var documenterSearchIndex = {"docs":
[{"location":"fematrix/#FEMatrix","page":"FEMatrix","title":"FEMatrix","text":"","category":"section"},{"location":"fematrix/","page":"FEMatrix","title":"FEMatrix","text":"A FEMatrix consists of FEMatrixBlocks that share a common ExtendableSparseMatrix. Each block is associated to two FESpaces and can only write into a submatrix of the common sparse matrix specified by offsets. It also acts as a two-dimensional AbstractArray itself.","category":"page"},{"location":"fematrix/","page":"FEMatrix","title":"FEMatrix","text":"Modules = [ExtendableFEMBase]\nPages = [\"fematrix.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fematrix/#ExtendableFEMBase.FEMatrix","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrix","text":"struct FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal} <: SparseArrays.AbstractSparseArray{TvM, TiM, 2}\n\nan AbstractMatrix (e.g. an ExtendableSparseMatrix) with an additional layer of several FEMatrixBlock subdivisions each carrying coefficients for their associated pair of FESpaces\n\n\n\n\n\n","category":"type"},{"location":"fematrix/#ExtendableFEMBase.FEMatrix-Tuple{FESpace, FESpace}","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrix","text":"FEMatrix{TvM,TiM}(FESX, FESY; name = \"auto\")\n\nCreates FEMatrix with one rectangular block (FESX,FESY) if FESX and FESY are single FESpaces, or a rectangular block matrix with blocks corresponding to the entries of the FESpace vectors FESX and FESY. Optionally a name for the matrix can be given.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.FEMatrix-Tuple{FESpace}","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrix","text":"FEMatrix{TvM,TiM}(name::String, FES::FESpace{TvG,TiG,FETypeX,APTX}) where {TvG,TiG,FETypeX,APTX}\n\nCreates FEMatrix with one square block (FES,FES).\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.FEMatrix-Union{Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}, Tuple{Vector{<:FESpace{TvG, TiG}}, Vector{<:FESpace{TvG, TiG}}}} where {TvM, TiM, TvG, TiG}","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrix","text":"FEMatrix{TvM,TiM}(FESX, FESY; name = \"auto\")\n\nCreates an FEMatrix with blocks coressponding to the ndofs of FESX (rows) and FESY (columns).\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.FEMatrixBlock","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrixBlock","text":"struct FEMatrixBlock{TvM, TiM, TvG, TiG, FETypeX, FETypeY, APTX, APTY} <: AbstractArray{TvM, 2}\n\nblock of an FEMatrix that carries coefficients for an associated pair of FESpaces and can be assigned as an two-dimensional AbstractArray (getindex, setindex, size)\n\n\n\n\n\n","category":"type"},{"location":"fematrix/#Base.fill!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv, Ti}, Any}} where {Tv, Ti}","page":"FEMatrix","title":"Base.fill!","text":"fill!(B::FEMatrixBlock{Tv, Ti}, value)\n\n\nCustom fill function for FEMatrixBlock (only fills the already present nzval in the block, not the complete FEMatrix).\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.length-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"Base.length","text":"length(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Any\n\n\nCustom length function for FEMatrix that gives the total number of defined FEMatrixBlocks in it\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.show-Union{Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}, Tuple{IO, FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"Base.show","text":"show(\n    io::IO,\n    FEM::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n)\n\n\nCustom show function for FEMatrix that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.size-Tuple{FEMatrixBlock}","page":"FEMatrix","title":"Base.size","text":"size(FEB::FEMatrixBlock) -> Tuple{Int64, Int64}\n\n\nCustom size function for FEMatrixBlock that gives a tuple with the size of the block (that coressponds to the number of degrees of freedoms in X and Y)\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.size-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"Base.size","text":"size(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Tuple{Any, Any}\n\n\nCustom size function for FEMatrix that gives a tuple with the number of rows and columns of the FEBlock overlay\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.add!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrix{Tv, Ti}, FEMatrix{Tv, Ti}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.add!","text":"add!(\n    A::FEMatrix{Tv, Ti},\n    B::FEMatrix{Tv, Ti};\n    factor,\n    transpose\n)\n\n\nAdds FEMatrix B to FEMatrix A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv, Ti}, FEMatrixBlock{Tv, Ti}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    A::FEMatrixBlock{Tv, Ti},\n    B::FEMatrixBlock{Tv, Ti};\n    factor,\n    transpose\n)\n\n\nAdds FEMatrixBlock B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv}, ExtendableSparseMatrix{Tv, Ti}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    A::FEMatrixBlock{Tv},\n    B::ExtendableSparseMatrix{Tv, Ti<:Integer};\n    factor,\n    transpose\n)\n\n\nAdds ExtendableSparseMatrix B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv}, SparseArrays.SparseMatrixCSC{Tv, Ti}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    A::FEMatrixBlock{Tv},\n    cscmat::SparseArrays.SparseMatrixCSC{Tv, Ti<:Integer};\n    factor,\n    transpose\n)\n\n\nAdds SparseMatrixCSC B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, FEMatrixBlock{Tv, Ti}, AbstractVector{Tv}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    a::AbstractArray{Tv, 1},\n    B::FEMatrixBlock{Tv, Ti},\n    b::AbstractArray{Tv, 1};\n    factor,\n    transposed\n)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv}, SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    A::FEMatrixBlock{Tv},\n    cscmatB::SparseArrays.SparseMatrixCSC{Tv, Ti},\n    cscmatC::SparseArrays.SparseMatrixCSC{Tv, Ti};\n    factor,\n    transposed\n)\n\n\nAdds matrix-matrix product B times C to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEVectorBlock{Tv}, ExtendableSparseMatrix{Tv, Ti}, FEVectorBlock{Tv}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    a::FEVectorBlock{Tv},\n    B::ExtendableSparseMatrix{Tv, Ti<:Integer},\n    b::FEVectorBlock{Tv};\n    factor\n)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEVectorBlock{Tv}, FEMatrixBlock{Tv, Ti}, FEVectorBlock{Tv}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    a::FEVectorBlock{Tv},\n    B::FEMatrixBlock{Tv, Ti},\n    b::FEVectorBlock{Tv};\n    factor,\n    transposed\n)\n\n\nAdds matrix-vector product B times b (or B' times b if transposed = true) to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.ldrdmatmul-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, AbstractVector{Tv}, ExtendableSparseMatrix{Tv, Ti}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.ldrdmatmul","text":"ldrdmatmul(\n    a1::AbstractArray{Tv, 1},\n    a2::AbstractArray{Tv, 1},\n    B::ExtendableSparseMatrix{Tv, Ti<:Integer},\n    b1::AbstractArray{Tv, 1},\n    b2::AbstractArray{Tv, 1};\n    factor\n) -> Any\n\n\nComputes vector'-matrix-vector product (a1-a2)'B(b1-b2).\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.lrmatmul-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, ExtendableSparseMatrix{Tv, Ti}, AbstractVector{Tv}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.lrmatmul","text":"lrmatmul(\n    a::AbstractArray{Tv, 1},\n    B::ExtendableSparseMatrix{Tv, Ti<:Integer},\n    b::AbstractArray{Tv, 1};\n    factor\n) -> Any\n\n\nComputes vector'-matrix-vector product a'Bb.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.nbcols-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"ExtendableFEMBase.nbcols","text":"nbcols(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Any\n\n\nGives the number of FEMatrixBlocks in each row.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.nbrows-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"ExtendableFEMBase.nbrows","text":"nbrows(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Any\n\n\nGives the number of FEMatrixBlocks in each column.\n\n\n\n\n\n","category":"method"},{"location":"examples/Example200_LowLevelPoisson/#:-Poisson-Problem","page":"200 : Poisson Problem","title":"200 : Poisson Problem","text":"","category":"section"},{"location":"examples/Example200_LowLevelPoisson/","page":"200 : Poisson Problem","title":"200 : Poisson Problem","text":"(source code)","category":"page"},{"location":"examples/Example200_LowLevelPoisson/","page":"200 : Poisson Problem","title":"200 : Poisson Problem","text":"This example computes the solution u of the two-dimensional Poisson problem","category":"page"},{"location":"examples/Example200_LowLevelPoisson/","page":"200 : Poisson Problem","title":"200 : Poisson Problem","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example200_LowLevelPoisson/","page":"200 : Poisson Problem","title":"200 : Poisson Problem","text":"with right-hand side f(xy) equiv xy and homogeneous Dirichlet boundary conditions on the unit square domain Omega on a given grid.","category":"page"},{"location":"examples/Example200_LowLevelPoisson/","page":"200 : Poisson Problem","title":"200 : Poisson Problem","text":"This script measures runtimes for grid generation, assembly and solving (direct/UMFPACK) for different refinement levels.","category":"page"},{"location":"examples/Example200_LowLevelPoisson/","page":"200 : Poisson Problem","title":"200 : Poisson Problem","text":"module Example200_LowLevelPoisson\n\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\nusing UnicodePlots\n\n# data for Poisson problem\nconst μ = 1.0\nconst f = x -> x[1] - x[2]\n\nfunction main(; maxnref = 8, order = 2, Plotter = nothing)\n\n\t# Finite element type\n\tFEType = H1Pk{1,2,order}\n\n\t# run once on a tiny mesh for compiling\n\tX = LinRange(0,1,4)\n\txgrid = simplexgrid(X,X)\n\tFES = FESpace{FEType}(xgrid)\n\tsol, time_assembly, time_solve = solve_poisson_lowlevel(FES, μ, f)\n\n\t# loop over uniform refinements + timings\n\tfor level = 1 : maxnref\n\t\tX = LinRange(0,1,2^level+1)\n\t\ttime_grid = @elapsed xgrid = simplexgrid(X,X)\n\t\ttime_facenodes = @elapsed xgrid[FaceNodes]\n\t\tFES = FESpace{FEType}(xgrid)\n\t\tprintln(\"\\nLEVEL = $level, ndofs = $(FES.ndofs)\\n\")\n\t\tif level < 4\n\t\t\tprintln(stdout, unicode_gridplot(xgrid))\n\t\tend\n\t\ttime_dofmap = @elapsed FES[CellDofs]\n\t\tsol, time_assembly, time_solve = solve_poisson_lowlevel(FES, μ, f)\n\n\t\t# plot statistics\n\t\tprintln(stdout, barplot([\"Grid\", \"FaceNodes\", \"CellDofs\", \"Assembly\", \"Solve\"], [time_grid, time_facenodes, time_dofmap, time_assembly, time_solve], title=\"Runtimes\"))\n\n\t\t# plot\n\t\tscalarplot(xgrid, view(sol.entries,1:num_nodes(xgrid)); Plotter = Plotter, levels = 5)\n\tend\n\n\treturn sol\nend\n\n\nfunction solve_poisson_lowlevel(FES, μ, f)\n\tSolution = FEVector(FES)\n\tFES = Solution[1].FES\n\tA = FEMatrix(FES, FES)\n\tb = FEVector(FES)\n\tprintln(\"Assembling...\")\n\ttime_assembly = @elapsed @time begin\n\t\tassemble!(A.entries, b.entries, FES, f, μ)\n\n\t\t# fix boundary dofs\n\t\tbegin\n\t\t\tBFaceDofs::Adjacency{Int32} = FES[ExtendableFEMBase.BFaceDofs]\n\t\t\tnbfaces::Int = num_sources(BFaceDofs)\n\t\t\tAM::ExtendableSparseMatrix{Float64,Int64} = A.entries\n\t\t\tdof_j::Int = 0\n\t\t\tfor bface = 1 : nbfaces\n\t\t\t\tfor j = 1 : num_targets(BFaceDofs,1)\n\t\t\t\t\tdof_j = BFaceDofs[j, bface]\n\t\t\t\t\tAM[dof_j,dof_j] = 1e60\n\t\t\t\t\tb.entries[dof_j] = 0\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tExtendableSparse.flush!(A.entries)\n\tend\n\n\t# solve\n\tprintln(\"Solving linear system...\")\n\ttime_solve = @elapsed @time copyto!(Solution.entries, A.entries \\ b.entries)\n\n\treturn Solution, time_assembly, time_solve\nend\n\nfunction assemble!(A::ExtendableSparseMatrix, b::Vector, FES, f, μ = 1)\n\txgrid = FES.xgrid\n\tEG = xgrid[UniqueCellGeometries][1]\n\tFEType = eltype(FES)\n\tL2G = L2GTransformer(EG, xgrid, ON_CELLS)\n\n\t# quadrature formula\n\tqf = QuadratureRule{Float64, EG}(2*(get_polynomialorder(FEType, EG)-1))\n\tweights::Vector{Float64} = qf.w\n\txref::Vector{Vector{Float64}} = qf.xref\n\tnweights::Int = length(weights)\n\tcellvolumes = xgrid[CellVolumes]\n\n\t# FE basis evaluator and dofmap\n\tFEBasis_∇ = FEEvaluator(FES, Gradient, qf)\n\t∇vals = FEBasis_∇.cvals\n\tFEBasis_id = FEEvaluator(FES, Identity, qf)\n\tidvals = FEBasis_id.cvals\n\tCellDofs = FES[ExtendableFEMBase.CellDofs]\n\n\t# ASSEMBLY LOOP\n\tfunction barrier(EG, L2G::L2GTransformer)\n\t\t# barrier function to avoid allocations by type dispatch\n\n\t\tndofs4cell::Int = get_ndofs(ON_CELLS, FEType, EG)\n\t\tAloc = zeros(Float64, ndofs4cell, ndofs4cell)\n\t\tncells::Int = num_cells(xgrid)\n\t\tdof_j::Int, dof_k::Int = 0, 0\n\t\tx::Vector{Float64} = zeros(Float64, 2)\n\n\t\tfor cell = 1 : ncells\n\t\t\t# update FE basis evaluators\n\t\t\tFEBasis_∇.citem[] = cell\n\t\t\tupdate_basis!(FEBasis_∇)\n\n\t\t\t# assemble local stiffness matrix\n\t\t\tfor j = 1 : ndofs4cell, k = j : ndofs4cell\n\t\t\t\ttemp = 0\n\t\t\t\tfor qp = 1 : nweights\n\t\t\t\t\ttemp += weights[qp] * dot(view(∇vals,:,j,qp), view(∇vals,:,k,qp))\n\t\t\t\tend\n\t\t\t\tAloc[j,k] = temp\n\t\t\tend\n\t\t\tAloc .*= μ * cellvolumes[cell]\n\n\t\t\t# add local matrix to global matrix\n\t\t\tfor j = 1 : ndofs4cell\n\t\t\t\tdof_j = CellDofs[j, cell]\n\t\t\t\tfor k = j : ndofs4cell\n\t\t\t\t\tdof_k = CellDofs[k, cell]\n\t\t\t\t\tif abs(Aloc[j,k]) > 1e-15\n\t\t\t\t\t\t# write into sparse matrix, only lines with allocations\n\t\t\t\t\t\trawupdateindex!(A, +, Aloc[j,k], dof_j, dof_k)\n\t\t\t\t\t\tif k > j\n\t\t\t\t\t\t\trawupdateindex!(A, +, Aloc[j,k], dof_k, dof_j)\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tfill!(Aloc, 0)\n\n\t\t\t# assemble right-hand side\n\t\t\tupdate_trafo!(L2G, cell)\n\t\t\tfor j = 1 : ndofs4cell\n\t\t\t\t# right-hand side\n\t\t\t\ttemp = 0\n\t\t\t\tfor qp = 1 : nweights\n\t\t\t\t\t# get global x for quadrature point\n\t\t\t\t\teval_trafo!(x, L2G, xref[qp])\n\t\t\t\t\t# evaluate (f(x), v_j(x))\n\t\t\t\t\ttemp += weights[qp] * idvals[1, j, qp] * f(x)\n\t\t\t\tend\n\t\t\t\t# write into global vector\n\t\t\t\tdof_j = CellDofs[j, cell]\n\t\t\t\tb[dof_j] += temp * cellvolumes[cell]\n\t\t\tend\n\t\tend\n\tend\n\tbarrier(EG, L2G)\n\tflush!(A)\nend\n\nend #module","category":"page"},{"location":"examples/Example200_LowLevelPoisson/","page":"200 : Poisson Problem","title":"200 : Poisson Problem","text":"","category":"page"},{"location":"examples/Example200_LowLevelPoisson/","page":"200 : Poisson Problem","title":"200 : Poisson Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example200_LowLevelPoisson/","page":"200 : Poisson Problem","title":"200 : Poisson Problem","text":"Default output:","category":"page"},{"location":"examples/Example200_LowLevelPoisson/","page":"200 : Poisson Problem","title":"200 : Poisson Problem","text":"julia> Example200_LowLevelPoisson.main()\nAssembling...\n 11.400272 seconds (13.80 M allocations: 912.276 MiB, 4.86% gc time, 99.94% compilation time)\nSolving linear system...\n  0.101854 seconds (39.70 k allocations: 2.445 MiB, 99.50% compilation time)\n\nLEVEL = 1, ndofs = 25\n\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⢸│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸│ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⢸│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸│ \n    │⣇⣔⣁⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣇⣔⣁⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣸│ \n    └────────────────────────────────────────┘ \nAssembling...\n  0.000214 seconds (202 allocations: 28.445 KiB)\nSolving linear system...\n  0.000095 seconds (54 allocations: 16.734 KiB)\n                              Runtimes                  \n             ┌                                        ┐ \n        Grid ┤ 1.67e⁻⁵                                  \n   FaceNodes ┤ 6.92e⁻⁵                                  \n    CellDofs ┤■■■■■ 0.00344539                          \n    Assembly ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.0191822   \n       Solve ┤ 0.000109599                              \n             └                                        ┘ \n\nLEVEL = 2, ndofs = 81\n\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⢸│ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⢸│ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⢸│ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⢸│ \n    │⣇⣔⣁⣀⣀⣀⣀⣀⣀⣀⣇⣔⣁⣀⣀⣀⣀⣀⣀⣀⣇⣔⣁⣀⣀⣀⣀⣀⣀⣀⣇⣔⣁⣀⣀⣀⣀⣀⣀⣸│ \n    └────────────────────────────────────────┘ \nAssembling...\n  0.000284 seconds (202 allocations: 55.258 KiB)\nSolving linear system...\n  0.000151 seconds (58 allocations: 58.812 KiB)\n                              Runtimes                  \n             ┌                                        ┐ \n        Grid ┤■■ 1.86e⁻⁵                                \n   FaceNodes ┤■■■■■■■ 8.04e⁻⁵                           \n    CellDofs ┤■■■■ 4.06e⁻⁵                              \n    Assembly ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.000300799   \n       Solve ┤■■■■■■■■■■■■■■ 0.0001573                  \n             └                                        ┘ \n\nLEVEL = 3, ndofs = 289\n\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⢽│ \n    │⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⢸│ \n    │⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢼│ \n    │⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⢹│ \n    │⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⢸│ \n    │⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⢽│ \n    │⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⢸│ \n    │⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢼│ \n    │⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⢹│ \n    │⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⢸│ \n    │⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⢽│ \n    │⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⢸│ \n    │⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢼│ \n    │⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⢹│ \n    │⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⢸│ \n    │⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⠝⡏⠉⠉⢉⢽│ \n    │⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⠀⡇⢀⠔⠁⢸│ \n    │⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢤⡷⠥⠤⠤⢼│ \n    │⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⢹│ \n    │⣇⣔⣁⣀⣀⣇⣔⣁⣀⣀⣇⣔⣁⣀⣀⣇⣔⣁⣀⣀⣇⣔⣁⣀⣀⣇⣔⣁⣀⣀⣇⣔⣁⣀⣀⣇⣔⣁⣀⣸│ \n    └────────────────────────────────────────┘ \nAssembling...\n  0.000684 seconds (202 allocations: 120.352 KiB)\nSolving linear system...\n  0.000381 seconds (59 allocations: 217.562 KiB)\n                              Runtimes                  \n             ┌                                        ┐ \n        Grid ┤■ 1.47e⁻⁵                                 \n   FaceNodes ┤■■■ 6.4899e⁻⁵                             \n    CellDofs ┤■■ 4.74e⁻⁵                                \n    Assembly ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.000693798   \n       Solve ┤■■■■■■■■■■■■■■■ 0.000386999               \n             └                                        ┘ \n\nLEVEL = 4, ndofs = 1089\n\nAssembling...\n  0.001629 seconds (205 allocations: 422.648 KiB)\nSolving linear system...\n  0.001180 seconds (63 allocations: 881.516 KiB)\n                              Runtimes                  \n             ┌                                        ┐ \n        Grid ┤■ 3.02e⁻⁵                                 \n   FaceNodes ┤■■■ 0.000160499                           \n    CellDofs ┤■■ 0.0001333                              \n    Assembly ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.0016374   \n       Solve ┤■■■■■■■■■■■■■■■■■■■■■ 0.0011877           \n             └                                        ┘ \n\nLEVEL = 5, ndofs = 4225\n\nAssembling...\n  0.006184 seconds (210 allocations: 1.187 MiB)\nSolving linear system...\n  0.005359 seconds (65 allocations: 3.642 MiB)\n                              Runtimes                  \n             ┌                                        ┐ \n        Grid ┤ 8.52e⁻⁵                                  \n   FaceNodes ┤■■■ 0.000570198                           \n    CellDofs ┤■■ 0.000491199                            \n    Assembly ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.00619569   \n       Solve ┤■■■■■■■■■■■■■■■■■■■■■■■■ 0.00537409       \n             └                                        ┘ \n\nLEVEL = 6, ndofs = 16641\n\nAssembling...\n  0.026814 seconds (215 allocations: 6.522 MiB)\nSolving linear system...\n  0.025550 seconds (69 allocations: 15.576 MiB)\n                              Runtimes                  \n             ┌                                        ┐ \n        Grid ┤ 0.0002811                                \n   FaceNodes ┤■■ 0.0021104                              \n    CellDofs ┤■■ 0.00195619                             \n    Assembly ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.0268316   \n       Solve ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.025581     \n             └                                        ┘ \n\nLEVEL = 7, ndofs = 66049\n\nAssembling...\n  0.101214 seconds (216 allocations: 20.700 MiB)\nSolving linear system...\n  0.121644 seconds (69 allocations: 66.420 MiB, 15.58% gc time)\n                              Runtimes                  \n             ┌                                        ┐ \n        Grid ┤ 0.0010556                                \n   FaceNodes ┤■■■■■■ 0.0242355                          \n    CellDofs ┤■■ 0.00730908                             \n    Assembly ┤■■■■■■■■■■■■■■■■■■■■■■■■■ 0.101237        \n       Solve ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.121679   \n             └                                        ┘ \n\nLEVEL = 8, ndofs = 263169\n\nAssembling...\n  0.407991 seconds (220 allocations: 82.609 MiB, 0.90% gc time)\nSolving linear system...\n  0.491642 seconds (69 allocations: 285.247 MiB, 1.45% gc time)\n                              Runtimes                  \n             ┌                                        ┐ \n        Grid ┤ 0.00441189                               \n   FaceNodes ┤■■ 0.0335853                              \n    CellDofs ┤■■ 0.0307502                              \n    Assembly ┤■■■■■■■■■■■■■■■■■■■■■■■■■ 0.408018        \n       Solve ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.491678   \n             └                                        ┘ ","category":"page"},{"location":"interpolations/#Finite-Element-Interpolations","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"","category":"section"},{"location":"interpolations/#Standard-Interpolations","page":"Finite Element Interpolations","title":"Standard Interpolations","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"Each finite element has its standard interpolator that can be applied to some user-defined DataFunction. Instead of interpolating on the full cells, the interpolation can be restricted to faces or edges. ","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"It is also possible to interpolate finite element functions on one grid onto a finite element function on another grid (experimental feature, does not work for all finite elements yet and shall be extended to interpolations of operator evaluations as well in future).","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"interpolate!","category":"page"},{"location":"interpolations/#ExtendableGrids.interpolate!","page":"Finite Element Interpolations","title":"ExtendableGrids.interpolate!","text":"function ExtendableGrids.interpolate!(target::FEVectorBlock,\n     AT::Type{<:AssemblyType},\n     source::UserData{AbstractDataFunction};\n     items = [],\n     time = 0)\n\nInterpolates the given source into the finite elements space assigned to the target FEVectorBlock with the specified AssemblyType (usualy ON_CELLS). The optional time argument is only used if the source depends on time.\n\n\n\n\n\nfunction ExtendableGrids.interpolate!(target::FEVectorBlock,\n     source::UserData{AbstractDataFunction};\n     items = [],\n     time = 0)\n\nInterpolates the given source into the finite element space assigned to the target FEVectorBlock. The optional time argument is only used if the source depends on time.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#Nodal-Evaluations","page":"Finite Element Interpolations","title":"Nodal Evaluations","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"Usually, Plotters need nodal values, so there is a gengeric function that evaluates any finite element function at the nodes of the grids (possibly by averaging if discontinuous). In case of Identity evaluations of an H1-conforming finite element, the function nodevalues_view can generate a view into the coefficient field that avoids further allocations.","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"nodevalues!\nnodevalues\nnodevalues_view","category":"page"},{"location":"interpolations/#ExtendableFEMBase.nodevalues!","page":"Finite Element Interpolations","title":"ExtendableFEMBase.nodevalues!","text":"function nodevalues!(\n    target::AbstractArray{<:Real,2},\n    source::AbstractArray{T,1},\n    FE::FESpace{Tv,Ti,FEType,AT},\n    operator::Type{<:AbstractFunctionOperator} = Identity;\n    regions::Array{Int,1} = [0],\n    abs::Bool = false,\n    factor = 1,\n    target_offset::Int = 0,   # start to write into target after offset\n    zero_target::Bool = true, # target vector is zeroed\n    continuous::Bool = false)\n\nEvaluates the finite element function with the coefficient vector source (interpreted as a coefficient vector for the FESpace FE) and the specified FunctionOperator at all the nodes of the (specified regions of the) grid and writes the values into target. Discontinuous (continuous = false) quantities are averaged.\n\n\n\n\n\nfunction nodevalues!(\n    target::AbstractArray{<:Real,2},\n    source::FEVectorBlock,\n    operator::Type{<:AbstractFunctionOperator} = Identity;\n    regions::Array{Int,1} = [0],\n    abs::Bool = false,\n    factor = 1,\n    target_offset::Int = 0,   # start to write into target after offset\n    zero_target::Bool = true, # target vector is zeroed\n    continuous::Bool = false)\n\nEvaluates the finite element function with the coefficient vector source and the specified FunctionOperator at all the nodes of the (specified regions of the) grid and writes the values into target. Discontinuous (continuous = false) quantities are averaged.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#ExtendableFEMBase.nodevalues","page":"Finite Element Interpolations","title":"ExtendableFEMBase.nodevalues","text":"function nodevalues(\n    source::FEVectorBlock,\n    operator::Type{<:AbstractFunctionOperator} = Identity;\n    regions::Array{Int,1} = [0],\n    abs::Bool = false,\n    factor = 1,\n    target_offset::Int = 0,   # start to write into target after offset\n    zero_target::Bool = true, # target vector is zeroed\n    continuous::Bool = false)\n\nEvaluates the finite element function with the coefficient vector source and the specified FunctionOperator at all the nodes of the (specified regions of the) grid and returns an array with the values. Discontinuous (continuous = false) quantities are averaged.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#ExtendableFEMBase.nodevalues_view","page":"Finite Element Interpolations","title":"ExtendableFEMBase.nodevalues_view","text":"function nodevalues_view(\n    source::FEVectorBlock,\n    operator::Type{<:AbstractFunctionOperator} = Identity)\n\nReturns a vector of views of the nodal values of the source block (currently works for unbroken H1-conforming elements) that directly accesses the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#Lazy-Interpolation","page":"Finite Element Interpolations","title":"Lazy Interpolation","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"To interpolate between different finite element spaces and meshes, there is a lazy interpolation routine that works in all cases (but is not very efficient as it involves a PointeEvaluator and CellFinder):","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"lazy_interpolate!","category":"page"},{"location":"interpolations/#ExtendableFEMBase.lazy_interpolate!","page":"Finite Element Interpolations","title":"ExtendableFEMBase.lazy_interpolate!","text":"function lazy_interpolate!(\n    target::FEVectorBlock{T1,Tv,Ti},\n    source::FEVectorBlock{T2,Tv,Ti};\n    operator = Identity,\n    postprocess = nothing,\n    xtrafo = nothing,\n    items = [],\n    not_in_domain_value = 1e30,\n    use_cellparents::Bool = false) where {T1,T2,Tv,Ti}\n\nInterpolates (operator-evaluations of) the given finite element function into the finite element space assigned to the target FEVectorBlock.  (Currently not the most efficient way as it is based on the PointEvaluation pattern and cell search. If CellParents are available in the grid components of the target grid, these parent cell information can be used to improve the search. To activate this put 'use_cellparents' = true). By some given kernel function (result, input, qpinfo) the operator evaluation (=input) can be further postprocessed.\n\nNote: discontinuous quantities at vertices of the target grid will be evaluted in the first found cell of the source grid. No averaging is performed.\n\n\n\n\n\n","category":"function"},{"location":"package_index/","page":"Index","title":"Index","text":"Modules = [ExtendableFEMBase]\nOrder   = [:function, :type]","category":"page"},{"location":"fevector/#FEVector","page":"FEVector","title":"FEVector","text":"","category":"section"},{"location":"fevector/","page":"FEVector","title":"FEVector","text":"A FEVector consists of FEVectorBlocks that share a common one-dimensional array. Each block is associated to a FESpace and can only write into a region of the common array specified by offsets. It also acts as a one-dimensional AbstractArray itself.","category":"page"},{"location":"fevector/","page":"FEVector","title":"FEVector","text":"Modules = [ExtendableFEMBase]\nPages = [\"fevector.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fevector/#ExtendableFEMBase.FEVector","page":"FEVector","title":"ExtendableFEMBase.FEVector","text":"struct FEVector{T, Tv, Ti}\n\na plain array but with an additional layer of several FEVectorBlock subdivisions each carrying coefficients for their associated FESpace. The j-th block can be accessed by getindex(::FEVector, j) or by getindex(::FEVector, tag) if tags are associated. The full vector can be accessed via FEVector.entries \n\n\n\n\n\n","category":"type"},{"location":"fevector/#ExtendableFEMBase.FEVector-Union{Tuple{FESpace{Tv, Ti, FEType, APT}}, Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType, APT}","page":"FEVector","title":"ExtendableFEMBase.FEVector","text":"FEVector{T}(FES; name = nothing, tags = nothing, kwargs...) where T <: Real\n\nCreates FEVector that has one block if FES is a single FESpace, and a blockwise FEVector if FES is a vector of FESpaces. Optionally a name for the vector (as a String) or each of the blocks (as a vector of Strings), or tags (as an Array{Any}) for the blocks can be specified.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.FEVectorBlock","page":"FEVector","title":"ExtendableFEMBase.FEVectorBlock","text":"struct FEVectorBlock{T, Tv, Ti, FEType, APT} <: AbstractArray{T, 1}\n\nblock of an FEVector that carries coefficients for an associated FESpace and can be assigned as an AbstractArray (getindex, setindex, size, length)\n\n\n\n\n\n","category":"type"},{"location":"fevector/#Base.append!-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{T}, Tuple{FEVector{T}, FESpace{Tv, Ti, FEType, APT}}} where {T, Tv, Ti, FEType, APT}","page":"FEVector","title":"Base.append!","text":"append!(\n    FEF::FEVector{T},\n    FES::FESpace{Tv, Ti, FEType, APT};\n    name,\n    tag\n)\n\n\nOverloaded append function for FEVector that adds a FEVectorBlock at the end.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.fill!-Tuple{FEVectorBlock, Any}","page":"FEVector","title":"Base.fill!","text":"fill!(b::FEVectorBlock, value)\n\n\nOverloaded fill function for FEVectorBlock (only fills the block, not the complete FEVector).\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.length-Tuple{FEVectorBlock}","page":"FEVector","title":"Base.length","text":"length(FEB::FEVectorBlock) -> Int64\n\n\nCustom length function for FEVectorBlock that gives the coressponding number of degrees of freedoms of the associated FESpace\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.length-Tuple{FEVector}","page":"FEVector","title":"Base.length","text":"length(FEF::FEVector) -> Int64\n\n\nCustom length function for FEVector that gives the number of defined FEMatrixBlocks in it\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.show-Tuple{IO, FEVector}","page":"FEVector","title":"Base.show","text":"show(io::IO, FEF::FEVector)\n\n\nCustom show function for FEVector that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.view-Tuple{FEVectorBlock}","page":"FEVector","title":"Base.view","text":"returns a view of the part of the full FEVector that coressponds to the block. \n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.FESpaces-Union{Tuple{FEVector{T, Tv, Ti}}, Tuple{Ti}, Tuple{Tv}, Tuple{T}} where {T, Tv, Ti}","page":"FEVector","title":"ExtendableFEMBase.FESpaces","text":"FESpaces(FEV::FEVector{T, Tv, Ti}) -> Any\n\n\nReturns the vector of FEspaces for the blocks of the given FEVector.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.addblock!-Tuple{FEVectorBlock, AbstractVector}","page":"FEVector","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    a::FEVectorBlock,\n    b::AbstractVector;\n    factor,\n    offset\n)\n\n\nAdds Array b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.addblock!-Tuple{FEVectorBlock, FEVectorBlock}","page":"FEVector","title":"ExtendableFEMBase.addblock!","text":"addblock!(a::FEVectorBlock, b::FEVectorBlock; factor)\n\n\nAdds FEVectorBlock b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#LinearAlgebra.dot-Union{Tuple{T}, Tuple{FEVectorBlock{T}, FEVectorBlock{T}}} where T","page":"FEVector","title":"LinearAlgebra.dot","text":"dot(a::FEVectorBlock{T}, b::FEVectorBlock{T}) -> Any\n\n\nScalar product between two FEVEctorBlocks\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#PointEvaluator","page":"PointEvaluator","title":"PointEvaluator","text":"","category":"section"},{"location":"pointevaluators/","page":"PointEvaluator","title":"PointEvaluator","text":"Point evaluators allow to evaluate a finite element function (FEVector) at arbitrary points.","category":"page"},{"location":"pointevaluators/","page":"PointEvaluator","title":"PointEvaluator","text":"Modules = [ExtendableFEMBase]\nPages = [\"point_evaluator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pointevaluators/#ExtendableFEMBase.PointEvaluator","page":"PointEvaluator","title":"ExtendableFEMBase.PointEvaluator","text":"function Pointevaluator(\n    [kernel!::Function],\n    oa_args::Array{<:Tuple{<:Any, DataType},1};\n    kwargs...)\n\nGenerates a PointEvaluator that can evaluate the specified operator evaluations at arbitrary points. If no kernel function is given, the arguments are given directly. If a kernel is provided, the arguments are postprocessed accordingly and the kernel has be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current evaluation point. Additionally the length of the result needs to be specified via the kwargs.\n\nEvaluation can be triggered via the evaluate function after an initialize! call.\n\nOperator evaluations are tuples that pair a tag (to identify an unknown or the position in the vector) with a FunctionOperator.\n\nKeyword arguments:\n\nresultdim: dimension of result field (default = length of operators). Default: 0\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nname: name for operator used in printouts. Default: ''PointEvaluator''\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"pointevaluators/#ExtendableFEMBase.eval_func-Tuple{PointEvaluator}","page":"PointEvaluator","title":"ExtendableFEMBase.eval_func","text":"function eval_func(PE::PointEvaluator)\n\nYields the function (result, xref, item) -> evaluate!(result,PE,xref,item) that can be, e.g., used in a vectorplot.\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#ExtendableFEMBase.evaluate!-Tuple{Any, PointEvaluator, Any, Any}","page":"PointEvaluator","title":"ExtendableFEMBase.evaluate!","text":"function evaluate!(\n    result,\n    PE::PointEvaluator,\n    xref, \n    item\n    )\n\nEvaluates the PointEvaluator at the specified reference coordinates in the cell with the specified item number.\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#ExtendableFEMBase.initialize!-Union{Tuple{UT}, Tuple{T}, Tuple{PointEvaluator{T, UT}, Any}} where {T, UT}","page":"PointEvaluator","title":"ExtendableFEMBase.initialize!","text":"function initialize!(\n    O::PointEvaluator,\n    sol;\n    time = 0,\n    kwargs...)\n\nInitializes the PointEvaluator for the specified solution.\n\n\n\n\n\n","category":"method"},{"location":"examples/Example290_InterpolationBetweenMeshes/#:-Interpolation-Between-Meshes","page":"290 : Interpolation Between Meshes","title":"290 : Interpolation Between Meshes","text":"","category":"section"},{"location":"examples/Example290_InterpolationBetweenMeshes/","page":"290 : Interpolation Between Meshes","title":"290 : Interpolation Between Meshes","text":"(source code)","category":"page"},{"location":"examples/Example290_InterpolationBetweenMeshes/","page":"290 : Interpolation Between Meshes","title":"290 : Interpolation Between Meshes","text":"This example demonstrates the interpolation between meshes feature. Here, we interpolate a function with the P2 element of a coarse triangulation and then interpolate this P2 function on two uniform refinements into some P1 function. Then, both finite element functions are plotted.","category":"page"},{"location":"examples/Example290_InterpolationBetweenMeshes/","page":"290 : Interpolation Between Meshes","title":"290 : Interpolation Between Meshes","text":"module Example290_InterpolationBetweenMeshes\n\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing GridVisualize\n\n# function to interpolate\nfunction u!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = sin(4*pi*x[1])*sin(4*pi*x[2]);\n    result[2] = cos(4*pi*x[1])*cos(4*pi*x[2]);\nend\n\n# everything is wrapped in a main function\nfunction main(; ν = 1e-3, nrefs = 4, Plotter = nothing)\n\n    # generate two grids\n    xgrid1 = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n    xgrid2 = uniform_refine(xgrid1, 3; store_parents = true)\n\n    @show xgrid1 xgrid2\n\n    # set finite element types for the two grids\n    FEType1 = H1Pk{2,2,2}\n    FEType2 = H1Pk{2,2,1}\n\n    # generate coressponding finite element spaces and FEVectors\n    FES1 = FESpace{FEType1}(xgrid1)\n    FES2 = FESpace{FEType2}(xgrid2)\n    FEFunction1 = FEVector(FES1)\n    FEFunction2 = FEVector(FES2)\n\n    # interpolate function onto first grid\n    @time interpolate!(FEFunction1[1], u!)\n    @time interpolate!(FEFunction2[1], u!)\n\n    # interpolate onto other grid\n    @time lazy_interpolate!(FEFunction2[1], FEFunction1)\n    @time lazy_interpolate!(FEFunction2[1], FEFunction1; use_cellparents = true)\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1], xgrid1, view(nodevalues(FEFunction1[1]),1,:), levels = 11, title = \"u_h ($FEType1, coarse grid)\")\n    scalarplot!(p[1,2], xgrid2, view(nodevalues(FEFunction2[1]),1,:), levels = 11, title = \"u_h ($FEType2, fine grid)\")\nend\n\nend","category":"page"},{"location":"examples/Example290_InterpolationBetweenMeshes/","page":"290 : Interpolation Between Meshes","title":"290 : Interpolation Between Meshes","text":"","category":"page"},{"location":"examples/Example290_InterpolationBetweenMeshes/","page":"290 : Interpolation Between Meshes","title":"290 : Interpolation Between Meshes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example290_InterpolationBetweenMeshes/","page":"290 : Interpolation Between Meshes","title":"290 : Interpolation Between Meshes","text":"Default output:","category":"page"},{"location":"examples/Example290_InterpolationBetweenMeshes/","page":"290 : Interpolation Between Meshes","title":"290 : Interpolation Between Meshes","text":"julia> Example290_InterpolationBetweenMeshes.main()\nxgrid1 = ExtendableGrid{Float64, Int32};\ndim: 2 nodes: 545 cells: 1024 bfaces: 64\n\n\nxgrid2 = ExtendableGrid{Float64, Int32};\ndim: 2 nodes: 33025 cells: 65536 bfaces: 512\n\n\n  1.453655 seconds (1.33 M allocations: 88.938 MiB, 4.16% gc time, 99.80% compilation time)\n  0.418520 seconds (569.00 k allocations: 52.398 MiB, 6.37% gc time, 90.79% compilation time)\n  1.577442 seconds (1.39 M allocations: 89.844 MiB, 3.16% gc time, 93.77% compilation time)\n  0.258862 seconds (236.19 k allocations: 12.747 MiB, 10.50% gc time, 63.29% compilation time)","category":"page"},{"location":"segmentintegrators/#SegmentIntegrator","page":"SegmentIntegrator","title":"SegmentIntegrator","text":"","category":"section"},{"location":"segmentintegrators/","page":"SegmentIntegrator","title":"SegmentIntegrator","text":"Segment integrators allow to integrate a finite element function (FEVector) along arbitrary lines through mesh cells.","category":"page"},{"location":"segmentintegrators/","page":"SegmentIntegrator","title":"SegmentIntegrator","text":"Modules = [ExtendableFEMBase]\nPages = [\"segment_integrator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"segmentintegrators/#ExtendableFEMBase.SegmentIntegrator-Tuple{Any, Any, Vector{<:Tuple{Any, DataType}}}","page":"SegmentIntegrator","title":"ExtendableFEMBase.SegmentIntegrator","text":"function SegmentIntegrator(\n    EG::ElementGeometry,\n    [kernel!::Function],\n    oa_args::Array{<:Tuple{<:Any, DataType},1};\n    kwargs...)\n\nGenerates an SegmentIntegrator that can intgrate over segments of the specified geometry EG. To do so, it evaluates, at each quadrature point, the specified operator evaluations, postprocesses them with the kernel function (if provided) and accumulates the results with the quadrature weights. If no kernel is given, the arguments are integrated directly. If a kernel is provided it has be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point. Additionally the length of the result needs to be specified via the kwargs.\n\nEvaluation can be triggered via the integrate_segment! function after an initialize!\n\nOperator evaluations are tuples that pair a tag (to identify an unknown or the position in the vector) with a FunctionOperator.\n\nKeyword arguments:\n\nfactor: factor that should be multiplied during assembly. Default: 1\nresultdim: dimension of result field (default = length of arguments). Default: 0\nmatrix_mode: integrator integrates basis functions of FEspace seperately to assembly a matrix that maps solution to segment integrations (requires that kernel is linear). Default: false\nname: name for operator used in printouts. Default: ''SegmentIntegrator''\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentrytolerance: threshold to add entry to sparse matrix (only in matrixmode). Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"segmentintegrators/#ExtendableFEMBase.initialize!-Union{Tuple{UT}, Tuple{T}, Tuple{SegmentIntegrator{T, UT}, Any}} where {T, UT}","page":"SegmentIntegrator","title":"ExtendableFEMBase.initialize!","text":"function initialize!(\n    O::SegmentIntegrator{T, UT},\n    sol;\n    time = 0,\n    kwargs...)\n\nInitializes the SegmentIntegrator for the specified solution.\n\n\n\n\n\n","category":"method"},{"location":"segmentintegrators/#ExtendableFEMBase.integrate_segment!-Union{Tuple{T}, Tuple{Vector{T}, SegmentIntegrator, Array{Vector{T}, 1}, Array{Vector{T}, 1}, Any}} where T","page":"SegmentIntegrator","title":"ExtendableFEMBase.integrate_segment!","text":"function integrate_segment!(\n    result::Array{T,1},\n    SI::SegmentIntegrator,\n    w::Array{Array{T,1},1},\n    b::Array{Array{T,1},1},\n    item\n    ) where {T}\n\nIntegrate a segment with world coordinates w and barycentric coordinates b in the cell with the given item number.\n\n\n\n\n\n","category":"method"},{"location":"plots/#Plots","page":"Plots","title":"Plots","text":"","category":"section"},{"location":"plots/#GridVisualize","page":"Plots","title":"GridVisualize","text":"","category":"section"},{"location":"plots/","page":"Plots","title":"Plots","text":"Plotting is possible e.g. via Nodal Evaluations and the plot routines from ExtendableGrids.jl. For an example see one of the many examples with plots in the example section.","category":"page"},{"location":"plots/#UnicodePlots","page":"Plots","title":"UnicodePlots","text":"","category":"section"},{"location":"plots/","page":"Plots","title":"Plots","text":"For a fast and rough peak several UnicodePlots plotters are available:","category":"page"},{"location":"plots/","page":"Plots","title":"Plots","text":"Modules = [ExtendableFEMBase]\nPages = [\"plots.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"plots/#ExtendableFEMBase.unicode_gridplot-Tuple{ExtendableGrid}","page":"Plots","title":"ExtendableFEMBase.unicode_gridplot","text":"function unicode_gridplot(\n    xgrid::ExtendableGrid;\n    title = \"gridplot\",\n    resolution = (40,20),\n    color = (200,200,200),\n    bface_color = (255,0,0),\n    CanvasType = BrailleCanvas,\n    plot_based = ON_CELLS,   # or ON_FACES/ON_EDGES\n    kwargs...\n\nPlots the grid on a UnicodePlots canvas (default: BrailleCanvas) by drawing all edges in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"plots/#ExtendableFEMBase.unicode_scalarplot-Tuple{FEVectorBlock}","page":"Plots","title":"ExtendableFEMBase.unicode_scalarplot","text":"function unicode_scalarplot(\n    u::FEVectorBlock; \n    component = 1,\n    resolution = (40,40),\n    colormap = :viridis,\n    title = u.name,\n    kwargs...)\n\nPlots a component of the finite element function in the FEVectorBlock u by using a lazy_interpolate! onto a coarse uniform mesh and UnicodePlots.jl heatmap.\n\n\n\n\n\n","category":"method"},{"location":"functionoperators/#Function-Operators","page":"Function Operators","title":"Function Operators","text":"","category":"section"},{"location":"functionoperators/#StandardFunctionOperators","page":"Function Operators","title":"StandardFunctionOperators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"StandardFunctionOperators are abstract types that encode primitive (linear) operators (like Identity, Gradient etc.) used to dispatch different evaluations of finite element basis functions.","category":"page"},{"location":"functionoperators/#List-of-primitive-operators","page":"Function Operators","title":"List of primitive operators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"StandardFunctionOperator Description Mathematically\nIdentity identity v rightarrow v\nIdentityComponent{c} identity of c-th component v rightarrow v_c\nNormalFlux normal flux (function times normal) v rightarrow v cdot vecn (only ON_FACES)\nTangentFlux tangent flux (function times tangent) v rightarrow v cdot vect (only ON_EDGES)\nGradient gradient/Jacobian (as a vector) v rightarrow nabla v\nSymmetricGradient symmetric part of the gradient v rightarrow Voigt(mathrmsym(nabla v))\nDivergence divergence v rightarrow mathrmdiv(v) = nabla cdot v\nCurlScalar curl operator 1D to 2D (rotated gradient) v rightarrow -dvdx_2dvdx_1\nCurl2D curl operator 2D to 1D v rightarrow dv_1dx_2 - dv_2dx_1\nCurl3D curl operator 3D to 3D v rightarrow nabla times v\nHessian Hesse matrix = all 2nd order derivatives (as a vector) v rightarrow D^2 v      (e.g. in 2D: xx,xy,yx,yy for each component)\nSymmetricHessian{a} symmetric part of Hesse matrix, offdiagonals scaled by a v rightarrow sym(D^2 v) (e.g. in 2D: xx,yy,a*xy for each component)\nLaplacian Laplace Operator (diagonal of Hessian) v rightarrow Delta v   (e.g. in 2D: xx,yy for each component)","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"note: Note\nAs each finite element type is transformed differently from the reference domain to the general domain, the evaluation of each function operator has to be implemented for each finite element class. Currently, not every function operator works in any dimension and for any finite element. More evaluations are added as soon as they are needed (and possibly upon request). Also, the function operators can be combined with user-defined actions to evaluate other operators that can be build from the ones available (e.g. the deviator).","category":"page"},{"location":"functionoperators/#ReconstructionOperators","page":"Function Operators","title":"ReconstructionOperators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"There are special operators that allow to evaluate a primitive operator of some discrete reconstructed version of a testfunction. ","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Modules = [ExtendableFEMBase]\nPages = [\"reconstructionoperators.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"functionoperators/#ExtendableFEMBase.Reconstruct","page":"Function Operators","title":"ExtendableFEMBase.Reconstruct","text":"abstract type Reconstruct{FETypeR, O} <: ??\n\nreconstruction operator: evaluates a reconstructed version of the finite element function.\n\nFETypeR specifies the reconstruction space (needs to be defined for the finite element that it is applied to). O specifies the StandardFunctionOperator that shall be evaluated.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#Divergence-free-reconstruction-operators","page":"Function Operators","title":"Divergence-free reconstruction operators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"For gradient-robust discretisations of certain classical non divergence-conforming ansatz spaces, reconstruction operators are available that map a discretely divergence-free H1 function to a pointwise divergence-free Hdiv function. So far such operators are available for the vector-valued Crouzeix-Raviart (H1CR) and Bernardi–Raugel (H1BR) finite element types, as well as for the P2-bubble (H1P2B) finite element type in two dimensions.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Example: Reconst{HDIVRT0{d}, Identity} gives the reconstruction of the Identity operator into HDIVRT0 (and is available for H1BR{d} and H1CR{d} for d = 1,2)","category":"page"},{"location":"functionoperators/#Operator-Pairs-(experimental)","page":"Function Operators","title":"Operator Pairs (experimental)","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Two function operators can be put into an OperatorPair so that one can provide effectively two operators in each argument of an assembly pattern. However, the user should make sure that both operators can be evaluated together reasonably (meaning both should be well-defined on the element geometries and the finite element space where the argument will be evaluated, and the action of the operator has to operate with coressponding input and result fields). This feature is still experimental and might have issues in some cases. OperatorTriple for a combination of three operators is also available.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"OperatorPair\nOperatorTriple","category":"page"},{"location":"functionoperators/#ExtendableFEMBase.OperatorPair","page":"Function Operators","title":"ExtendableFEMBase.OperatorPair","text":"abstract type OperatorPair{<:StandardFunctionOperator,<:StandardFunctionOperator} <: StandardFunctionOperator\n\nallows to evaluate two operators in place of one, e.g. OperatorPair{Identity,Gradient}.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.OperatorTriple","page":"Function Operators","title":"ExtendableFEMBase.OperatorTriple","text":"abstract type OperatorTriple{<:StandardFunctionOperator,<:StandardFunctionOperator} <: StandardFunctionOperator\n\nallows to evaluate three operators in place of one, e.g. OperatorTriple{Identity,Gradient,Hessian}.\n\n\n\n\n\n","category":"type"},{"location":"quadrature/#Quadrature","page":"Quadrature","title":"Quadrature","text":"","category":"section"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Usually quadrature is a hidden layer as quadrature rules are chosen automatically based on the polynomial degree of the ansatz functions and the specified quadorder of the user data.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Hence, quadrature rules are only needed if the user wants write his own low-level assembly.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Quadrature rules consist of points (coordinates of evaluation points with respect to reference geometry) and weights. There are constructors for several AbstractElementGeometries (from ExtendableGrids) and different order (some have generic formulas for arbitrary order), see below for a detailed list.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Modules = [ExtendableFEMBase]\nPages = [\"quadrature.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"abstract type QuadratureRule{T<:Real, ET<:AbstractElementGeometry}\n\nA struct that contains the name of the quadrature rule, the reference points and the weights for the parameter-determined element geometry.\n\n\n\n\n\n","category":"type"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:AbstractElementGeometry0D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry0D}\n\nConstructs 0D quadrature rule of specified order (always point evaluation).\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:AbstractElementGeometry1D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry1D}\n\nConstructs 1D quadrature rule of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Parallelepiped3D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelepiped3D}\n\nConstructs quadrature rule on Parallelepiped3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Parallelogram2D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelogram2D}\n\nConstructs quadrature rule on Parallelogram2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Tetrahedron3D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Tetrahedron3D}\n\nConstructs quadrature rule on Tetrahedron3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Triangle2D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Triangle2D}\n\nConstructs quadrature rule on Triangle2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Base.eltype-Union{Tuple{QuadratureRule{T, ET}}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:AbstractElementGeometry}","page":"Quadrature","title":"Base.eltype","text":"eltype(\n    _::QuadratureRule{T<:Real, ET<:AbstractElementGeometry}\n) -> Any\n\n\nCustom eltype function for QuadratureRule{T,ET}.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Base.show-Tuple{IO, QuadratureRule}","page":"Quadrature","title":"Base.show","text":"show(io::IO, Q::QuadratureRule)\n\n\nCustom show function for QuadratureRule{T,ET} that prints some information.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.integrate!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{T}, Tuple{AbstractArray{T}, ExtendableGrid{Tv, Ti}, Type{<:AssemblyType}, Any}} where {T, Tv, Ti}","page":"Quadrature","title":"ExtendableFEMBase.integrate!","text":"integrate!(\n    integral4items::AbstractArray{T},\n    grid::ExtendableGrid{Tv, Ti},\n    AT::Type{<:AssemblyType},\n    integrand;\n    offset,\n    bonus_quadorder,\n    quadorder,\n    time,\n    items,\n    force_quadrature_rule,\n    kwargs...\n)\n\n\nIntegration that writes result on every item into integral4items.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.integrate-Tuple{ExtendableGrid, Type{<:AssemblyType}, Any, Int64}","page":"Quadrature","title":"ExtendableFEMBase.integrate","text":"integrate(\n    grid::ExtendableGrid,\n    AT::Type{<:AssemblyType},\n    integrand!,\n    resultdim::Int64;\n    T,\n    kwargs...\n) -> Union{Float64, Vector{Float64}}\n\n\nIntegration that returns total integral.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.ref_integrate!-Tuple{AbstractArray, Type{<:AbstractElementGeometry}, Int64, Function}","page":"Quadrature","title":"ExtendableFEMBase.ref_integrate!","text":"ref_integrate!(\n    integral::AbstractArray,\n    EG::Type{<:AbstractElementGeometry},\n    order::Int64,\n    integrand::Function\n)\n\n\nIntegration for reference basis functions on reference domains (merely for testing stuff).\n\nNote: area of reference geometry is not multiplied\n\n\n\n\n\n","category":"method"},{"location":"fespace/#FESpace","page":"FESpace","title":"FESpace","text":"","category":"section"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"To generate a finite element space only a finite element type and a grid is needed, dofmaps are generated automatically on their first demand.","category":"page"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"Modules = [ExtendableFEMBase]\nPages = [\"finiteelements.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#ExtendableFEMBase.FESpace","page":"FESpace","title":"ExtendableFEMBase.FESpace","text":"struct FESpace{Tv, Ti, FEType<:AbstractFiniteElement,AT<:AssemblyType}\n    name::String                          # full name of finite element space (used in messages)\n    broken::Bool                          # if true, broken dofmaps are generated\n    ndofs::Int                            # total number of dofs\n    coffset::Int                          # offset for component dofs\n    xgrid::ExtendableGrid[Tv,Ti}          # link to xgrid \n    dofmaps::Dict{Type{<:AbstractGridComponent},Any} # backpack with dofmaps\nend\n\nA struct that has a finite element type as parameter and carries dofmaps (CellDofs, FaceDofs, BFaceDofs) plus additional grid information and access to arrays holding coefficients if needed.\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.FESpace-Union{Tuple{ExtendableGrid{Tv, Ti}}, Tuple{AT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, AT<:AssemblyType}","page":"FESpace","title":"ExtendableFEMBase.FESpace","text":"function FESpace{FEType<:AbstractFiniteElement,AT<:AssemblyType}(\n    xgrid::ExtendableGrid{Tv,Ti};\n    name = \"\",\n    broken::Bool = false)\n\nConstructor for FESpace of the given FEType, AT = ONCELLS/ONFACES/ONEDGES generates a finite elements space on the cells/faces/edges of the provided xgrid (if omitted ONCELLS is used as default). The broken switch allows to generate a broken finite element space (that is piecewise H1/Hdiv/HCurl). If no name is provided it is generated automatically from FEType. If no AT is provided, the space is generated ON_CELLS.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.eltype-Union{Tuple{FESpace{Tv, Ti, FEType, APT}}, Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"Base.eltype","text":"eltype(\n    _::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT}\n) -> Type{FEType} where FEType<:AbstractFiniteElement\n\n\nCustom eltype function for FESpace returns the finite element type parameter of the finite element space.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.get!-Tuple{FESpace, Type{<:DofMap}}","page":"FESpace","title":"Base.get!","text":"get!(FES::FESpace, DM::Type{<:DofMap}) -> Any\n\n\nTo be called by getindex. This triggers lazy creation of  non-existing dofmaps\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.getindex-Tuple{FESpace, Type{<:DofMap}}","page":"FESpace","title":"Base.getindex","text":"Base.getindex(FES::FESpace,DM::Type{<:DofMap})\n\nGeneric method for obtaining dofmap. This method is mutating in the sense that non-existing dofmaps are created on demand. Due to the fact that components are stored as Any the return value triggers type instability.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.setindex!-Tuple{FESpace, Any, Type{<:DofMap}}","page":"FESpace","title":"Base.setindex!","text":"setindex!(FES::FESpace, v, DM::Type{<:DofMap}) -> Any\n\n\nSet new dofmap\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{IO, FESpace{Tv, Ti, FEType, APT}}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"Base.show","text":"show(\n    io::IO,\n    FES::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT}\n)\n\n\nCustom show function for FESpace that prints some information and all available dofmaps.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.assemblytype-Union{Tuple{FESpace{Tv, Ti, FEType, APT}}, Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"ExtendableFEMBase.assemblytype","text":"assemblytype(\n    _::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT}\n) -> Any\n\n\nreturns the assembly type parameter of the finite element space, i.e. on which entities of the grid the finite element is defined.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#DofMaps","page":"FESpace","title":"DofMaps","text":"","category":"section"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"Modules = [ExtendableFEMBase]\nPages = [\"dofmaps.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#ExtendableFEMBase.DofMap","page":"FESpace","title":"ExtendableFEMBase.DofMap","text":"abstract type DofMap <: AbstractGridAdjacency\n\nDofmaps are stored as an ExtendableGrids.AbstractGridAdjacency in the finite element space and collect information with respect to different AssemblyTypes. They are generated automatically on demand and the dofmaps associated to each subtype can be accessed via FESpace[DofMap].\n\n\n\n\n\n","category":"type"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"The following DofMap subtypes are available and are used as keys to access the dofmap via FESpace[DofMap] (which is equivalent to FESpace.dofmaps[DofMap]).","category":"page"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"DofMap Explanation\nCellDofs degrees of freedom for on each cell\nFaceDofs degrees of freedom for each face\nEdgeDofs degrees of freedom for each edge (in 3D)\nBFaceDofs degrees of freedom for each boundary face\nBEdgeDofs degrees of freedom for each boundary edge (in 3D)","category":"page"},{"location":"feevaluator/#FEEvaluator","page":"FEEvaluator","title":"FEEvaluator","text":"","category":"section"},{"location":"feevaluator/","page":"FEEvaluator","title":"FEEvaluator","text":"FEEvaluators provide a structure that handles the evaluation of finite element basis functions for a given function operator, quadrature rule and item geometry. It stores the evaluations on the reference geometry (where derivatives are computed by automatic differentiation) and on the current mesh item. The current mesh item can be changed via the update! call.","category":"page"},{"location":"feevaluator/","page":"FEEvaluator","title":"FEEvaluator","text":"Modules = [ExtendableFEMBase]\nPages = [\"feevaluator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"feevaluator/#ExtendableFEMBase.FEEvaluator-Union{Tuple{FEAPT}, Tuple{EG}, Tuple{FEType}, Tuple{TvR}, Tuple{TiG}, Tuple{TvG}, Tuple{FESpace{TvG, TiG, FEType, FEAPT}, Type{<:??}, QuadratureRule{TvR, EG}}} where {TvG, TiG, TvR, FEType<:AbstractFiniteElement, EG<:AbstractElementGeometry, FEAPT<:AssemblyType}","page":"FEEvaluator","title":"ExtendableFEMBase.FEEvaluator","text":"function FEEvaluator(FE::FESpace, operator::AbstractFunctionOperator, qrule::QuadratureRule; T = Float64, AT = ON_CELLS, L2G = nothing)\n\nConstructs a FEEvaluator that handles evaluations of finite element basis function evaluation for the given FESpace, operator at the quadrature points of the given QuadratureRule. It has an update! function to update the evaluation upon entry to a new cell. Evaluations can be accessed via FEEvaluator.cvals[j,k,i] where i is the quadrature point id, k is the local dof number and j is the component. \n\nNote that matrix-valued operators evaluations, e.g. for Gradient, are given as a long vector (in component-wise order).\n\n\n\n\n\n","category":"method"},{"location":"feevaluator/#ExtendableFEMBase.eval_febe!","page":"FEEvaluator","title":"ExtendableFEMBase.eval_febe!","text":"    eval_febe!(result, FEBE::FEBasisEvaluator, j::Int, i::Int, offset::Int = 0, factor = 1)\n\nEvaluate the j-th basis function of the FEBasisEvaluator at the i-th quadrature point and writes the (possibly vector-valued) evaluation into result (beginning at offset and with the specified factor).\n\n\n\n\n\n","category":"function"},{"location":"feevaluator/#ExtendableFEMBase.eval_febe!-2","page":"FEEvaluator","title":"ExtendableFEMBase.eval_febe!","text":"    eval_febe!(result, FEBE::FEBasisEvaluator, j::Int, i::Int, offset::Int = 0, factor = 1)\n\nEvaluates the linear combination of the basisfunction with given coefficients at the i-th quadrature point and writes the (possibly vector-valued) evaluation into result (beginning at offset and with the specified factor).\n\n\n\n\n\n","category":"function"},{"location":"feevaluator/#ExtendableFEMBase.update_basis!-Tuple{FEEvaluator, Any}","page":"FEEvaluator","title":"ExtendableFEMBase.update_basis!","text":"function update_basis!(FEBE::FEEvaluator, item::Integer)\n\nSets FEBE.citem[] = item and updates the basis.\n\n\n\n\n\n","category":"method"},{"location":"feevaluator/#ExtendableFEMBase.update_basis!-Union{Tuple{ExtendableFEMBase.SingleFEEvaluator{<:Real, <:Real, <:Integer, operator, FEType}}, Tuple{FEType}, Tuple{operator}} where {operator, FEType}","page":"FEEvaluator","title":"ExtendableFEMBase.update_basis!","text":"function update_basis!(FEBE::SingleFEEvaluator)\n\nUpdates the basis for the current item FEBE.citem[].\n\n\n\n\n\n","category":"method"},{"location":"examples/Example210_LowLevelNavierStokes/#:-Navier-Stokes-Problem","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"","category":"section"},{"location":"examples/Example210_LowLevelNavierStokes/","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"(source code)","category":"page"},{"location":"examples/Example210_LowLevelNavierStokes/","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"Consider the Navier-Stokes problem that seeks u and p such that","category":"page"},{"location":"examples/Example210_LowLevelNavierStokes/","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"beginaligned\n\t- mu Delta u + (u cdot nabla) u + nabla p = f\n\t\t\tmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/Example210_LowLevelNavierStokes/","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"The weak formulation seeks u in V = H^1_0(Omega) and p in Q = L^2_0(Omega) such that","category":"page"},{"location":"examples/Example210_LowLevelNavierStokes/","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"beginaligned\n\tmu (nabla u nabla v) + ((u cdot nabla) u v) - (p mathrmdiv(v))  = (f v)\n\t textfor all  v in V\n\t(q mathrmdiv(u))  = 0\n\t textfor all  q in Q\nendaligned","category":"page"},{"location":"examples/Example210_LowLevelNavierStokes/","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"This example computes a planar lattice flow with inhomogeneous Dirichlet boundary conditions (which requires some modification above). Newton's method with automatic differentation is used to handle the nonlinear convection term.","category":"page"},{"location":"examples/Example210_LowLevelNavierStokes/","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"module Example210_LowLevelNavierStokes\n\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\nusing ForwardDiff\nusing DiffResults\nusing UnicodePlots\n\n# data for Poisson problem\nconst μ = 1e-2\nfunction f!(fval, x, t) # right-hand side\n    fval[1] = 8.0*π*π*μ * exp(-8.0*π*π*μ*t) * sin(2.0*π*x[1])*sin(2.0*π*x[2])\n    fval[2] = 8.0*π*π*μ * exp(-8.0*π*π*μ*t) * cos(2.0*π*x[1])*cos(2.0*π*x[2])\n    return nothing\nend\n\n# exact velocity (for boundary data and error calculation)\nfunction u!(uval, qpinfo)\n    x = qpinfo.x\n    t = qpinfo.time\n    uval[1] = exp(-8.0*π*π*μ*t) * sin(2.0*π*x[1])*sin(2.0*π*x[2])\n    uval[2] = exp(-8.0*π*π*μ*t) * cos(2.0*π*x[1])*cos(2.0*π*x[2])\n    return nothing\nend\n\n# exact pressure (for error calculation)\nfunction p!(pval, qpinfo)\n    x = qpinfo.x\n    t = qpinfo.time\n    pval[1] = exp(-16*pi*pi*μ*t)*(cos(4*pi*x[1])-cos(4*pi*x[2]))/4\n    return nothing\nend\n\nfunction main(; nref = 5, teval = 0, order = 2, Plotter = nothing)\n\n    @assert order >= 2\n\n    # create grid\n    X = LinRange(0,1,2^nref+1)\n    Y = LinRange(0,1,2^nref+1)\n    println(\"Creating grid...\")\n    @time xgrid = simplexgrid(X,Y)\n\n    # create FESpace\n    println(\"Creating FESpace...\")\n    FETypes = [H1Pk{2,2,order}, H1Pk{1,2,order-1}]\n    @time FES = [FESpace{FETypes[1]}(xgrid; name = \"velocity space\"),\n                 FESpace{FETypes[2]}(xgrid; name = \"pressure space\")]\n    FES\n\n    # solve\n    sol = solve_stokes_lowlevel(FES; teval = teval)\n\n    # move integral mean of pressure\n    pmean = sum(compute_error(sol[2], nothing, order, 1))\n    for j = 1 : sol[2].FES.ndofs\n        sol[2][j] -= pmean\n    end\n\n    # calculate l2 error\n    error_u = sqrt(sum(compute_error(sol[1], u!, 2)))\n    error_p = sqrt(sum(compute_error(sol[2], p!, 2)))\n    println(\"\\nl2 error velo = $(error_u)\")\n    println(\"l2 error pressure = $(error_p)\")\n\n    # plot\n    p=GridVisualizer(; Plotter = Plotter, layout = (1,1), clear = true, resolution = (1200,1200))\n    scalarplot!(p[1,1], xgrid, nodevalues(sol[1]; abs = true)[1,:]; title = \"|u| + quiver\", Plotter = Plotter)\n    vectorplot!(p[1,1], xgrid, eval_func(PointEvaluator([(1, Identity)], sol)), spacing = 0.05, clear = false)\nend\n\n# computes error and integrals\nfunction compute_error(uh::FEVectorBlock, u, order = get_polynomialorder(get_FEType(uh), uh.FES.xgrid[CellGeometries][1]), p = 2)\n    xgrid = uh.FES.xgrid\n    FES = uh.FES\n    EG = xgrid[UniqueCellGeometries][1]\n    ncomponents = get_ncomponents(uh)\n    cellvolumes = xgrid[CellVolumes]\n    celldofs = FES[CellDofs]\n    error = zeros(Float64, ncomponents, num_cells(xgrid))\n    uhval = zeros(Float64, ncomponents)\n    uval = zeros(Float64, ncomponents)\n    L2G = L2GTransformer(EG, xgrid, ON_CELLS)\n    QP = QPInfos(xgrid)\n    qf = VertexRule(EG, order)\n    FEB = FEEvaluator(FES, Identity, qf)\n\n    function barrier(L2G::L2GTransformer)\n        for cell in 1:num_cells(xgrid)\n            update_trafo!(L2G, cell)\n            update_basis!(FEB, cell)\n            for (qp, weight) in enumerate(qf.w)\n                # evaluate uh\n                fill!(uhval,0)\n                eval_febe!(uhval, FEB, view(view(uh),view(celldofs,:,cell)), qp)\n\n                # evaluate u\n                if u !== nothing\n                    fill!(uval,0)\n                    eval_trafo!(QP.x, L2G, qf.xref[qp])\n                    u(uval, QP)\n                end\n\n                # evaluate error\n                for d = 1 : ncomponents\n                    error[d, cell] += (uhval[d] - uval[d]).^p * cellvolumes[cell] * weight\n                end\n            end\n        end\n    end\n\n    barrier(L2G)\n    return error\nend\n\nfunction solve_stokes_lowlevel(FES; teval = 0)\n\n    println(\"Initializing system...\")\n    sol = FEVector(FES)\n    A = FEMatrix(FES)\n    b = FEVector(FES)\n    @time update_system! = prepare_assembly!(A, b, FES[1], FES[2], sol)\n    @time update_system!(true, false)\n    Alin = deepcopy(A) ## = keep linear part of system matrix\n    blin = deepcopy(b) ## = keep linear part of right-hand side\n\n    println(\"Prepare boundary conditions...\")\n    @time begin\n        u_init = FEVector(FES)\n        interpolate!(u_init[1], u!; time = teval)\n\n        fixed_dofs = [size(A.entries,1)] # fix one pressure dof = last dof\n        BFaceDofs::Adjacency{Int32} = FES[1][ExtendableFEMBase.BFaceDofs]\n        nbfaces::Int = num_sources(BFaceDofs)\n        AM::ExtendableSparseMatrix{Float64,Int64} = A.entries\n        dof_j::Int = 0\n        for bface = 1 : nbfaces\n            for j = 1 : num_targets(BFaceDofs,1)\n                dof_j = BFaceDofs[j, bface]\n                push!(fixed_dofs, dof_j)\n            end\n        end\n        push!(fixed_dofs, FES[1].ndofs+1) ## fix one pressure dof\n    end\n\n    for it = 1 : 20\n        # solve\n        println(\"\\nITERATION $it\\n=============\")\n        println(\"Solving linear system...\")\n        @time copyto!(sol.entries, A.entries \\ b.entries)\n        res = A.entries.cscmatrix * sol.entries .- b.entries\n        for dof in fixed_dofs\n            res[dof] = 0\n        end\n        linres = norm(res)\n        println(\"linear residual = $linres\")\n\n        fill!(A.entries.cscmatrix.nzval,0)\n        fill!(b.entries,0)\n        println(\"Updating linear system...\")\n        @time begin\n            update_system!(false,true)\n            A.entries.cscmatrix += Alin.entries.cscmatrix\n            b.entries .+= blin.entries\n        end\n\n        # fix boundary dofs\n        for dof in fixed_dofs\n            AM[dof,dof] = 1e60\n            b.entries[dof] = 1e60 * u_init.entries[dof]\n        end\n        ExtendableSparse.flush!(A.entries)\n\n        # calculate nonlinear residual\n        res = A.entries.cscmatrix * sol.entries .- b.entries\n        for dof in fixed_dofs\n            res[dof] = 0\n        end\n        nlres = norm(res)\n        println(\"nonlinear residual = $nlres\")\n        if nlres < max(1e-12, 20*linres)\n            break\n        end\n    end\n\n    return sol\nend\n\nfunction prepare_assembly!(A, b, FESu, FESp, sol; teval = 0)\n\n    A = A.entries\n    b = b.entries\n    sol = sol.entries\n    xgrid = FESu.xgrid\n    EG = xgrid[UniqueCellGeometries][1]\n    FEType_u = eltype(FESu)\n    FEType_p = eltype(FESp)\n    L2G = L2GTransformer(EG, xgrid, ON_CELLS)\n    cellvolumes = xgrid[CellVolumes]\n    ncells::Int = num_cells(xgrid)\n\n    # dofmap\n    CellDofs_u = FESu[ExtendableFEMBase.CellDofs]\n    CellDofs_p = FESp[ExtendableFEMBase.CellDofs]\n    offset_p = FESu.ndofs\n\n    # quadrature formula\n    qf = QuadratureRule{Float64, EG}(3*get_polynomialorder(FEType_u, EG)-1)\n    weights::Vector{Float64} = qf.w\n    xref::Vector{Vector{Float64}} = qf.xref\n    nweights::Int = length(weights)\n\n    # FE basis evaluator\n    FEBasis_∇u = FEEvaluator(FESu, Gradient, qf)\n    ∇uvals = FEBasis_∇u.cvals\n    FEBasis_idu = FEEvaluator(FESu, Identity, qf)\n    iduvals = FEBasis_idu.cvals\n    FEBasis_idp = FEEvaluator(FESp, Identity, qf)\n    idpvals = FEBasis_idp.cvals\n\n    # prepare automatic differentation of convection operator\n    function operator!(result, input)\n        # result = (u ⋅ ∇)u\n        result[1] = input[1]*input[3]+input[2]*input[4]\n        result[2] = input[1]*input[5]+input[2]*input[6]\n    end\n    result = Vector{Float64}(undef,2)\n    input = Vector{Float64}(undef,6)\n    tempV = zeros(Float64, 2)\n    Dresult = DiffResults.JacobianResult(result, input)\n    cfg = ForwardDiff.JacobianConfig(operator!, result, input, ForwardDiff.Chunk{6}())\n    jac = DiffResults.jacobian(Dresult)\n    value = DiffResults.value(Dresult)\n\n    # ASSEMBLY LOOP\n    function barrier(EG, L2G::L2GTransformer, linear::Bool, nonlinear::Bool)\n        # barrier function to avoid allocations caused by L2G\n\n        ndofs4cell_u::Int = get_ndofs(ON_CELLS, FEType_u, EG)\n        ndofs4cell_p::Int = get_ndofs(ON_CELLS, FEType_p, EG)\n        Aloc = zeros(Float64, ndofs4cell_u, ndofs4cell_u)\n        Bloc = zeros(Float64, ndofs4cell_u, ndofs4cell_p)\n        dof_j::Int, dof_k::Int = 0, 0\n        fval::Vector{Float64} = zeros(Float64,2)\n        x::Vector{Float64} = zeros(Float64, 2)\n\n        for cell = 1 : ncells\n            # update FE basis evaluators\n            update_basis!(FEBasis_∇u, cell)\n            update_basis!(FEBasis_idu, cell)\n            update_basis!(FEBasis_idp, cell)\n\n            # assemble local stiffness matrix (symmetric)\n            if (linear)\n                for j = 1 : ndofs4cell_u, k = 1 : ndofs4cell_u\n                    temp = 0\n                    for qp = 1 : nweights\n                        temp += weights[qp] * dot(view(∇uvals,:,j,qp), view(∇uvals,:,k,qp))\n                    end\n                    Aloc[k,j] = μ * temp\n                end\n\n                # assemble div-pressure coupling\n                for j = 1 : ndofs4cell_u, k = 1 : ndofs4cell_p\n                    temp = 0\n                    for qp = 1 : nweights\n                        temp -= weights[qp] * (∇uvals[1,j,qp] + ∇uvals[4,j,qp]) *\n                        idpvals[1,k,qp]\n                    end\n                    Bloc[j,k] = temp\n                end\n                Bloc .*= cellvolumes[cell]\n\n                # assemble right-hand side\n                update_trafo!(L2G, cell)\n                for j = 1 : ndofs4cell_u\n                    # right-hand side\n                    temp = 0\n                    for qp = 1 : nweights\n                        # get global x for quadrature point\n                        eval_trafo!(x, L2G, xref[qp])\n                        # evaluate (f(x), v_j(x))\n                        f!(fval, x, teval)\n                        temp += weights[qp] * dot(view(iduvals,: , j, qp), fval)\n                    end\n                    # write into global vector\n                    dof_j = CellDofs_u[j, cell]\n                    b[dof_j] += temp * cellvolumes[cell]\n                end\n            end\n\n            # assemble nonlinear term\n            if (nonlinear)\n                for qp = 1 : nweights\n                    fill!(input,0)\n                    for j = 1 : ndofs4cell_u\n                        dof_j = CellDofs_u[j, cell]\n                        for d = 1 : 2\n                            input[d] += sol[dof_j] * iduvals[d,j,qp]\n                        end\n                        for d = 1 : 4\n                            input[2+d] += sol[dof_j] * ∇uvals[d,j,qp]\n                        end\n                    end\n\n                    # evaluate jacobian\n                    ForwardDiff.chunk_mode_jacobian!(Dresult, operator!, result, input, cfg)\n\n                    # update matrix\n                    for j = 1 : ndofs4cell_u\n                        # multiply ansatz function with local jacobian\n                        fill!(tempV,0)\n                        for d = 1 : 2\n                            tempV[1] += jac[1,d] * iduvals[d,j,qp]\n                            tempV[2] += jac[2,d] * iduvals[d,j,qp]\n                        end\n                        for d = 1 : 4\n                            tempV[1] += jac[1,2+d] * ∇uvals[d,j,qp]\n                            tempV[2] += jac[2,2+d] * ∇uvals[d,j,qp]\n                        end\n\n                        # multiply test function operator evaluation\n                        for k = 1 : ndofs4cell_u\n                            Aloc[k,j] += dot(tempV,view(iduvals,:,k,qp)) * weights[qp]\n                        end\n                    end\n\n                    # update rhs\n                    mul!(tempV, jac, input)\n                    tempV .-= value\n                    for j = 1 : ndofs4cell_u\n                        dof_j = CellDofs_u[j, cell]\n                        b[dof_j] += dot(tempV, view(iduvals,:,j,qp)) * weights[qp] * cellvolumes[cell]\n                    end\n                end\n            end\n\n            # add local matrices to global matrix\n            Aloc .*= cellvolumes[cell]\n            for j = 1 : ndofs4cell_u\n                dof_j = CellDofs_u[j, cell]\n                for k = 1 : ndofs4cell_u\n                    dof_k = CellDofs_u[k, cell]\n                    rawupdateindex!(A, +, Aloc[j,k], dof_j, dof_k)\n                end\n                if (linear)\n                    for k = 1 : ndofs4cell_p\n                        dof_k = CellDofs_p[k, cell] + offset_p\n                        rawupdateindex!(A, +, Bloc[j,k], dof_j, dof_k)\n                        rawupdateindex!(A, +, Bloc[j,k], dof_k, dof_j)\n                    end\n                end\n            end\n            fill!(Aloc, 0)\n            fill!(Bloc, 0)\n        end\n    end\n\n    function update_system!(linear::Bool, nonlinear::Bool)\n        barrier(EG, L2G, linear, nonlinear)\n        flush!(A)\n    end\n    update_system!\nend\n\nend #module","category":"page"},{"location":"examples/Example210_LowLevelNavierStokes/","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"","category":"page"},{"location":"examples/Example210_LowLevelNavierStokes/","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example210_LowLevelNavierStokes/","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"Default output:","category":"page"},{"location":"examples/Example210_LowLevelNavierStokes/","page":"210 : Navier-Stokes Problem","title":"210 : Navier-Stokes Problem","text":"julia> Example210_LowLevelNavierStokes.main()\nCreating grid...\n  0.000099 seconds (153 allocations: 54.453 KiB)\nCreating FESpace...\n  0.159905 seconds (288.84 k allocations: 19.611 MiB, 98.66% compilation time)\nInitializing system...\n  2.552614 seconds (3.00 M allocations: 193.648 MiB, 4.98% gc time, 99.89% compilation time)\n  1.418411 seconds (1.51 M allocations: 111.122 MiB, 4.01% gc time, 91.97% compilation time)\nPrepare boundary conditions...\n  6.660337 seconds (5.25 M allocations: 343.684 MiB, 2.87% gc time, 99.83% compilation time)\n\nITERATION 1\n=============\nSolving linear system...\n  0.114268 seconds (140 allocations: 83.900 MiB, 21.58% gc time)\nlinear residual = 1.2409849547040626e-15\nUpdating linear system...\n  0.226230 seconds (66.96 k allocations: 12.850 MiB, 5.73% gc time, 64.74% compilation time)\nnonlinear residual = 0.1222501140854554\n\nITERATION 2\n=============\nSolving linear system...\n  0.088417 seconds (83 allocations: 48.996 MiB, 11.75% gc time)\nlinear residual = 1.770787696762069e-14\nUpdating linear system...\n  0.079391 seconds (15 allocations: 8.269 MiB)\nnonlinear residual = 0.03438674749707003\n\nITERATION 3\n=============\nSolving linear system...\n  0.084530 seconds (86 allocations: 48.996 MiB, 8.71% gc time)\nlinear residual = 1.0731660686535238e-15\nUpdating linear system...\n  0.079624 seconds (15 allocations: 8.269 MiB)\nnonlinear residual = 0.0011018426981475133\n\nITERATION 4\n=============\nSolving linear system...\n  0.081646 seconds (86 allocations: 48.996 MiB, 3.16% gc time)\nlinear residual = 1.0631648642290553e-15\nUpdating linear system...\n  0.079319 seconds (15 allocations: 8.269 MiB)\nnonlinear residual = 1.0715126096788832e-5\n\nITERATION 5\n=============\nSolving linear system...\n  0.079042 seconds (86 allocations: 48.996 MiB, 2.82% gc time)\nlinear residual = 1.0740269916345858e-15\nUpdating linear system...\n  0.079592 seconds (15 allocations: 8.269 MiB)\nnonlinear residual = 4.030019988355817e-9\n\nITERATION 6\n=============\nSolving linear system...\n  0.079911 seconds (86 allocations: 48.996 MiB, 2.95% gc time)\nlinear residual = 1.0293391766847716e-15\nUpdating linear system...\n  0.079556 seconds (15 allocations: 8.269 MiB)\nnonlinear residual = 1.0678528430337422e-15\n\nl2 error velo = 0.38605133038179756\nl2 error pressure = 0.20006755549266816","category":"page"},{"location":"examples_intro/#About-the-examples","page":"About the examples","title":"About the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"The examples have been designed with the following issues in mind:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"they run from the Julia REPL\neach example is a Julia module named similar to the basename of the example file.\nan example can be used as the starting point for a project \nsome examples define test cases for the test suite\nExampleXYZ with X = A can be considered advanced and uses low-level structures and/or demonstrates customisation features or experimental features\nthe default output of the main function is printed on the website and can be used to check if the code runs as expected (unfortunately REPL messages are not recorded)\nprinted assembly and solving times (especially in a first iteration) can be much larger due to first-run compilation times","category":"page"},{"location":"examples_intro/#Running-the-examples","page":"About the examples","title":"Running the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"In order to run ExampleXXX, peform the following steps:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Download the example file (e.g. via the source code link at the top)\nMake sure all used packages are installed in your Julia environment\nIn the REPL: ","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"julia> include(\"ExampleXXX.jl\")`\n\njulia> ExampleXXX.main()","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Some examples offer visual output via the optional argument Plotter = PyPlot or Plotter = GLMakie","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"(provided the package PyPlot/GLMakie is installed and loaded)","category":"page"},{"location":"meshing/#Meshing","page":"Meshing","title":"Meshing","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Meshes are stored as an ExtendableGrid, see ExtendableGrids.jl for details and constructors. Grid generators for simplex grids can be found e.g. in the external module SimplexGridFactory.jl","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Cells, faces and edges of the mesh are associated to AbstractElementGeometries (defined by ExtendableGrids.jl) that are used to dispatch functionality (local/global transformation, enumeration rules, set of basis functions, volume calculation, refinements etc.). See further below for a list of recognized element geometries.","category":"page"},{"location":"meshing/#Recognized-Geometries-and-Reference-Domains","page":"Meshing","title":"Recognized Geometries and Reference Domains","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The following list contains all subtypes of ExtendableGrids.AbstractElementGeometries and their reference domains for which the package offers finite elements on them.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Edge1D-:-AbstractElementGeometry1D","page":"Meshing","title":"Edge1D <: AbstractElementGeometry1D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[1]-----[2]               [1] = [0]\n                          [2] = [1]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Triangle2D","page":"Meshing","title":"Triangle2D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[3]                 \n | \\   \n |   \\                    [1] = [0,0]\n |     \\                  [2] = [1,0]\n |       \\                [3] = [0,1]\n |         \\ \n[1]--------[2]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Parallelogram2D-:-Quadrilateral2D","page":"Meshing","title":"Parallelogram2D <: Quadrilateral2D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[4]--------[3]               \n |          |             [1] = [0,0]\n |          |             [2] = [1,0]\n |          |             [3] = [1,1]\n |          |             [4] = [0,1]\n[1]--------[2]\n\nNote: most finite elements only work as intended on Parallelogram2D\n      since the local<>global map stays affine in this case","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Tetrahedron3D","page":"Meshing","title":"Tetrahedron3D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[4]                 \n |\\\\   \n | \\ \\                    [1] = [0,0,0]\n |  \\  \\                  [2] = [1,0,0]\n |   \\   \\                [3] = [0,1,0]\n | _-[3]-_ \\              [4] = [0,0,1]\n[1]--------[2]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Parallelepiped3D-:-Hexahedron3D","page":"Meshing","title":"Parallelepiped3D <: Hexahedron3D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"    [8]--------[7]        [1] = [0,0,0]\n   / |        / |         [2] = [1,0,0]\n[5]--------[6]  |         [3] = [1,1,0]\n |   |      |   |         [4] = [0,1,0]\n |   |      |   |         [5] = [0,0,1]\n |  [4]-----|--[3]        [6] = [1,0,1]\n | /        | /           [7] = [1,1,1]\n[1]--------[2]            [8] = [0,1,1]\n\nNote: most finite elements only work as intended on Parallelepiped3D\n      since the local<>global map stays affine in this case","category":"page"},{"location":"fems/#Implemented-Finite-Elements","page":"List of Finite Elements","title":"Implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"This page describes the finite element type-tree and lists all implemented finite elements.","category":"page"},{"location":"fems/#The-Finite-Element-Type-Tree","page":"List of Finite Elements","title":"The Finite Element Type-Tree","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Finite elements are abstract type leaves in a type-tree. The complete tree looks like this:","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"AbstractFiniteElement\n├─ AbstractH1FiniteElement\n│  ├─ AbstractH1FiniteElementWithCoefficients\n│  │  ├─ H1P1TEB\n│  │  └─ H1BR\n│  ├─ H1CR\n│  ├─ H1MINI\n│  ├─ L2P0\n│  ├─ L2P1\n│  ├─ H1P1\n│  ├─ H1P2\n│  ├─ H1P2B\n│  ├─ H1P3\n│  ├─ H1Pk\n│  ├─ H1Q1\n│  └─ H1Q2\n├─ AbstractHcurlFiniteElement\n│  └─ HCURLN0\n└─ AbstractHdivFiniteElement\n   ├─ HDIVBDM1\n   ├─ HDIVBDM2\n   ├─ HDIVRT0\n   └─ HDIVRT1","category":"page"},{"location":"fems/#Remarks","page":"List of Finite Elements","title":"Remarks","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"each type depends on one/two or three parameters, the first one is always the number of components (ncomponents) that determines if the finite element is scalar- or veector-valued; some elements additionaly require the parameter edim <: Int if they are structurally different in different space dimensions; arbitrary order elements require a third parameter that determines the order\neach finite elements mainly comes with a set of basis functions in reference coordinates for each applicable AbstractElementGeometry and degrees of freedom maps for each mesh entity\nbroken finite elements are possible via the broken switch in the FESpace constructor\nthe type steers how the basis functions are transformed from local to global coordinates and how FunctionOperators are evaluated\ndepending on additional continuity properties of the element types more basis function sets are defined:\nAbstractH1FiniteElements additionally have evaluations of nonzero basisfunctions on faces/bfaces\nAbstractHdivFiniteElements additionally have evaluations of nonzero normalfluxes of basisfunctions on faces/bfaces\nAbstractHcurlFiniteElements additionally have evaluations of nonzero tangentfluxes of basisfunctions on edges/bedges\neach finite element has its own implemented standard interpolation interpolate! (see Finite Element Interpolations) that can be applied to a function with header function(result, input, qpinfo), below it is shortly described what this means for each finite element","category":"page"},{"location":"fems/#List-of-implemented-Finite-Elements","page":"List of Finite Elements","title":"List of implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The following table lists all curently implemented finite elements and on which geometries they are available (in brackets a dofmap pattern for CellDofs is shown and the number of local degrees of freedom for a vector-valued realisation). Click on the FEType to find out more details.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"FEType Triangle2D Parallelogram2D Tetrahedron3D Parallelepiped3D\nAbstractH1FiniteElementWithCoefficients    \nH1BR ✓ (N1f1, 9) ✓ (N1f1, 12) ✓ (N1f1, 16) \nH1P1TEB ✓ (N1f1, 9)  ✓ (N1e1, 18) \nAbstractH1FiniteElement    \nH1BUBBLE ✓ (I1, 2) ✓ (I1, 2) ✓ (I1, 3) \nH1CR ✓ (F1, 6) ✓ (F1, 8) ✓ (F1, 12) \nH1MINI ✓ (N1I1, 8) ✓ (N1I1, 10) ✓ (N1I1, 15) \nL2P0 ✓ (I1, 2) ✓ (I1, 2) ✓ (I1, 3) ✓ (I1, 3)\nL2P1 ✓ (I3, 6) ✓ (I3, 6) ✓ (I4, 12) ✓ (I4, 12)\nH1P1 ✓ (N1, 6)  ✓ (N1, 12) \nH1P2 ✓ (N1F1, 12)  ✓ (N1E1, 30) \nH1P2B ✓ (N1F1I1, 14)   \nH1P3 ✓ (N1F2I1, 20)  ✓ (N1E2F1, 60) \nH1Pk ✓ (order-dep)   \nH1Q1 ✓ (N1, 6) ✓ (N1, 8) ✓ (N1, 12) ✓ (N1, 24)\nH1Q2 ✓ (N1F1, 12) ✓ (N1F1I1, 18) ✓ (N1E1, 30) \nAbstractHcurlFiniteElement    \nHCURLN0 ✓ (f1, 3) ✓ (f1, 4) ✓ (e1, 6) \nAbstractHdivFiniteElement    \nHDIVBDM1 ✓ (f2, 6) ✓ (f2, 8) ✓ (f3, 12) \nHDIVBDM2 ✓ (f3i3, 12)   \nHDIVRT0 ✓ (f1, 3) ✓ (f1, 4) ✓ (f1, 4) ✓ (f1, 6)\nHDIVRT1 ✓ (f2i2, 8)  ✓ (f3i3, 15) ","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Note: the dofmap pattern describes the connection of the local degrees of freedom to entities of the grid and also hints to the continuity. Here, \"N\" or \"n\" means nodes, \"F\" or \"f\" means faces, \"E\" or \"e\" means edges and \"I\" means interior (dofs without any continuity across elements). Capital letters cause that every component has its own degree of freedom, while small letters signalize that only one dof is associated to the entity. As an example \"N1f1\" (for the Bernardi-Raugel element) means that at each node sits one dof per component and at each face sits a single dof. Usually finite elements that involve small letters are only defined vector-valued (i.e. the number of components has to match the element dimension), while finite elements that only involve capital letters are available for any number of components.","category":"page"},{"location":"fems/#H1-conforming-finite-elements","page":"List of Finite Elements","title":"H1-conforming finite elements","text":"","category":"section"},{"location":"fems/#P0-finite-element","page":"List of Finite Elements","title":"P0 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Piecewise constant finite element that has one degree of freedom on each cell of the grid. (It is masked as a H1-conforming finite element, because it uses the same operator evaulations.)","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space preserves the cell integrals.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"L2P0","category":"page"},{"location":"fems/#ExtendableFEMBase.L2P0","page":"List of Finite Elements","title":"ExtendableFEMBase.L2P0","text":"abstract type L2P0{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nPiecewise constant polynomials on cells.\n\nallowed on every ElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"fems/#P1-finite-element","page":"List of Finite Elements","title":"P1 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The lowest-order Courant finite element that has a degree of freedom on each vertex of the grid. On simplices the basis functions coincide with the linear barycentric coordinates. Only the L2P1 element is also defined on quads.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"L2P1\nH1P1","category":"page"},{"location":"fems/#ExtendableFEMBase.L2P1","page":"List of Finite Elements","title":"ExtendableFEMBase.L2P1","text":"abstract type L2P1{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nDiscontinuous piecewise first-order linear polynomials.\n\nallowed ElementGeometries:\n\nany\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.H1P1","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P1","text":"abstract type H1P1{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nContinuous piecewise first-order linear polynomials.\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Q1-finite-element","page":"List of Finite Elements","title":"Q1 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The lowest-order finite element that has a degree of freedom on each vertex of the grid. On simplices the basis functions coincide with the linear barycentric coordinates. This element is also defined on quads.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1Q1","category":"page"},{"location":"fems/#ExtendableFEMBase.H1Q1","page":"List of Finite Elements","title":"ExtendableFEMBase.H1Q1","text":"abstract type Q1P1{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nContinuous piecewise first-order polynomials on quads.\n\nallowed ElementGeometries:\n\nQuadrilateral2D (Q1 space)\nHexahedron3D (Q1 space)\n\n\n\n\n\n","category":"type"},{"location":"fems/#MINI-finite-element","page":"List of Finite Elements","title":"MINI finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The mini finite element adds cell bubles to the P1 element that are e.g. beneficial to define inf-sup stable finite element pairs for the Stokes problem.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its cell integral.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1MINI","category":"page"},{"location":"fems/#ExtendableFEMBase.H1MINI","page":"List of Finite Elements","title":"ExtendableFEMBase.H1MINI","text":"abstract type H1MINI{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nMini finite element.\n\nallowed element geometries:\n\nTriangle2D (linear polynomials + cubic cell bubble)\nQuadrilateral2D (Q1 space + quartic cell bubble)\nTetrahedron3D (linear polynomials + cubic cell bubble)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P1TEB-finite-element","page":"List of Finite Elements","title":"P1TEB finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"This element adds tangent-weighted edge bubbles to the P1 finite element and therefore is only available as a vector-valued element.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves face integrals of its tangential flux.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1P1TEB","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P1TEB","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P1TEB","text":"abstract type H1P1TEB{edim} <: AbstractH1FiniteElementWithCoefficients where {edim<:Int}\n\nvector-valued (ncomponents = edim) element that uses P1 functions + tangential-weighted edge bubbles as suggested by [\"Fortin Operator for the Taylor-Hood Element\", 2021, arxiv:2104.13953]\n\n(is inf-sup stable for Stokes if paired with continuous P1 pressure space, less degrees of freedom than MINI)\n\nallowed ElementGeometries:\n\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Bernardi-Raugel-(BR)-finite-element","page":"List of Finite Elements","title":"Bernardi-Raugel (BR) finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The Bernardi-Raugel adds normal-weighted face bubbles to the P1 finite element and therefore is only available as a vector-valued element.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves face integrals of its normal flux.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1BR","category":"page"},{"location":"fems/#ExtendableFEMBase.H1BR","page":"List of Finite Elements","title":"ExtendableFEMBase.H1BR","text":"abstract type H1BR{edim} <: AbstractH1FiniteElementWithCoefficients where {edim<:Int}\n\nvector-valued (ncomponents = edim) Bernardi–Raugel element (first-order polynomials + normal-weighted face bubbles)\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear + normal-weighted face bubbles)\nQuadrilateral2D (Q1 space + normal-weighted face bubbles)\nTetrahedron3D (piecewise linear + normal-weighted face bubbles)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P2-finite-element","page":"List of Finite Elements","title":"P2 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The P2 finite element method on simplices equals quadratic polynomials. On the Triangle2D shape the degrees of freedom are associated with the three vertices and the three faces of the triangle. On the Tetrahedron3D shape the degrees of freedom are associated with the four verties and the six edges.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its face/edge integrals in 2D/3D.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1P2","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P2","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P2","text":"abstract type H1P2{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D (quadratic polynomials)\nTriangle2D (quadratic polynomials)\nQuadrilateral2D (Q2 space)\nTetrahedron3D (quadratic polynomials)\n\n\n\n\n\n","category":"type"},{"location":"fems/#Q2-finite-element","page":"List of Finite Elements","title":"Q2 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"A second order finite element. On simplices it equals the P2 finite element, and on Quadrilateral2D it has 9 degrees of freedom (vertices, faces and one cell bubble).","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves lowest order face moments and (only on quads) also the cell integreal mean.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1Q2","category":"page"},{"location":"fems/#ExtendableFEMBase.H1Q2","page":"List of Finite Elements","title":"ExtendableFEMBase.H1Q2","text":"abstract type H1Q2{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D (quadratic polynomials)\nTriangle2D (quadratic polynomials)\nQuadrilateral2D (Q2 space with cell bubble)\nTetrahedron3D (quadratic polynomials)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P2B-finite-element","page":"List of Finite Elements","title":"P2B finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The P2B finite element adds additional cell bubles (in 2D and 3D) and face bubbles (only in 3D) that are e.g. used to define inf-sup stable finite element pairs for the Stokes problem.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its cell and face integrals in 2D and also edge integrals in 3D.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1P2B","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P2B","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P2B","text":"abstract type H1P2B{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials.\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#P3-finite-element","page":"List of Finite Elements","title":"P3 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The P3 finite element method on simplices equals cubic polynomials. On the Triangle2D shape the degrees of freedom are associated with the three vertices, the three faces (double dof) of the triangle and the cell itself (one cell bubble).","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves cell and face integrals in 2D.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1P3","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P3","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P3","text":"abstract type H1P3{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise third-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D (cubic polynomials)\nTriangle2D (cubic polynomials, experimental)\n\n\n\n\n\n","category":"type"},{"location":"fems/#Pk-finite-element-(experimental)","page":"List of Finite Elements","title":"Pk finite element (experimental)","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The Pk finite element method generically generates polynomials of abitrary order k on simplices (Edge1D, Triangle2D so far).","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves cell and face integrals in 2D (moment order depends on the order and the element dimension).","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1Pk","category":"page"},{"location":"fems/#ExtendableFEMBase.H1Pk","page":"List of Finite Elements","title":"ExtendableFEMBase.H1Pk","text":"abstract type H1PK{ncomponents,edim,order} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int,order<:Int}\n\nContinuous piecewise polynomials of arbitrary order >= 1 with ncomponents components in edim space dimensions.\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Crouzeix-Raviart-(CR)-finite-element","page":"List of Finite Elements","title":"Crouzeix-Raviart (CR) finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The Crouzeix-Raviart element associates one lowest-order function with each face. On the Triangle2D shape, the basis function of a face is one minus two times the nodal basis function of the opposite node. ","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space preserves its face integrals.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1CR","category":"page"},{"location":"fems/#ExtendableFEMBase.H1CR","page":"List of Finite Elements","title":"ExtendableFEMBase.H1CR","text":"abstract type H1CR{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nCrouzeix-Raviart element (only continuous at face centers).\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear, similar to P1)\nQuadrilateral2D (similar to Q1 space)\nTetrahedron3D (piecewise linear, similar to P1)\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hdiv-conforming-finite-elements","page":"List of Finite Elements","title":"Hdiv-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"These Raviart-Thomas and Brezzi-Douglas-Marini finite elements of lower order and their standard interpolations are available:","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"HDIVRT0\nHDIVBDM1\nHDIVRT1\nHDIVBDM2","category":"page"},{"location":"fems/#ExtendableFEMBase.HDIVRT0","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVRT0","text":"abstract type HDIVRT0{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Raviart-Thomas space.\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\nHexahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVBDM1","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVBDM1","text":"abstract type HDIVBDM1{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Brezzi-Douglas-Marini space\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVRT1","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVRT1","text":"abstract type HDIVRT1{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) Raviart-Thomas space of order 1.\n\nallowed ElementGeometries:\n\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVBDM2","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVBDM2","text":"abstract type HDIVBDM2{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) Brezzi-Douglas-Marini space of order 2\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hcurl-conforming-finite-elements","page":"List of Finite Elements","title":"Hcurl-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"So far only the lowest order Nedelec element is available in 2D and 3D. On Triangle2D it has one degree of freedom for each face (i.e. the rotated RT0 element), on Tetrahedron3D it has one degree of freedom associated to each of the six edges.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Its standard interpolation of a given functions preserves its tangential face/edge integrals.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"HCURLN0","category":"page"},{"location":"fems/#ExtendableFEMBase.HCURLN0","page":"List of Finite Elements","title":"ExtendableFEMBase.HCURLN0","text":"abstract type HCURLN0{edim} <: AbstractHcurlFiniteElement where {edim<:Int}\n\nHcurl-conforming vector-valued (ncomponents = edim) lowest-order Nedelec space.\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"notebooks_intro/#About-the-notebooks","page":"About the notebooks","title":"About the notebooks","text":"","category":"section"},{"location":"notebooks_intro/","page":"About the notebooks","title":"About the notebooks","text":"This sections contains Pluto.jl notebooks.","category":"page"},{"location":"notebooks_intro/","page":"About the notebooks","title":"About the notebooks","text":"Plese note, that in the html version, interactive elements like sliders are disabled. Navigation via the table of contents does work, though.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build status) (Image: ) (Image: ) (Image: DOI)","category":"page"},{"location":"#ExtendableFEMBase.jl","page":"Home","title":"ExtendableFEMBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides some low level structures like finite element spaces, interpolors, matrices and vectors to assemble custom finite element solvers based on ExtendableGrids.jl infrastructure.","category":"page"},{"location":"#Dependencies-on-other-Julia-packages","page":"Home","title":"Dependencies on other Julia packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExtendableGrids.jl\nExtendableSparse.jl\nForwardDiff.jl\nDiffResults.jl\nUnicodePlots.jl\nDocStringExtensions.jl","category":"page"}]
}
