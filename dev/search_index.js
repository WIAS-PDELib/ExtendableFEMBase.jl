var documenterSearchIndex = {"docs":
[{"location":"fematrix/#FEMatrix","page":"FEMatrix","title":"FEMatrix","text":"","category":"section"},{"location":"fematrix/","page":"FEMatrix","title":"FEMatrix","text":"A FEMatrix represents a block-structured finite element matrix, where each block (a FEMatrixBlock) corresponds to a pair of finite element spaces and operates on a submatrix of a shared ExtendableSparseMatrix.","category":"page"},{"location":"fematrix/#ExtendableFEMBase.FEMatrix","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrix","text":"FEMatrix(FESX::Union{FESpace, Vector{<:FESpace}}, FESY::Union{FESpace, Vector{<:FESpace}}=FESX; TvM=Float64, TiM=Int64, ...)\n\nConstructs an FEMatrix for storing (sparse) matrix representations associated with one or more pairs of finite element spaces (FESpace).\n\n– If FESX and FESY are single FESpace objects, the resulting FEMatrix contains one rectangular block.\n\nIf FESX and/or FESY are vectors of FESpace objects, the resulting FEMatrix is block-structured, with one block for each pair.\n\nOptionally, you can assign a name (as a String for all blocks) and/or tags (as arrays for rows and columns) to the blocks for identification and access.\n\nArguments\n\nFESX::FESpace or FESX::Vector{<:FESpace}: Row finite element space(s).\nFESY::FESpace or FESY::Vector{<:FESpace}: Column finite element space(s) (default: same as FESX).\n\nKeyword Arguments\n\nentries: Optional sparse matrix of coefficients. If not provided, a new sparse matrix of appropriate size is created.\nname: Name for the matrix or for each block (default: :automatic).\ntags: Array of tags for both rows and columns (default: nothing).\ntagsX: Array of tags for the row blocks (default: tags).\ntagsY: Array of tags for the column blocks (default: tagsX).\nnpartitions: Number of partitions for the underlying sparse matrix (default: 1).\nAdditional keyword arguments are passed to the underlying block constructors.\n\nReturns\n\nAn FEMatrix object with one or more FEMatrixBlocks, each corresponding to a given pair of FESpace objects.\n\n\n\n\n\n","category":"type"},{"location":"fematrix/#ExtendableFEMBase.FEMatrix-2","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrix","text":"struct FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal} <: SparseArrays.AbstractSparseArray{TvM, TiM, 2}\n\nA block-structured sparse matrix type for finite element assembly.\n\nFEMatrix represents a (typically sparse) matrix with an additional layer of structure: it is subdivided into multiple FEMatrixBlocks, each associated with a specific pair of finite element spaces (FESpace).\n\nFields\n\nFEMatrixBlocks::Array{FEMatrixBlock{TvM, TiM, TvG, TiG}, 1}: The array of matrix blocks, each corresponding to a pair of row and column finite element spaces.\nentries::AbstractSparseMatrix{TvM, TiM}: The underlying sparse matrix storing all coefficients.\ntags::Matrix{Any}: Optional tags for identifying or accessing blocks.\n\nType Parameters\n\nTvM: Value type for matrix entries (e.g., Float64).\nTiM: Integer type for matrix indices (e.g., Int64).\nTvG, TiG: Value and index types for the associated finite element spaces.\nnbrow: Number of block rows.\nnbcol: Number of block columns.\nnbtotal: Total number of blocks.\n\n\n\n\n\n","category":"type"},{"location":"fematrix/#ExtendableFEMBase.FEMatrixBlock","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrixBlock","text":"struct FEMatrixBlock{TvM, TiM, TvG, TiG, FETypeX, FETypeY, APTX, APTY} <: AbstractArray{TvM, 2}\n\nA block of an FEMatrix representing the coupling between two finite element spaces.\n\nFEMatrixBlock acts as a two-dimensional array (subclassing AbstractArray{TvM, 2}) and stores the coefficients for a specific pair of row and column finite element spaces (FESpace). Each block is mapped to a submatrix of the global sparse matrix, with offsets and sizes corresponding to the degrees of freedom of the associated spaces.\n\nFields\n\nname::String: Name of the block (for identification and display).\nFES::FESpace{TvG, TiG, FETypeX, APTX}: Row finite element space.\nFESY::FESpace{TvG, TiG, FETypeY, APTY}: Column finite element space.\noffset::Int64: Row offset in the global matrix.\noffsetY::Int64: Column offset in the global matrix.\nlast_index::Int64: Last row index for this block.\nlast_indexY::Int64: Last column index for this block.\nentries::AbstractSparseMatrix{TvM, TiM}: Reference to the underlying global sparse matrix (shared with the parent FEMatrix).\n\nSee also: [FEMatrix], [FESpace]\n\n\n\n\n\n","category":"type"},{"location":"fematrix/#Base.fill!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv, Ti}, Any}} where {Tv, Ti}","page":"FEMatrix","title":"Base.fill!","text":"fill!(B::FEMatrixBlock{Tv, Ti}, value)\n\n\nCustom fill function for FEMatrixBlock (only fills the already present nzval in the block, not the complete FEMatrix).\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.length-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"Base.length","text":"length(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Any\n\n\nCustom length function for FEMatrix that gives the total number of defined FEMatrixBlocks in it\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.show-Tuple{IO, FEMatrixBlock}","page":"FEMatrix","title":"Base.show","text":"show(io::IO, FEB::FEMatrixBlock)\n\n\nCustom show function for FEMatrixBlock that prints its coordinates and the name.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.show-Union{Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}, Tuple{IO, FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"Base.show","text":"show(\n    io::IO,\n    FEM::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n)\n\n\nCustom show function for FEMatrix that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.size-Tuple{FEMatrixBlock}","page":"FEMatrix","title":"Base.size","text":"size(FEB::FEMatrixBlock) -> Tuple{Int64, Int64}\n\n\nCustom size function for FEMatrixBlock that gives a tuple with the size of the block (that coressponds to the number of degrees of freedoms in X and Y)\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.size-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"Base.size","text":"size(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Tuple{Any, Any}\n\n\nCustom size function for FEMatrix that gives a tuple with the number of rows and columns of the FEBlock overlay\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase._addnz-Union{Tuple{Tv}, Tuple{ExtendableSparse.AbstractExtendableSparseMatrixCSC, Any, Any, Tv, Any}, Tuple{ExtendableSparse.AbstractExtendableSparseMatrixCSC, Any, Any, Tv, Any, Any}} where Tv","page":"FEMatrix","title":"ExtendableFEMBase._addnz","text":"adds value v to matrix at position (i,j) if it is nonzero\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.add!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrix{Tv, Ti}, FEMatrix{Tv, Ti}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.add!","text":"add!(A::FEMatrix{Tv, Ti}, B::FEMatrix{Tv, Ti}; kwargs...)\n\n\nAdds FEMatrix/ExtendableSparseMatrix/CSCMatrix B to FEMatrix A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv, Ti}, FEMatrixBlock{Tv, Ti}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    A::FEMatrixBlock{Tv, Ti},\n    B::FEMatrixBlock{Tv, Ti};\n    factor,\n    transpose\n)\n\n\nAdds FEMatrixBlock B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv}, ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    A::FEMatrixBlock{Tv},\n    B::ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti<:Integer};\n    factor,\n    transpose\n)\n\n\nAdds ExtendableSparseMatrix B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv}, SparseArrays.SparseMatrixCSC{Tv, Ti}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    A::FEMatrixBlock{Tv},\n    cscmat::SparseArrays.SparseMatrixCSC{Tv, Ti<:Integer};\n    factor,\n    transpose\n)\n\n\nAdds SparseMatrixCSC B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, FEMatrixBlock{Tv, Ti}, AbstractVector{Tv}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    a::AbstractArray{Tv, 1},\n    B::FEMatrixBlock{Tv, Ti},\n    b::AbstractArray{Tv, 1};\n    factor,\n    transposed\n)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv}, SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    A::FEMatrixBlock{Tv},\n    cscmatB::SparseArrays.SparseMatrixCSC{Tv, Ti},\n    cscmatC::SparseArrays.SparseMatrixCSC{Tv, Ti};\n    factor,\n    transposed\n)\n\n\nAdds matrix-matrix product B times C to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEVectorBlock{Tv, Tv1, Ti, TVector} where {Tv1, Ti, TVector<:AbstractVector{Tv}}, ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti}, FEVectorBlock{Tv, Tv1, Ti, TVector} where {Tv1, Ti, TVector<:AbstractVector{Tv}}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    a::FEVectorBlock{Tv, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractArray{Tv, 1}},\n    B::ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti<:Integer},\n    b::FEVectorBlock{Tv, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractArray{Tv, 1}};\n    factor\n)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEVectorBlock{Tv, Tv1, Ti, TVector} where {Tv1, Ti, TVector<:AbstractVector{Tv}}, FEMatrixBlock{Tv, Ti}, FEVectorBlock{Tv, Tv1, Ti, TVector} where {Tv1, Ti, TVector<:AbstractVector{Tv}}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    a::FEVectorBlock{Tv, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractArray{Tv, 1}},\n    B::FEMatrixBlock{Tv, Ti},\n    b::FEVectorBlock{Tv, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractArray{Tv, 1}};\n    factor,\n    transposed\n)\n\n\nAdds matrix-vector product B times b (or B' times b if transposed = true) to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.apply_nonzero_pattern!-Tuple{FEMatrixBlock, Type{<:ExtendableGrids.AssemblyType}}","page":"FEMatrix","title":"ExtendableFEMBase.apply_nonzero_pattern!","text":"pre-allocates the expected pattern for the default dofmaps for the AssemblyType\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.apply_penalties!-Tuple{ExtendableSparse.AbstractExtendableSparseMatrixCSC, Any, Any}","page":"FEMatrix","title":"ExtendableFEMBase.apply_penalties!","text":"apply_penalties!(\n    A::ExtendableSparse.AbstractExtendableSparseMatrixCSC,\n    fixed_dofs,\n    penalty\n)\n\n\nsets penalty to the diagonal entries of fixed_dofs in A\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.ldrdmatmul-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, AbstractVector{Tv}, ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.ldrdmatmul","text":"ldrdmatmul(\n    a1::AbstractArray{Tv, 1},\n    a2::AbstractArray{Tv, 1},\n    B::ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti<:Integer},\n    b1::AbstractArray{Tv, 1},\n    b2::AbstractArray{Tv, 1};\n    factor\n) -> Any\n\n\nComputes vector'-matrix-vector product (a1-a2)'B(b1-b2).\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.lrmatmul-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti}, AbstractVector{Tv}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.lrmatmul","text":"lrmatmul(\n    a::AbstractArray{Tv, 1},\n    B::ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti<:Integer},\n    b::AbstractArray{Tv, 1};\n    factor\n) -> Any\n\n\nComputes vector'-matrix-vector product a'Bb.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.nbcols-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"ExtendableFEMBase.nbcols","text":"nbcols(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Any\n\n\nGives the number of FEMatrixBlocks in each row.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.nbrows-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"ExtendableFEMBase.nbrows","text":"nbrows(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Any\n\n\nGives the number of FEMatrixBlocks in each column.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.submatrix-Union{Tuple{FEMatrixBlock{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.submatrix","text":"submatrix(\n    A::FEMatrixBlock{Tv, Ti}\n) -> ExtendableSparse.ExtendableSparseMatrixCSC\n\n\nReturns the FEMatrixBlock as an ExtendableSparseMatrix\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.submatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti}, Any, Any}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.submatrix","text":"submatrix(\n    A::ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti},\n    srows,\n    scols;\n    factor\n) -> ExtendableSparse.ExtendableSparseMatrixCSC\n\n\nGenerates an ExtendableSparseMatrix from the submatrix for the given row and col numbers\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Example281_DiscontinuousPlot/#281-:-Discontinuous-Plot","page":"Example281_DiscontinuousPlot","title":"281 : Discontinuous Plot","text":"","category":"section"},{"location":"module_examples/Example281_DiscontinuousPlot/","page":"Example281_DiscontinuousPlot","title":"Example281_DiscontinuousPlot","text":"(source code)","category":"page"},{"location":"module_examples/Example281_DiscontinuousPlot/","page":"Example281_DiscontinuousPlot","title":"Example281_DiscontinuousPlot","text":"This example demonstrates how to plot a discontinuous function on a grid with two regions by region-wise nodal values and plotting.","category":"page"},{"location":"module_examples/Example281_DiscontinuousPlot/","page":"Example281_DiscontinuousPlot","title":"Example281_DiscontinuousPlot","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example281_DiscontinuousPlot/","page":"Example281_DiscontinuousPlot","title":"Example281_DiscontinuousPlot","text":"(Image: )","category":"page"},{"location":"module_examples/Example281_DiscontinuousPlot/","page":"Example281_DiscontinuousPlot","title":"Example281_DiscontinuousPlot","text":"module Example281_DiscontinuousPlot\n\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing GridVisualize\n\n# function to interpolate\nfunction u!(result, qpinfo)\n    x = qpinfo.x\n    return if qpinfo.region == 1\n        result[1] = 2 * x[1] * x[2]\n    elseif qpinfo.region == 2\n        result[1] = -1 * x[2] * x[1] + 0.5\n    else\n        @error \"function was evaluated without region information\"\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(; broken = false, nrefs = 3, abs = false, Plotter = nothing)\n\n    # generate two grids\n    xgrid = grid_unitsquare(Triangle2D)\n\n    # mark first two triangles to be in second region\n    xgrid[CellRegions][1:2] .= 2\n\n    # refine\n    xgrid = uniform_refine(xgrid, nrefs)\n\n    # generate coressponding finite element spaces and FEVectors\n    FES = FESpace{L2P1{1}}(xgrid; broken = broken)\n    FEFunction = FEVector(FES)\n\n    # interpolate function onto first grid\n    interpolate!(FEFunction[1], u!; bonus_quadorder = 2)\n\n    # get subgrid for each region\n    subgrid1 = subgrid(xgrid, [1])\n    subgrid2 = subgrid(xgrid, [2])\n\n    # get parent nodes for each subgrid\n    subnodes1 = subgrid1[NodeParents]\n    subnodes2 = subgrid2[NodeParents]\n\n    # compute nodevalues for nodes of each subgrid\n    nodevals4nodes1 = nodevalues(FEFunction[1], Identity; abs = abs, regions = [1], nodes = subnodes1)\n    nodevals4nodes2 = nodevalues(FEFunction[1], Identity; abs = abs, regions = [2], nodes = subnodes2)\n\n    # plot\n    if Plotter !== nothing\n        p = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, resolution = (1000, 500))\n        gridplot!(p[1, 1], xgrid)\n        scalarplot!(p[1, 2], [subgrid1, subgrid2], xgrid, [view(nodevals4nodes1, :), view(nodevals4nodes2, :)], cellwise = false, levels = 11, title = \"u\")\n    end\n\n    return p\nend\n\nfunction generateplots(dir = pwd(); Plotter = nothing, kwargs...)\n    plt = main(; Plotter = Plotter, kwargs...)\n    scene = GridVisualize.reveal(plt)\n    return GridVisualize.save(joinpath(dir, \"example281.png\"), scene; Plotter = Plotter)\nend\nend","category":"page"},{"location":"module_examples/Example281_DiscontinuousPlot/","page":"Example281_DiscontinuousPlot","title":"Example281_DiscontinuousPlot","text":"","category":"page"},{"location":"module_examples/Example281_DiscontinuousPlot/","page":"Example281_DiscontinuousPlot","title":"Example281_DiscontinuousPlot","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interpolations/#Finite-Element-Interpolations","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"","category":"section"},{"location":"interpolations/#Source-functions-and-QPInfo","page":"Finite Element Interpolations","title":"Source functions and QPInfo","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"The functions that can be interpolated with the methods below are expected to have a certain interface, i.e.:","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"function f!(result, qpinfo) end","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"The qpinfo argument communicates vast information of the current quadrature point:","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"qpinfo child Type Description\nqpinfo.x Vector{Real} space coordinates of quadrature point\nqpinfo.time Real current time\nqpinfo.item Integer current item that contains qpinfo.x\nqpinfo.cell Integer cell number (when reasonable)\nqpinfo.region Integer region number of item\nqpinfo.xref Vector{Real} reference coordinates within item of qpinfo.x\nqpinfo.volume Real volume of item\nqpinfo.normal Vector{Real} normal vector (when reasonable)\nqpinfo.params Vector{Any} parameters that can be transferred via keyword arguments\nqpinfo.grid ExtendableGrid full access to grid","category":"page"},{"location":"interpolations/#Standard-Interpolations","page":"Finite Element Interpolations","title":"Standard Interpolations","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"Each finite element type provides a standard interpolation routine that can be applied to user-defined source functions. By default, interpolation is performed over all cells, but it can also be restricted to faces or edges using an appropriate AssemblyType.","category":"page"},{"location":"interpolations/#ExtendableGrids.interpolate!","page":"Finite Element Interpolations","title":"ExtendableGrids.interpolate!","text":"function ExtendableGrids.interpolate!(\n    target::FEVectorBlock{T, Tv, Ti},\n    AT::Type{<:AssemblyType},\n    source;\n    items = [],\n    kwargs...\n) where {T, Tv, Ti}\n\nInterpolate a function or data into the finite element space (i.e. computes the coefficients) associated with target, using the specified assembly type.\n\nArguments\n\ntarget::FEVectorBlock: The block of the FE vector to store the interpolated coefficients.\nAT::Type{<:AssemblyType}: The assembly type specifying where interpolation is performed (e.g., ON_CELLS).\nsource: The function or callable to interpolate. Should have the signature source!(result, qpinfo).\n\nKeyword Arguments\n\nitems: List of mesh entities (cells, faces, etc.) to interpolate on. If empty, all entities of the specified type are used.\nkwargs...: Additional keyword arguments passed to lower-level routines (e.g., bonus_quadorder, time).\n\nNotes\n\nFor \"broken\" FE spaces, interpolation is performed in a continuous auxiliary space and then mapped to the broken space.\nThe source! function is called at each quadrature point and should fill result with the function values at that point.\nThe qpinfo argument provides information about the current quadrature point, including coordinates, weights, and possibly time.\n\n\n\n\n\nfunction ExtendableGrids.interpolate!(target::FEVectorBlock,\n\t source::Function;\n\t kwargs...)\n\nsee interpolate!(target, ON_CELLS, source; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"Additionally, you can transfer finite element functions from one grid to another using the lazy_interpolate! routine, which interpolates between different meshes.","category":"page"},{"location":"interpolations/#ExtendableFEMBase.lazy_interpolate!","page":"Finite Element Interpolations","title":"ExtendableFEMBase.lazy_interpolate!","text":"function lazy_interpolate!(\n        target::FEVectorBlock{T1, Tv, Ti},\n        source,\n        operators = [(1, Identity)];\n        postprocess! = standard_kernel,\n        xtrafo! = nothing,\n        items = [],\n        resultdim = get_ncomponents(eltype(target.FES)),\n        not_in_domain_value = 1.0e30,\n        start_cell = 1,\n        only_localsearch = false,\n        use_cellparents::Bool = false,\n        eps = 1.0e-13,\n        kwargs...) where {T1, Tv, Ti}\n\nInterpolates (operator-evaluations of) the given FEVector source (or an array of FEVectorBlocks) into the finite element space assigned to the target FEVectorBlock.\n\nThe interpolation is performed using a point evaluation pattern and cell search. If CellParents information is available in the target grid, enabling use_cellparents=true can improve the efficiency of the search.\n\nA custom postprocessing function can be provided via the postprocess! argument, which should have the interface:     postprocess!(result, input, qpinfo) where result is the output buffer, input is the operator evaluation, and qpinfo provides quadrature point information.\n\nIf the source and target grids have different coordinate dimensions, a coordinate transformation function xtrafo! must be provided, with the interface:     xtrafo!(x_source, x) which maps coordinates x from the target grid to coordinates in the source grid.\n\nIf a point cannot be found in the source grid, the value not_in_domain_value is used as the function value. The items argument can be used to restrict the interpolation to specific target cells.\n\nArguments\n\ntarget::FEVectorBlock: The target finite element vector block.\nsource: The source array of FEVectorBlocks.\noperators: Array of operator argument tuples (source block tag, operator type)  (default: [(1, Identity)]).\n\nKeyword Arguments\n\npostprocess!: Function to postprocess operator evaluations (default: standard_kernel).\nxtrafo!: Optional coordinate transformation function (default: nothing).\nitems: List of target cells to interpolate (default: []).\nresultdim: Result dimension (default: get_ncomponents(eltype(target.FES))).\nnot_in_domain_value: Value assigned if a point is not found in the source domain (default: 1.0e30).\nstart_cell: Starting cell index for cell search (default: 1).\nonly_localsearch: Restrict cell search to local neighborhood (default: false).\nuse_cellparents: Use parent cell information for search (default: false).\neps: Tolerance for cell search (default: 1.0e-13).\nkwargs...: Additional keyword arguments passed to interpolate!.\n\nNotes\n\nDiscontinuous quantities at target grid vertices are evaluated in the first found cell of the source grid; no averaging is performed.\nThe function is not the most efficient for large-scale problems due to its reliance on pointwise cell search.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"The following function continuously interpolates finite element function into a H1Pk space by point evaluations at the Lagrange nodes of the H1Pk element (averaged over all neighbours).","category":"page"},{"location":"interpolations/#ExtendableFEMBase.continuify","page":"Finite Element Interpolations","title":"ExtendableFEMBase.continuify","text":"function continuify(\n\tsource::FEVectorBlock,\n\toperator = Identity;\n\tabs::Bool = false,\n\tbroken = false,\n\torder = \"auto\",\n\tfactor = 1,\n\tregions::Array{Int,1} = [0]) where {T,Tv,Ti,FEType,APT}\n\nInterpolate the evaluation of an operator applied to a finite element function onto a continuous Lagrange finite element space (H1Pk), returning a new FEVector with the interpolated values.\n\nThis function performs nodal interpolation of the (possibly vector-valued) result of applying operator to the FE function represented by source. The result is a new FE function in a continuous Lagrange space of the specified order and dimension. If broken = true, the interpolation is performed in a piecewise (discontinuous) fashion.\n\nArguments\n\nsource: The FEVectorBlock containing the coefficients of the original FE function.\noperator: The function operator to apply before interpolation (default: Identity).\n\nKeyword Arguments\n\nabs: If true, interpolate the Euclidean norm of the result (default: false).\nbroken: If true, generate a piecewise (discontinuous) interpolation (default: false).\norder: Polynomial order of the target Lagrange space (default: \"auto\", which chooses an appropriate order).\nfactor: Scaling factor applied to the result before interpolation (default: 1).\nregions: List of region indices to restrict interpolation (default: all regions).\n\nReturns\n\nA new FEVector in a continuous (or broken) Lagrange space, containing the interpolated values.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#Nodal-Evaluations","page":"Finite Element Interpolations","title":"Nodal Evaluations","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"Plotting routines require nodal values, i.e., the values of a finite element function at the mesh nodes. The generic nodevalues! function evaluates any finite element function at the grid nodes, averaging values if the function is discontinuous. For H1-conforming finite elements and identity evaluations, the nodevalues_view function can provide a direct view into the coefficient field, avoiding unnecessary memory allocations.","category":"page"},{"location":"interpolations/#ExtendableFEMBase.nodevalues!","page":"Finite Element Interpolations","title":"ExtendableFEMBase.nodevalues!","text":"function nodevalues!(\n        target::AbstractArray{<:Real,2},\n        source::AbstractArray{T,1},\n        FE::FESpace{Tv,Ti,FEType,AT},\n        operator::Type{<:AbstractFunctionOperator} = Identity;\n        abs::Bool = false,\n        factor = 1,\n        regions::Array{Int,1} = [0],\n        target_offset::Int = 0,\n        source_offset::Int = 0,\n        zero_target::Bool = true,\n        continuous::Bool = false\n    )\n\nEvaluate a finite element function (given by the coefficient vector source and FE space FE) at all nodes of the grid, applying an optional function operator, and write the results into target.\n\nBy default, the function is evaluated at every node in the mesh. If continuous is false, the value at each node is averaged over all neighboring cells (suitable for discontinuous quantities). If continuous is true, the value is taken from a single cell per node (suitable for continuous quantities). The result can optionally be scaled, offset, or restricted to specific regions.\n\nArguments\n\ntarget: Output array to store the evaluated values (size: result dimension × number of nodes).\nsource: Coefficient vector for the FE function.\nFE: The finite element space.\noperator: Function operator to apply at each node (default: Identity).\n\nKeyword Arguments\n\nabs: If true, store the Euclidean norm of the result at each node (default: false).\nfactor: Scaling factor applied to the result (default: 1).\nregions: List of region indices to restrict evaluation (default: all regions).\ntarget_offset: Offset for writing into target (default: 0).\nsource_offset: Offset for reading from source (default: 0).\nzero_target: If true, zero out target before writing (default: true).\ncontinuous: If true, evaluate only once per node; otherwise, average over all neighboring cells (default: false).\n\nNotes\n\nThe result dimension is determined by the FE space, the operator, and the abs argument.\nThe function modifies target in-place.\nFor vector-valued or higher-dimensional results, the first dimension of target corresponds to the result dimension.\n\n\n\n\n\nConvenience method: Evaluate a finite element function (given by the FEVectorBlock), applying an optional function operator, and write the results into target.\n\nThis forwards to the main nodevalues! method using a view of the block's entries and its FESpace.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#ExtendableFEMBase.nodevalues","page":"Finite Element Interpolations","title":"ExtendableFEMBase.nodevalues","text":"    nodevalues(\n        source::FEVectorBlock,\n        operator::Type{<:AbstractFunctionOperator} = Identity;\n        continuous = \"auto\",\n        nodes = [],\n        cellwise = false,\n        abs = false,\n        kwargs...\n    )\n\nEvaluate a finite element function (given by the coefficient vector source) at nodes of the grid, applying an optional function operator, and return the result as a newly allocated array of the appropriate size.\n\nThis function provides a flexible interface for extracting nodal or cellwise values from a finite element solution. By default, it evaluates at all nodes, but a subset of nodes can be specified. The result can be returned in a cellwise (piecewise) layout if desired.\n\nArguments\n\nsource: The FEVectorBlock containing the coefficients of the FE function.\noperator: The function operator to apply at each node (default: Identity).\n\nKeyword Arguments\n\ncontinuous: If \"auto\", automatically choose continuous/discontinuous evaluation based on FE type and operator. If true, evaluate only once per node; if false, average over all neighboring cells. Is ignored when cellwise is true.\nnodes: List of node indices to evaluate (default: all nodes).\ncellwise: If true, return values in a cellwise (piecewise) layout (default: false).\nabs: If true, return the Euclidean norm at each node (default: false).\nkwargs...: Additional keyword arguments passed to lower-level routines (e.g., regions, factor, target_offset, zero_target, etc.).\n\nReturns\n\nA newly allocated array containing the evaluated values, with shape depending on the options chosen.\n\nNotes\n\nIf nodes is empty, all nodes are evaluated.\nIf cellwise is true, the result is organized per cell (suitable for discontinuous or element-wise quantities).\nThe result dimension is determined by the FE space, the operator, and the abs argument.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#ExtendableFEMBase.nodevalues_view","page":"Finite Element Interpolations","title":"ExtendableFEMBase.nodevalues_view","text":"function nodevalues_view(\n\tsource::FEVectorBlock,\n\toperator::Type{<:AbstractFunctionOperator} = Identity)\n\nReturn a vector of views into the nodal values of the given finite element function, allowing direct access to the underlying coefficient storage for each component.\n\nThis function provides efficient, zero-copy access to the nodal values of an FEVectorBlock for unbroken H1-conforming finite element spaces with the identity operator. Each entry in the returned vector is a view into the coefficients corresponding to one component of the FE function, optionally restricted to a subset of nodes.\n\nArguments\n\nsource: The FEVectorBlock containing the coefficients of the FE function.\noperator: The function operator to apply (must be Identity for direct views; default: Identity).\n\nKeyword Arguments\n\nnodes: List of node indices to view (default: all nodes).\n\nReturns\n\nA vector of SubArray views, one for each component, directly referencing the coefficients for the specified nodes.\n\nNotes\n\nOnly available for unbroken H1-conforming elements and the Identity operator.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#ExtendableFEMBase.nodevalues_subset!","page":"Finite Element Interpolations","title":"ExtendableFEMBase.nodevalues_subset!","text":"function nodevalues_subset!(\n\ttarget::AbstractArray{<:Real,2},\n\tsource::AbstractArray{T,1},\n\tFE::FESpace{Tv,Ti,FEType,AT},\n\toperator::Type{<:AbstractFunctionOperator} = Identity;\n\tregions::Array{Int,1} = [0],\n\tabs::Bool = false,\n\tfactor = 1,\n\tnodes = [],\t\t\t\t  \n\ttarget_offset::Int = 0,   # start to write into target after offset\n\tzero_target::Bool = true, # target vector is zeroed\n\tcontinuous::Bool = false)\n\nEvaluate (an operator of) a finite element function (given by the coefficient vector source and FE space FE) at a specified subset of nodes, and write the results into target.\n\nFor each node in nodes, the function is evaluated (optionally with operator) and the result is written to the corresponding column of target. If continuous is false, values are averaged over all neighboring cells; if true, only one cell is used per node. If abs is true, the Euclidean norm is computed instead of the raw values.\n\nArguments\n\ntarget: Output array to store the evaluated values (size: result dimension × number of nodes).\nsource: Coefficient vector for the FE function.\nFE: The finite element space.\noperator: Function operator to apply (default: Identity).\nabs: If true, store the Euclidean norm of the result at each node (default: false).\nfactor: Scaling factor applied to the result (default: 1).\nnodes: List of node indices to evaluate (default: all nodes).\nregions: List of region indices to restrict evaluation (default: all regions).\ntarget_offset: Offset for writing into target (default: 0).\nsource_offset: Offset for reading from source (default: 0).\nzero_target: If true, zero out target before writing (default: true).\ncontinuous: If true, evaluate only once per node; otherwise, average over all neighboring cells (default: false).\n\nNotes\n\nThe result dimension is determined by the FE space and operator and the abs argument.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#Displace-Mesh","page":"Finite Element Interpolations","title":"Displace Mesh","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"Nodal values (e.g. of a FEVector that discretizes a displacement) can be used to displace the mesh.","category":"page"},{"location":"interpolations/#ExtendableFEMBase.displace_mesh!","page":"Finite Element Interpolations","title":"ExtendableFEMBase.displace_mesh!","text":"function displace_mesh!(xgrid::ExtendableGrid, source::FEVectorBlock; magnify = 1)\n\nDisplace all nodes of the given grid by adding a vector-valued finite element field as a displacement, scaled by an optional magnification factor.\n\nThis function modifies the coordinates of xgrid in-place by adding the nodal values of the FE function represented by source (typically a displacement field) to each node. The displacement can be scaled by the magnify parameter. After the update, all cached geometric quantities in the grid are invalidated and recomputed.\n\nArguments\n\nxgrid: The ExtendableGrid whose node coordinates will be updated.\nsource: An FEVectorBlock representing the displacement field (must be vector-valued and defined on the grid).\n\nKeyword Arguments\n\nmagnify: Scaling factor for the displacement field (default: 1).\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#ExtendableFEMBase.displace_mesh","page":"Finite Element Interpolations","title":"ExtendableFEMBase.displace_mesh","text":"function displace_mesh(xgrid::ExtendableGrid, source::FEVectorBlock; magnify = 1)\n\nReturn a new grid with node coordinates displaced by a vector-valued finite element field, optionally scaled by a magnification factor.\n\nArguments\n\nxgrid: The ExtendableGrid to be copied and displaced.\nsource: An FEVectorBlock representing the displacement field (must be vector-valued and defined on the grid).\n\nKeyword Arguments\n\nmagnify: Scaling factor for the displacement field (default: 1).\n\nReturns\n\nA new ExtendableGrid with displaced node coordinates.\n\n\n\n\n\n","category":"function"},{"location":"package_index/","page":"Index","title":"Index","text":"Modules = [ExtendableFEMBase]\nOrder   = [:function, :type]","category":"page"},{"location":"fevector/#FEVector","page":"FEVector","title":"FEVector","text":"","category":"section"},{"location":"fevector/","page":"FEVector","title":"FEVector","text":"A FEVector represents a block-structured vector used in finite element computations. It consists of one or more FEVectorBlocks, each associated with a specific FESpace. All blocks share a common one-dimensional array that stores the global degrees of freedom (DoFs). Each block can only write to a region of the array specified by offsets, ensuring that each FESpace manages its own DoFs within the global vector.","category":"page"},{"location":"fevector/#Core.Array-Tuple{FEVectorBlock}","page":"FEVector","title":"Core.Array","text":"Array(FEB::FEVectorBlock) -> Any\n\n\nConvert an FEVectorBlock to a standard Julia array containing the coefficients for that block.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Core.Array-Tuple{FEVector}","page":"FEVector","title":"Core.Array","text":"Array(FEV::FEVector) -> Any\n\n\nConvert an FEVector to a standard Julia array containing all coefficients.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.FEVector","page":"FEVector","title":"ExtendableFEMBase.FEVector","text":"struct FEVector{T, Tv, Ti, TVector<:AbstractArray{T, 1}}\n\nA block-structured vector for storing coefficients associated with one or more finite element spaces (FESpace).\n\nAn FEVector consists of a global coefficient array subdivided into multiple FEVectorBlocks, each corresponding to a specific FESpace. This structure enables efficient block-wise access, assembly, and manipulation of solution vectors in finite element computations, especially for multi-field or mixed problems.\n\nType Parameters\n\nT: Value type of the vector entries (e.g., Float64).\nTv: Value type for the associated FESpace.\nTi: Integer type for the associated FESpace.\nTVector: Type of the entries vector\n\nFields\n\nFEVectorBlocks::Array{FEVectorBlock{T, Tv, Ti}, 1}: Array of blocks, each representing a segment of the global vector for a specific FESpace.\nentries::TVector: The global coefficient array, shared by all blocks.\ntags::Vector{Any}: Optional tags for identifying or accessing blocks (e.g., by name or symbol).\n\n\n\n\n\n","category":"type"},{"location":"fevector/#ExtendableFEMBase.FEVector-Union{Tuple{FESpace{Tv, Ti, FEType, APT}}, Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType, APT}","page":"FEVector","title":"ExtendableFEMBase.FEVector","text":"FEVector{T}(FES; name = nothing, tags = nothing, kwargs...) where T <: Real\n\nConstructs an FEVector for storing coefficients associated with one or more finite element spaces (FESpace).\n\nIf FES is a single FESpace, the resulting FEVector contains one block.\nIf FES is a vector of FESpace objects, the resulting FEVector is block-structured, with one block per space.\n\nOptionally, you can assign a name (as a String for all blocks, or a vector of String for each block) and/or tags (as an array of any type) to the blocks for identification and access.\n\nArguments\n\nFES::FESpace or FES::Vector{<:FESpace}: The finite element space(s) for which to create the vector.\n\nKeyword Arguments\n\nentries: Optional array of coefficients. If not provided, a zero vector of appropriate length is created.\nname: Name for the vector or for each block (default: nothing causes auto naming by index or tag).\ntags: Array of tags for the blocks (default: [], i.e. block access only by index).\n\nReturns\n\nAn FEVector object with one or more FEVectorBlocks, each corresponding to a given FESpace.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.FEVectorBlock","page":"FEVector","title":"ExtendableFEMBase.FEVectorBlock","text":"struct FEVectorBlock{T, Tv, Ti, TVector<:AbstractArray{T, 1}, FEType, APT} <: AbstractArray{T, 1}\n\nA block within an FEVector representing a contiguous segment of coefficients associated with a specific finite element space (FESpace).\n\nEach FEVectorBlock provides array-like access to the degrees of freedom (DOFs) for its associated FESpace, mapping local indices to a shared global coefficient array. This enables efficient block-wise operations, assembly, and extraction of sub-vectors corresponding to different FE spaces.\n\nType Parameters\n\nT: Value type of the vector entries (e.g., Float64).\nTv: Value type for the associated FESpace.\nTi: Integer type for the associated FESpace.\nTVector: Type of the entries vector.\nFEType: Type of the finite element.\nAPT: Assembly type for the finite element.\n\nFields\n\nname::String: Name or label for this block (for identification or debugging).\nFES::FESpace{Tv, Ti, FEType, APT}: The finite element space associated with this block.\noffset::Int: Global offset (start index in the global vector).\nlast_index::Int: Global end index (inclusive).\nentries::TVector: Reference to the global coefficient array (shared with the parent FEVector).\n\nUsage\n\nFEVectorBlock is typically created internally by FEVector constructors and provides efficient access to the coefficients for a particular FE space. Supports standard array operations (getindex, setindex!, size, length, etc.) and can be used for block-wise assembly, extraction, and manipulation.\n\n\n\n\n\n","category":"type"},{"location":"fevector/#Base.append!-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{T}, Tuple{FEVector{T, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractVector{T}}, FESpace{Tv, Ti, FEType, APT}}} where {T, Tv, Ti, FEType, APT}","page":"FEVector","title":"Base.append!","text":"append!(\n    FEF::FEVector{T, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractArray{T, 1}},\n    FES::FESpace{Tv, Ti, FEType, APT};\n    name,\n    tag\n) -> Int64\n\n\nOverloaded append function for FEVector that adds a FEVectorBlock at the end.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.fill!-Tuple{FEVectorBlock, Any}","page":"FEVector","title":"Base.fill!","text":"fill!(b::FEVectorBlock, value)\n\n\nOverloaded fill function for FEVectorBlock (only fills the block, not the complete FEVector).\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.length-Tuple{FEVectorBlock}","page":"FEVector","title":"Base.length","text":"length(FEB::FEVectorBlock) -> Int64\n\n\nCustom length function for FEVectorBlock that gives the coressponding number of degrees of freedoms of the associated FESpace\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.length-Tuple{FEVector}","page":"FEVector","title":"Base.length","text":"length(FEF::FEVector) -> Int64\n\n\nCustom length function for FEVector that gives the number of defined FEMatrixBlocks in it\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.show-Tuple{IO, FEVector}","page":"FEVector","title":"Base.show","text":"show(io::IO, FEF::FEVector)\n\n\nCustom show function for FEVector that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, FEVectorBlock}","page":"FEVector","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    FEB::FEVectorBlock\n) -> Any\n\n\nCustom show function for FEVectorBlock that prints some information and the view of that block.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.view-Tuple{FEVectorBlock, Union{Integer, AbstractArray{<:Integer}}}","page":"FEVector","title":"Base.view","text":"view(\n    FEB::FEVectorBlock,\n    inds::Union{Integer, AbstractArray{<:Integer}}\n) -> Any\n\n\nReturns a view of a slice of the FEVectorBlock, specified by local indices inds (which can be an integer, a range, or an array of indices). The indices are relative to the block (i.e., 1 corresponds to the first entry of the block).\n\nArguments\n\nFEB::FEVectorBlock: The FEVectorBlock to view.\ninds: Indices relative to the block (e.g., 1:30, [2,4,6]).\n\nReturns\n\nA view into the underlying entries array for the specified slice.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.view-Tuple{FEVectorBlock}","page":"FEVector","title":"Base.view","text":"view(FEB::FEVectorBlock) -> Any\n\n\nReturns a view of the part of the full FEVector that coressponds to the block. \n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.FESpaces-Union{Tuple{FEVector{T, Tv, Ti, TVector} where TVector<:AbstractVector{T}}, Tuple{Ti}, Tuple{Tv}, Tuple{T}} where {T, Tv, Ti}","page":"FEVector","title":"ExtendableFEMBase.FESpaces","text":"FESpaces(\n    FEV::FEVector{T, Tv, Ti, TVector} where TVector<:AbstractArray{T, 1}\n) -> Vector{T} where T<:FESpace\n\n\nReturns the vector of FEspaces for the blocks of the given FEVector.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.addblock!-Tuple{FEVectorBlock, AbstractVector}","page":"FEVector","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    a::FEVectorBlock,\n    b::AbstractVector;\n    factor,\n    offset\n)\n\n\nAdds Array b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.addblock!-Tuple{FEVectorBlock, FEVectorBlock}","page":"FEVector","title":"ExtendableFEMBase.addblock!","text":"addblock!(a::FEVectorBlock, b::FEVectorBlock; factor)\n\n\nAdds FEVectorBlock b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.get_ncomponents-Tuple{FEVectorBlock}","page":"FEVector","title":"ExtendableFEMBase.get_ncomponents","text":"get_ncomponents(FB::FEVectorBlock) -> Any\n\n\nReturns the number of components for the finite element in that block.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.norms-Union{Tuple{FEVector{T, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractVector{T}}}, Tuple{T}, Tuple{FEVector{T, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractVector{T}}, Real}} where T","page":"FEVector","title":"ExtendableFEMBase.norms","text":"norms(\n    FEV::FEVector{T, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractArray{T, 1}}\n) -> Any\nnorms(\n    FEV::FEVector{T, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractArray{T, 1}},\n    p::Real\n) -> Any\n\n\nReturns a vector with the individual norms of all blocks.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#LinearAlgebra.dot-Union{Tuple{T}, Tuple{FEVectorBlock{T, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractVector{T}}, FEVectorBlock{T, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractVector{T}}}} where T","page":"FEVector","title":"LinearAlgebra.dot","text":"dot(\n    a::FEVectorBlock{T, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractArray{T, 1}},\n    b::FEVectorBlock{T, Tv, Ti, TVector} where {Tv, Ti, TVector<:AbstractArray{T, 1}}\n) -> Any\n\n\nScalar product between two FEVEctorBlocks.\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#PointEvaluator","page":"PointEvaluator","title":"PointEvaluator","text":"","category":"section"},{"location":"pointevaluators/","page":"PointEvaluator","title":"PointEvaluator","text":"Point evaluators provide a convenient interface to evaluate finite element functions (FEVector) at arbitrary spatial points, not restricted to mesh nodes or quadrature points. This is useful for post-processing, visualization, or extracting solution values at specific locations.","category":"page"},{"location":"pointevaluators/#ExtendableFEMBase.PointEvaluator","page":"PointEvaluator","title":"ExtendableFEMBase.PointEvaluator","text":"PointEvaluator(\n    kernel,\n    u_args,\n    ops_args;\n    ...\n) -> PointEvaluator{Float64}\nPointEvaluator(\n    kernel,\n    u_args,\n    ops_args,\n    sol;\n    Tv,\n    kwargs...\n) -> PointEvaluator{Float64}\n\n\nConstruct a PointEvaluator object for evaluating operator expressions at arbitrary points in a finite element space.\n\nA PointEvaluator can be used to evaluate one or more operator evaluations (e.g., function values, gradients) at arbitrary points, optionally postprocessed by a user-supplied kernel function. The evaluation is performed with respect to a given solution and its finite element basis.\n\nAfter construction, the PointEvaluator must be initialized with a solution using initialize!. Evaluation at a point is then performed using evaluate! or evaluate_bary!.\n\nArguments\n\nkernel! (optional): Postprocessing function for operator evaluations. Should have the form kernel!(result, eval_args, qpinfo).\noa_args: Array of operator argument tuples (source block tag, operator type).\nsol (optional): Solution object for immediate initialization.\n\nKeyword arguments:\n\nresultdim: dimension of result field (default = length of operators). Default: 0\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nname: name for operator used in printouts. Default: ''PointEvaluator''\nverbosity: verbosity level. Default: 0\n\nKernel Function Interface\n\nkernel!(result, eval_args, qpinfo)\n\nresult: Preallocated array to store the kernel output.\neval_args: Array of operator evaluations at the current evaluation point.\nqpinfo: QPInfos struct with information about the current evaluation point.\n\nUsage\n\nAfter construction, call initialize! to prepare the evaluator for a given solution, then use evaluate! or evaluate_bary! to perform point evaluations.\n\n\n\n\n\n","category":"type"},{"location":"pointevaluators/#ExtendableFEMBase.eval_func-Tuple{PointEvaluator}","page":"PointEvaluator","title":"ExtendableFEMBase.eval_func","text":"function eval_func(PE::PointEvaluator)\n\nYields the function (result, x) -> evaluate!(result,PE,x).\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#ExtendableFEMBase.eval_func_bary-Tuple{PointEvaluator}","page":"PointEvaluator","title":"ExtendableFEMBase.eval_func_bary","text":"function eval_func_bary(PE::PointEvaluator)\n\nYields the function (result, xref, item) -> evaluate_bary!(result,PE,xref,item).\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#ExtendableFEMBase.evaluate!-Tuple{Any, PointEvaluator, Any}","page":"PointEvaluator","title":"ExtendableFEMBase.evaluate!","text":"function evaluate!(\n\tresult,\n\tPE::PointEvaluator,\n\tx\n\t)\n\nEvaluates the PointEvaluator at the specified coordinates x. (To do so it internally calls CellFinder to find the cell and the barycentric coordinates of x and calls evaluate_bary!.)\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#ExtendableFEMBase.evaluate_bary!-Tuple{Any, PointEvaluator, Any, Any}","page":"PointEvaluator","title":"ExtendableFEMBase.evaluate_bary!","text":"function evaluate_bary!(\n\tresult,\n\tPE::PointEvaluator,\n\txref, \n\titem\n\t)\n\nEvaluates the PointEvaluator at the specified reference coordinates in the cell with the specified item number.\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#ExtendableFEMBase.initialize!-Union{Tuple{UT}, Tuple{T}, Tuple{PointEvaluator{T, UT}, Any}} where {T, UT}","page":"PointEvaluator","title":"ExtendableFEMBase.initialize!","text":"function initialize!(\n\tO::PointEvaluator,\n\tsol;\n\ttime = 0,\n\tkwargs...)\n\nInitializes the given PointEvaluator for a specified solution (FEVector or vector of FEVectorBlocks).\n\nThis function prepares the PointEvaluator for evaluation by associating it with the provided solution vector. It sets up the necessary finite element basis evaluators, local-to-global transformations, and cell finder structures for the underlying grid.\n\nArguments\n\nO::PointEvaluator: The PointEvaluator instance to initialize.\nsol: The solution object (e.g., array of FEVectorBlocks) to be used for evaluations.\n\nKeyword Arguments\n\ntime: (default: 0) Time value to be passed to the quadrature point info structure.\nresultdim: dimension of result field (default = length of operators). Default: 0\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nname: name for operator used in printouts. Default: ''PointEvaluator''\nverbosity: verbosity level. Default: 0\n\nNotes\n\nThis function must be called before using evaluate! or evaluate_bary! with the PointEvaluator.\n\nInitializes the given PointEvaluator for a specified solution (FEVector or vector of FEVectorBlocks).\n\nThis function prepares the PointEvaluator for evaluation by associating it with the provided solution vector. It sets up the necessary finite element basis evaluators, local-to-global transformations, and cell finder structures for the underlying grid.\n\nArguments\n\nO::PointEvaluator: The PointEvaluator instance to initialize.\nsol: The solution object (e.g., array of FEVectorBlocks) to be used for evaluations.\n\nKeyword Arguments\n\ntime: (default: 0) Time value to be passed to the quadrature point info structure.\nresultdim: dimension of result field (default = length of operators). Default: 0\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nname: name for operator used in printouts. Default: ''PointEvaluator''\nverbosity: verbosity level. Default: 0\n\nNotes\n\nThis function must be called before using evaluate! or evaluate_bary! with the PointEvaluator.\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Example210_LowLevelNavierStokes/#210-:-Navier-Stokes-Problem","page":"Example210_LowLevelNavierStokes","title":"210 : Navier-Stokes Problem","text":"","category":"section"},{"location":"module_examples/Example210_LowLevelNavierStokes/","page":"Example210_LowLevelNavierStokes","title":"Example210_LowLevelNavierStokes","text":"(source code)","category":"page"},{"location":"module_examples/Example210_LowLevelNavierStokes/","page":"Example210_LowLevelNavierStokes","title":"Example210_LowLevelNavierStokes","text":"Consider the Navier-Stokes problem that seeks mathbfu and p such that","category":"page"},{"location":"module_examples/Example210_LowLevelNavierStokes/","page":"Example210_LowLevelNavierStokes","title":"Example210_LowLevelNavierStokes","text":"beginaligned\n    - mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p = mathbff \n    mathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example210_LowLevelNavierStokes/","page":"Example210_LowLevelNavierStokes","title":"Example210_LowLevelNavierStokes","text":"The weak formulation seeks mathbfu in V = H^1_0(Omega)^2 and p in Q = L^2_0(Omega) such that","category":"page"},{"location":"module_examples/Example210_LowLevelNavierStokes/","page":"Example210_LowLevelNavierStokes","title":"Example210_LowLevelNavierStokes","text":"beginaligned\n    mu (nabla mathbfu nabla mathbfv) + ((mathbfu cdot nabla) mathbfu mathbfv) - (p mathrmdiv(mathbfv))  = (mathbff mathbfv)\n     textfor all  mathbfv in V\n    (q mathrmdiv(mathbfu))  = 0\n     textfor all  q in Q\nendaligned","category":"page"},{"location":"module_examples/Example210_LowLevelNavierStokes/","page":"Example210_LowLevelNavierStokes","title":"Example210_LowLevelNavierStokes","text":"This example computes a planar lattice flow with inhomogeneous Dirichlet boundary conditions (which requires some modification above). Newton's method with automatic differentation is used to handle the nonlinear convection term.","category":"page"},{"location":"module_examples/Example210_LowLevelNavierStokes/","page":"Example210_LowLevelNavierStokes","title":"Example210_LowLevelNavierStokes","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example210_LowLevelNavierStokes/","page":"Example210_LowLevelNavierStokes","title":"Example210_LowLevelNavierStokes","text":"(Image: )","category":"page"},{"location":"module_examples/Example210_LowLevelNavierStokes/","page":"Example210_LowLevelNavierStokes","title":"Example210_LowLevelNavierStokes","text":"module Example210_LowLevelNavierStokes\n\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\nusing ForwardDiff\nusing DiffResults\n\n# data for Poisson problem\nconst μ = 1.0e-2\nfunction f!(fval, x, t) # right-hand side\n    fval[1] = 8.0 * π * π * μ * exp(-8.0 * π * π * μ * t) * sin(2.0 * π * x[1]) * sin(2.0 * π * x[2])\n    fval[2] = 8.0 * π * π * μ * exp(-8.0 * π * π * μ * t) * cos(2.0 * π * x[1]) * cos(2.0 * π * x[2])\n    return nothing\nend\n\n# exact velocity (for boundary data and error calculation)\nfunction u!(uval, qpinfo)\n    x = qpinfo.x\n    t = qpinfo.time\n    uval[1] = exp(-8.0 * π * π * μ * t) * sin(2.0 * π * x[1]) * sin(2.0 * π * x[2])\n    uval[2] = exp(-8.0 * π * π * μ * t) * cos(2.0 * π * x[1]) * cos(2.0 * π * x[2])\n    return nothing\nend\n\n# exact pressure (for error calculation)\nfunction p!(pval, qpinfo)\n    x = qpinfo.x\n    t = qpinfo.time\n    pval[1] = exp(-16 * pi * pi * μ * t) * (cos(4 * pi * x[1]) - cos(4 * pi * x[2])) / 4\n    return nothing\nend\n\nfunction main(; nref = 5, teval = 0, order = 2, Plotter = nothing)\n\n    @assert order >= 2\n\n    # create grid\n    X = LinRange(0, 1, 2^nref + 1)\n    Y = LinRange(0, 1, 2^nref + 1)\n    println(\"Creating grid...\")\n    @time xgrid = simplexgrid(X, Y)\n\n    # create FESpace\n    println(\"Creating FESpace...\")\n    FETypes = [H1Pk{2, 2, order}, H1Pk{1, 2, order - 1}]\n    @time FES = [\n        FESpace{FETypes[1]}(xgrid; name = \"velocity space\"),\n        FESpace{FETypes[2]}(xgrid; name = \"pressure space\"),\n    ]\n    FES\n\n    # solve\n    sol = solve_stokes_lowlevel(FES; teval = teval)\n\n    # move integral mean of pressure\n    pmean = sum(compute_error(sol[2], nothing, order, 1))\n    for j in 1:sol[2].FES.ndofs\n        sol[2][j] -= pmean\n    end\n\n    # calculate l2 error\n    error_u = sqrt(sum(compute_error(sol[1], u!, 2)))\n    error_p = sqrt(sum(compute_error(sol[2], p!, 2)))\n    println(\"\\nl2 error velo = $(error_u)\")\n    println(\"l2 error pressure = $(error_p)\")\n\n    # plot\n    plt = GridVisualizer(; Plotter = Plotter, layout = (1, 1), clear = true, resolution = (500, 500))\n    scalarplot!(plt[1, 1], xgrid, nodevalues(sol[1]; abs = true)[1, :]; title = \"|u| + quiver\", Plotter = Plotter)\n    vectorplot!(plt[1, 1], xgrid, eval_func_bary(PointEvaluator([(1, Identity)], sol)), clear = false)\n\n    return sol, plt\nend\n\n# computes error and integrals\nfunction compute_error(uh::FEVectorBlock, u, order = get_polynomialorder(get_FEType(uh), uh.FES.xgrid[CellGeometries][1]), p = 2)\n    xgrid = uh.FES.xgrid\n    FES = uh.FES\n    EG = xgrid[UniqueCellGeometries][1]\n    ncomponents = get_ncomponents(uh)\n    cellvolumes = xgrid[CellVolumes]\n    celldofs = FES[CellDofs]\n    error = zeros(Float64, ncomponents, num_cells(xgrid))\n    uhval = zeros(Float64, ncomponents)\n    uval = zeros(Float64, ncomponents)\n    L2G = L2GTransformer(EG, xgrid, ON_CELLS)\n    QP = QPInfos(xgrid)\n    qf = VertexRule(EG, order)\n    FEB = FEEvaluator(FES, Identity, qf)\n\n    function barrier(L2G::L2GTransformer)\n        for cell in 1:num_cells(xgrid)\n            update_trafo!(L2G, cell)\n            update_basis!(FEB, cell)\n            for (qp, weight) in enumerate(qf.w)\n                # evaluate uh\n                fill!(uhval, 0)\n                eval_febe!(uhval, FEB, view(view(uh), view(celldofs, :, cell)), qp)\n\n                # evaluate u\n                if u !== nothing\n                    fill!(uval, 0)\n                    eval_trafo!(QP.x, L2G, qf.xref[qp])\n                    u(uval, QP)\n                end\n\n                # evaluate error\n                for d in 1:ncomponents\n                    error[d, cell] += (uhval[d] - uval[d]) .^ p * cellvolumes[cell] * weight\n                end\n            end\n        end\n        return\n    end\n\n    barrier(L2G)\n    return error\nend\n\nfunction solve_stokes_lowlevel(FES; teval = 0)\n\n    println(\"Initializing system...\")\n    sol = FEVector(FES)\n    A = FEMatrix(FES)\n    b = FEVector(FES)\n    @time update_system! = prepare_assembly!(A, b, FES[1], FES[2], sol)\n    @time update_system!(true, false)\n    Alin = deepcopy(A) ## = keep linear part of system matrix\n    blin = deepcopy(b) ## = keep linear part of right-hand side\n\n    println(\"Prepare boundary conditions...\")\n    @time begin\n        u_init = FEVector(FES)\n        interpolate!(u_init[1], u!; time = teval)\n        fixed_dofs = boundarydofs(FES[1])\n        push!(fixed_dofs, FES[1].ndofs + 1) ## fix one pressure dof\n    end\n\n    for it in 1:20\n        # solve\n        println(\"\\nITERATION $it\\n=============\")\n        println(\"Solving linear system...\")\n        @time copyto!(sol.entries, A.entries \\ b.entries)\n        res = A.entries.cscmatrix * sol.entries .- b.entries\n        for dof in fixed_dofs\n            res[dof] = 0\n        end\n        linres = norm(res)\n        println(\"linear residual = $linres\")\n\n        fill!(A.entries.cscmatrix.nzval, 0)\n        fill!(b.entries, 0)\n        println(\"Updating linear system...\")\n        @time begin\n            update_system!(false, true)\n            A.entries.cscmatrix += Alin.entries.cscmatrix\n            b.entries .+= blin.entries\n        end\n\n        # fix boundary dofs\n        for dof in fixed_dofs\n            A.entries[dof, dof] = 1.0e60\n            b.entries[dof] = 1.0e60 * u_init.entries[dof]\n        end\n        ExtendableSparse.flush!(A.entries)\n\n        # calculate nonlinear residual\n        res = A.entries.cscmatrix * sol.entries .- b.entries\n        for dof in fixed_dofs\n            res[dof] = 0\n        end\n        nlres = norm(res)\n        println(\"nonlinear residual = $nlres\")\n        if nlres < max(1.0e-12, 20 * linres)\n            break\n        end\n    end\n\n    return sol\nend\n\nfunction prepare_assembly!(A, b, FESu, FESp, sol; teval = 0)\n\n    A = A.entries\n    b = b.entries\n    sol = sol.entries\n    xgrid = FESu.xgrid\n    EG = xgrid[UniqueCellGeometries][1]\n    FEType_u = eltype(FESu)\n    FEType_p = eltype(FESp)\n    L2G = L2GTransformer(EG, xgrid, ON_CELLS)\n    cellvolumes = xgrid[CellVolumes]\n    ncells::Int = num_cells(xgrid)\n\n    # dofmap\n    CellDofs_u = FESu[ExtendableFEMBase.CellDofs]\n    CellDofs_p = FESp[ExtendableFEMBase.CellDofs]\n    offset_p = FESu.ndofs\n\n    # quadrature formula\n    qf = QuadratureRule{Float64, EG}(3 * get_polynomialorder(FEType_u, EG) - 1)\n    weights::Vector{Float64} = qf.w\n    xref::Vector{Vector{Float64}} = qf.xref\n    nweights::Int = length(weights)\n\n    # FE basis evaluator\n    FEBasis_∇u = FEEvaluator(FESu, Gradient, qf)\n    ∇uvals = FEBasis_∇u.cvals\n    FEBasis_idu = FEEvaluator(FESu, Identity, qf)\n    iduvals = FEBasis_idu.cvals\n    FEBasis_idp = FEEvaluator(FESp, Identity, qf)\n    idpvals = FEBasis_idp.cvals\n\n    # prepare automatic differentation of convection operator\n    function operator!(result, input)\n        # result = (u ⋅ ∇)u\n        result[1] = input[1] * input[3] + input[2] * input[4]\n        return result[2] = input[1] * input[5] + input[2] * input[6]\n    end\n    result = Vector{Float64}(undef, 2)\n    input = Vector{Float64}(undef, 6)\n    tempV = zeros(Float64, 2)\n    Dresult = DiffResults.JacobianResult(result, input)\n    cfg = ForwardDiff.JacobianConfig(operator!, result, input, ForwardDiff.Chunk{6}())\n    jac = DiffResults.jacobian(Dresult)\n    value = DiffResults.value(Dresult)\n\n    # ASSEMBLY LOOP\n    function barrier(EG, L2G::L2GTransformer, linear::Bool, nonlinear::Bool)\n        # barrier function to avoid allocations caused by L2G\n\n        ndofs4cell_u::Int = get_ndofs(ON_CELLS, FEType_u, EG)\n        ndofs4cell_p::Int = get_ndofs(ON_CELLS, FEType_p, EG)\n        Aloc = zeros(Float64, ndofs4cell_u, ndofs4cell_u)\n        Bloc = zeros(Float64, ndofs4cell_u, ndofs4cell_p)\n        dof_j::Int, dof_k::Int = 0, 0\n        fval::Vector{Float64} = zeros(Float64, 2)\n        x::Vector{Float64} = zeros(Float64, 2)\n\n        for cell in 1:ncells\n            # update FE basis evaluators\n            update_basis!(FEBasis_∇u, cell)\n            update_basis!(FEBasis_idu, cell)\n            update_basis!(FEBasis_idp, cell)\n\n            # assemble local stiffness matrix (symmetric)\n            if (linear)\n                for j in 1:ndofs4cell_u, k in 1:ndofs4cell_u\n                    temp = 0\n                    for qp in 1:nweights\n                        temp += weights[qp] * dot(view(∇uvals, :, j, qp), view(∇uvals, :, k, qp))\n                    end\n                    Aloc[k, j] = μ * temp\n                end\n\n                # assemble div-pressure coupling\n                for j in 1:ndofs4cell_u, k in 1:ndofs4cell_p\n                    temp = 0\n                    for qp in 1:nweights\n                        temp -= weights[qp] * (∇uvals[1, j, qp] + ∇uvals[4, j, qp]) *\n                            idpvals[1, k, qp]\n                    end\n                    Bloc[j, k] = temp\n                end\n                Bloc .*= cellvolumes[cell]\n\n                # assemble right-hand side\n                update_trafo!(L2G, cell)\n                for j in 1:ndofs4cell_u\n                    # right-hand side\n                    temp = 0\n                    for qp in 1:nweights\n                        # get global x for quadrature point\n                        eval_trafo!(x, L2G, xref[qp])\n                        # evaluate (f(x), v_j(x))\n                        f!(fval, x, teval)\n                        temp += weights[qp] * dot(view(iduvals, :, j, qp), fval)\n                    end\n                    # write into global vector\n                    dof_j = CellDofs_u[j, cell]\n                    b[dof_j] += temp * cellvolumes[cell]\n                end\n            end\n\n            # assemble nonlinear term\n            if (nonlinear)\n                for qp in 1:nweights\n                    fill!(input, 0)\n                    for j in 1:ndofs4cell_u\n                        dof_j = CellDofs_u[j, cell]\n                        for d in 1:2\n                            input[d] += sol[dof_j] * iduvals[d, j, qp]\n                        end\n                        for d in 1:4\n                            input[2 + d] += sol[dof_j] * ∇uvals[d, j, qp]\n                        end\n                    end\n\n                    # evaluate jacobian\n                    ForwardDiff.chunk_mode_jacobian!(Dresult, operator!, result, input, cfg)\n\n                    # update matrix\n                    for j in 1:ndofs4cell_u\n                        # multiply ansatz function with local jacobian\n                        fill!(tempV, 0)\n                        for d in 1:2\n                            tempV[1] += jac[1, d] * iduvals[d, j, qp]\n                            tempV[2] += jac[2, d] * iduvals[d, j, qp]\n                        end\n                        for d in 1:4\n                            tempV[1] += jac[1, 2 + d] * ∇uvals[d, j, qp]\n                            tempV[2] += jac[2, 2 + d] * ∇uvals[d, j, qp]\n                        end\n\n                        # multiply test function operator evaluation\n                        for k in 1:ndofs4cell_u\n                            Aloc[k, j] += dot(tempV, view(iduvals, :, k, qp)) * weights[qp]\n                        end\n                    end\n\n                    # update rhs\n                    mul!(tempV, jac, input)\n                    tempV .-= value\n                    for j in 1:ndofs4cell_u\n                        dof_j = CellDofs_u[j, cell]\n                        b[dof_j] += dot(tempV, view(iduvals, :, j, qp)) * weights[qp] * cellvolumes[cell]\n                    end\n                end\n            end\n\n            # add local matrices to global matrix\n            Aloc .*= cellvolumes[cell]\n            for j in 1:ndofs4cell_u\n                dof_j = CellDofs_u[j, cell]\n                for k in 1:ndofs4cell_u\n                    dof_k = CellDofs_u[k, cell]\n                    rawupdateindex!(A, +, Aloc[j, k], dof_j, dof_k)\n                end\n                if (linear)\n                    for k in 1:ndofs4cell_p\n                        dof_k = CellDofs_p[k, cell] + offset_p\n                        rawupdateindex!(A, +, Bloc[j, k], dof_j, dof_k)\n                        rawupdateindex!(A, +, Bloc[j, k], dof_k, dof_j)\n                    end\n                end\n            end\n            fill!(Aloc, 0)\n            fill!(Bloc, 0)\n        end\n        return\n    end\n\n    function update_system!(linear::Bool, nonlinear::Bool)\n        barrier(EG, L2G, linear, nonlinear)\n        return flush!(A)\n    end\n    return update_system!\nend\n\nfunction generateplots(dir = pwd(); Plotter = nothing, kwargs...)\n    ~, plt = main(; Plotter = Plotter, kwargs...)\n    scene = GridVisualize.reveal(plt)\n    return GridVisualize.save(joinpath(dir, \"example210.png\"), scene; Plotter = Plotter)\nend\nend #module","category":"page"},{"location":"module_examples/Example210_LowLevelNavierStokes/","page":"Example210_LowLevelNavierStokes","title":"Example210_LowLevelNavierStokes","text":"","category":"page"},{"location":"module_examples/Example210_LowLevelNavierStokes/","page":"Example210_LowLevelNavierStokes","title":"Example210_LowLevelNavierStokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"segmentintegrators/#SegmentIntegrator","page":"SegmentIntegrator","title":"SegmentIntegrator","text":"","category":"section"},{"location":"segmentintegrators/","page":"SegmentIntegrator","title":"SegmentIntegrator","text":"Segment integrators provide tools to integrate finite element functions (FEVector) along arbitrary line segments that pass through mesh cells.","category":"page"},{"location":"segmentintegrators/#ExtendableFEMBase.SegmentIntegrator-Tuple{Any, Any, Vector{<:Tuple{Any, DataType}}}","page":"SegmentIntegrator","title":"ExtendableFEMBase.SegmentIntegrator","text":"function SegmentIntegrator(\n\tEG::ElementGeometry,\n\t[kernel!::Function],\n\toa_args::Array{<:Tuple{<:Any, DataType},1};\n\tkwargs...)\n\nConstruct a SegmentIntegrator for integrating over segments of the given element geometry EG.\n\nAt each quadrature point, the specified operator evaluations are performed, optionally postprocessed by the provided kernel! function, and accumulated using the quadrature weights. If no kernel is given, the operator arguments are integrated directly.\n\nArguments\n\nEG::ElementGeometry: The segment geometry over which to integrate.\nkernel!::Function (optional): A function of the form kernel!(result, eval_args, qpinfo) that postprocesses operator evaluations at each quadrature point. If omitted, a default kernel is used.\noa_args::Array{<:Tuple{Any, DataType},1}: Array of tuples (tag, FunctionOperator), where tag identifies the unknown or vector position, and FunctionOperator specifies the operator to evaluate.\n\nKeyword arguments:\n\nfactor: factor that should be multiplied during assembly. Default: 1\nresultdim: dimension of result field (default = length of arguments). Default: 0\nmatrix_mode: integrator integrates basis functions of FEspace separately to assembly a matrix that maps solution to segment integrations (requires that kernel is linear). Default: false\nname: name for operator used in printouts. Default: ''SegmentIntegrator''\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentrytolerance: threshold to add entry to sparse matrix (only in matrixmode). Default: 0\nverbosity: verbosity level. Default: 0\n\nKernel Function Interface\n\nkernel!(result, eval_args, qpinfo)\n\nresult: Preallocated array to store the kernel output.\neval_args: Array of operator evaluations at the current quadrature point.\nqpinfo: QPInfos struct with information about the current quadrature point.\n\nUsage\n\nAfter construction, call initialize! to prepare the integrator for a given solution, then use integrate_segment! to perform integration over a segment.\n\n\n\n\n\n","category":"method"},{"location":"segmentintegrators/#ExtendableFEMBase.initialize!-Union{Tuple{UT}, Tuple{T}, Tuple{SegmentIntegrator{T, UT}, Any}} where {T, UT}","page":"SegmentIntegrator","title":"ExtendableFEMBase.initialize!","text":"function initialize!(\n\tO::SegmentIntegrator{T, UT},\n\tsol;\n\ttime = 0,\n\tkwargs...)\n\nInitializes the SegmentIntegrator for the specified solution.\n\n\n\n\n\n","category":"method"},{"location":"segmentintegrators/#ExtendableFEMBase.integrate_segment!-Union{Tuple{T}, Tuple{Vector{T}, SegmentIntegrator, Array{Vector{T}, 1}, Array{Vector{T}, 1}, Any}} where T","page":"SegmentIntegrator","title":"ExtendableFEMBase.integrate_segment!","text":"function integrate_segment!(\n\tresult::Array{T,1},\n\tSI::SegmentIntegrator,\n\tw::Array{Array{T,1},1},\n\tb::Array{Array{T,1},1},\n\titem\n\t) where {T}\n\nIntegrate a segment with world coordinates w and barycentric coordinates b in the cell with the given item number.\n\n\n\n\n\n","category":"method"},{"location":"plots/#Plots","page":"Plots","title":"Plots","text":"","category":"section"},{"location":"plots/#GridVisualize-and-PlutoVista","page":"Plots","title":"GridVisualize and PlutoVista","text":"","category":"section"},{"location":"plots/","page":"Plots","title":"Plots","text":"Visualization of finite element solutions is possible, for example, via Nodal Evaluations and the plotting routines from ExtendableGrids.jl. For interactive Pluto notebooks, it is recommended to use PlutoVista.jl as the backend for high-quality plots.","category":"page"},{"location":"plots/#UnicodePlots","page":"Plots","title":"UnicodePlots","text":"","category":"section"},{"location":"plots/","page":"Plots","title":"Plots","text":"For quick, in-terminal visualization, several UnicodePlots-based plotters are available via the ExtendableFEMBaseUnicodePlotsExt extension. This extension is loaded automatically when UnicodePlots is available.","category":"page"},{"location":"plots/#ExtendableFEMBase.unicode_gridplot","page":"Plots","title":"ExtendableFEMBase.unicode_gridplot","text":"function unicode_gridplot(\n\txgrid::ExtendableGrid;\n\ttitle = \"gridplot\",\n\tresolution = (40,20),\n\tcolor = (200,200,200),\n\tbface_color = (255,0,0),\n\tCanvasType = BrailleCanvas,\n\tplot_based = ON_CELLS,   # or ON_FACES/ON_EDGES\n\tkwargs...\n\nRender a quick terminal plot of a 2D grid using UnicodePlots, suitable for quick visualization in the terminal.\n\nThis function draws the edges and boundary faces of the given ExtendableGrid using Unicode characters, with customizable resolution, colors, and plotting style. The plot can be based on cells, faces, or edges, and boundary faces are highlighted with a separate color.\n\nArguments\n\nxgrid: The ExtendableGrid to visualize.\n\nKeyword Arguments\n\ntitle: Title of the plot (default: \"gridplot\").\nresolution: Tuple specifying the number of columns and rows (characters) in the plot (default: (40, 20)).\nautoscale: Whether to automatically adjust the aspect ratio for the grid (default: true).\ncolor: RGB tuple for the main grid lines (default: (200, 200, 200)).\nbface_color: RGB tuple for boundary face lines (default: (255, 0, 0)).\nCanvasType: UnicodePlots canvas type to use (default: BrailleCanvas).\nplot_based: Plot based on ON_CELLS, ON_FACES, or ON_EDGES (default: ON_CELLS).\nkwargs...: Additional keyword arguments passed to the canvas or plot.\n\nReturns\n\nA UnicodePlots.Plot object displaying the grid in the terminal.\n\nNotes\n\nRequires the UnicodePlots extension to be loaded.\n\nExample\n\nusing ExtendableFEMBase, ExtendableGrids, UnicodePlots\ngrid = simplexgrid(LinRange(0, 1, 5), LinRange(0, 1, 5))\nunicode_gridplot(grid; title = \"My Grid\", resolution = (60, 30))\n\n\n\n\n\n","category":"function"},{"location":"plots/#ExtendableFEMBase.unicode_scalarplot","page":"Plots","title":"ExtendableFEMBase.unicode_scalarplot","text":"function unicode_scalarplot(\n\tu::FEVectorBlock; \n\tcomponents = 1:get_ncomponents(u),\n\tabs = false,\n\tresolution = (30,30),\n\tcolormap = :viridis,\n\ttitle = u.name,\n\tkwargs...)\n\nRender a quick terminal plot of one or more components of a finite element function using UnicodePlots.\n\nThis function visualizes the nodal values of the FE function stored in u by interpolating onto a coarse uniform mesh and plotting the result using UnicodePlots.jl. In 1D, all selected components are shown in a single line plot; in 2D, each component is shown as a separate heatmap. If abs = true, the Euclidean norm over all components is plotted instead.\n\nArguments\n\nu: The FEVectorBlock containing the finite element function to plot.\n\nKeyword Arguments\n\ncomponents: Indices of the components to plot (default: all components).\nabs: If true, plot the Euclidean norm over all components (default: false).\nnrows: Number of rows in the grid layout for 2D plots (default: 1).\nresolution: Tuple specifying the plot resolution (characters) in each direction (default: (30, 30)).\ncolormap: Colormap symbol for 2D heatmaps (default: :viridis).\ntitle: Title of the plot (default: u.name).\nkwargs...: Additional keyword arguments passed to the plotting routines.\n\nReturns\n\nA UnicodePlots.Plot object (or a vector of plots for multiple components in 2D).\n\nNotes\n\nRequires the UnicodePlots extension to be loaded.\n\n\n\n\n\n","category":"function"},{"location":"functionoperators/#Function-Operators","page":"Function Operators","title":"Function Operators","text":"","category":"section"},{"location":"functionoperators/#StandardFunctionOperators","page":"Function Operators","title":"StandardFunctionOperators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"StandardFunctionOperators are abstract types that represent fundamental (linear) operators, such as the identity, gradient, divergence, and others. These operators provide a unified interface for evaluating finite element basis functions in various ways.","category":"page"},{"location":"functionoperators/#List-of-Primitive-Operators","page":"Function Operators","title":"List of Primitive Operators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"StandardFunctionOperator Description Mathematically\nIdentity identity v rightarrow v\nIdentityComponent{c} identity of c-th component v rightarrow v_c\nNormalFlux normal flux (function times normal) v rightarrow v cdot vecn (only ON_FACES)\nTangentFlux tangent flux (function times tangent) v rightarrow v cdot vect (only ON_EDGES)\nGradient gradient/Jacobian (as a vector) v rightarrow nabla v\nSymmetricGradient symmetric part of the gradient v rightarrow Voigt(mathrmsym(nabla v))\nDivergence divergence v rightarrow mathrmdiv(v) = nabla cdot v\nCurlScalar curl operator 1D to 2D (rotated gradient) v rightarrow -dvdx_2dvdx_1\nCurl2D curl operator 2D to 1D v rightarrow dv_1dx_2 - dv_2dx_1\nCurl3D curl operator 3D to 3D v rightarrow nabla times v\nHessian Hesse matrix = all 2nd order derivatives (as a vector) v rightarrow D^2 v      (e.g. in 2D: xx,xy,yx,yy for each component)\nSymmetricHessian{a} symmetric part of Hesse matrix, offdiagonals scaled by a v rightarrow sym(D^2 v) (e.g. in 2D: xx,yy,a*xy for each component)\nLaplacian Laplace Operator (diagonal of Hessian) v rightarrow Delta v   (e.g. in 2D: xx,yy for each component)","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"note: Note\nThe transformation from the reference domain to the physical domain differs for each finite element class. As a result, the evaluation of each function operator must be implemented specifically for every finite element class. Not all function operators are currently available for every dimension or element type, but new implementations are added as needed or upon request.Additionally, function operators can be combined with user-defined kernels to postprocess/construct more advanced operators from the available primitives (for example, the deviatoric part of a tensor).","category":"page"},{"location":"functionoperators/#ExtendableFEMBase.AbstractFunctionOperator","page":"Function Operators","title":"ExtendableFEMBase.AbstractFunctionOperator","text":"abstract type AbstractFunctionOperator\n\nroot type for FunctionOperators.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Curl2D","page":"Function Operators","title":"ExtendableFEMBase.Curl2D","text":"abstract type Curl2D <: ??\n\nevaluates the curl of some two-dimensional vector field, i.e. Curl2D((u1,u2)) = du2/dx1 - du1/dx2\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Curl3D","page":"Function Operators","title":"ExtendableFEMBase.Curl3D","text":"abstract type Curl3D <: ??\n\nevaluates the curl of some three-dimensional vector field, i.e. Curl3D(u) =  abla \times u\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.CurlScalar","page":"Function Operators","title":"ExtendableFEMBase.CurlScalar","text":"abstract type CurlScalar <: ??\n\nevaluates the curl of some scalar function in 2D, i.e. the rotated gradient.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Deviator","page":"Function Operators","title":"ExtendableFEMBase.Deviator","text":"abstract type Deviator <: ??\n\nevaluates the deviator of a matrix-valued function\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Divergence","page":"Function Operators","title":"ExtendableFEMBase.Divergence","text":"abstract type Divergence <: ??\n\nevaluates the divergence of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Gradient","page":"Function Operators","title":"ExtendableFEMBase.Gradient","text":"abstract type Gradient <: ??\n\nevaluates the gradient of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Hessian","page":"Function Operators","title":"ExtendableFEMBase.Hessian","text":"abstract type Hessian <: ??\n\nevaluates the full Hessian of some (possibly vector-valued) finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Identity","page":"Function Operators","title":"ExtendableFEMBase.Identity","text":"abstract type Identity <: ??\n\nidentity operator: evaluates finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.IdentityComponent","page":"Function Operators","title":"ExtendableFEMBase.IdentityComponent","text":"abstract type IdentityComponent{c} <: ??\n\nidentity operator: evaluates only the c-th component of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Laplacian","page":"Function Operators","title":"ExtendableFEMBase.Laplacian","text":"abstract type Laplacian <: ??\n\nevaluates the Laplacian of some (possibly vector-valued) finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.NormalFlux","page":"Function Operators","title":"ExtendableFEMBase.NormalFlux","text":"abstract type NormalFlux <: ??\n\nevaluates the normal-flux of the finite element function.\n\nonly available on FACES/BFACES and currently only for H1 and Hdiv elements\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.OperatorPair","page":"Function Operators","title":"ExtendableFEMBase.OperatorPair","text":"abstract type OperatorPair{<:StandardFunctionOperator,<:StandardFunctionOperator} <: StandardFunctionOperator\n\nallows to evaluate two operators in place of one, e.g. OperatorPair{Identity,Gradient}.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.OperatorTriple","page":"Function Operators","title":"ExtendableFEMBase.OperatorTriple","text":"abstract type OperatorTriple{<:StandardFunctionOperator,<:StandardFunctionOperator} <: StandardFunctionOperator\n\nallows to evaluate three operators in place of one, e.g. OperatorTriple{Identity,Gradient,Hessian}.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.StandardFunctionOperator","page":"Function Operators","title":"ExtendableFEMBase.StandardFunctionOperator","text":"abstract type StandardFunctionOperator <: ??\n\nroot type for StandardFunctionOperators\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.SymmetricGradient","page":"Function Operators","title":"ExtendableFEMBase.SymmetricGradient","text":"abstract type SymmetricGradient{offdiagval} <: ??\n\nevaluates the symmetric part of the gradient of the finite element function and returns its Voigt compression (off-diagonals on position [j,k] and [k,j] are added together and weighted with offdiagval).\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.SymmetricHessian","page":"Function Operators","title":"ExtendableFEMBase.SymmetricHessian","text":"abstract type SymmetricHessian{offdiagval} <: ??\n\nevaluates only the symmetric part of the Hessian of some (possibly vector-valued) finite element function. A concatenation of Voigt compressed Hessians for each component of the finite element functions is returned. The weighting of the mixed derivatives can be steered with offdiagval (e.g. √2 or 1 depending on the use case).\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.TangentFlux","page":"Function Operators","title":"ExtendableFEMBase.TangentFlux","text":"abstract type TangentFlux <: ??\n\nevaluates the tangent-flux of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.TangentialGradient","page":"Function Operators","title":"ExtendableFEMBase.TangentialGradient","text":"abstract type TangentialGradient <: ??\n\nevaluates the gradient of the tangential part of some vector-valued finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Trace","page":"Function Operators","title":"ExtendableFEMBase.Trace","text":"abstract type Trace <: ??\n\nevaluates the trace of a matrix-valued function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.DefaultName4Operator-Tuple{Type{<:??}}","page":"Function Operators","title":"ExtendableFEMBase.DefaultName4Operator","text":"DefaultName4Operator(_::Type{<:??}) -> String\n\n\ndefault name of the operator for print-outs\n\n\n\n\n\n","category":"method"},{"location":"functionoperators/#ExtendableFEMBase.Length4Operator-Tuple{Type{<:id}, Int64, Int64}","page":"Function Operators","title":"ExtendableFEMBase.Length4Operator","text":"Length4Operator(\n    _::Type{<:id},\n    xdim::Int64,\n    ncomponents::Int64\n) -> Int64\n\n\nnumber of expected components for the operator in xdim dimensions and a function value dimension of ncomponents\n\n\n\n\n\n","category":"method"},{"location":"functionoperators/#ExtendableFEMBase.NeededDerivative4Operator-Tuple{Type{<:id}}","page":"Function Operators","title":"ExtendableFEMBase.NeededDerivative4Operator","text":"NeededDerivative4Operator(_::Type{<:id}) -> Int64\n\n\nnumber of derivatives that are needed to evaluate the operator\n\n\n\n\n\n","category":"method"},{"location":"functionoperators/#ExtendableFEMBase.QuadratureOrderShift4Operator-Tuple{Any}","page":"Function Operators","title":"ExtendableFEMBase.QuadratureOrderShift4Operator","text":"QuadratureOrderShift4Operator(operator) -> Any\n\n\ndefault quadrature order shift for an operator (basically equals minus the number of derivatives)\n\n\n\n\n\n","category":"method"},{"location":"functionoperators/#ReconstructionOperators","page":"Function Operators","title":"ReconstructionOperators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Special operators are provided to evaluate a primitive operator on a reconstructed version of a test function. These are useful for advanced discretizations and post-processing.","category":"page"},{"location":"functionoperators/#ExtendableFEMBase.Reconstruct","page":"Function Operators","title":"ExtendableFEMBase.Reconstruct","text":"abstract type Reconstruct{FETypeR, O} <: ??\n\nreconstruction operator: evaluates a reconstructed version of the finite element function.\n\nFETypeR specifies the reconstruction space (needs to be defined for the finite element that it is applied to). O specifies the StandardFunctionOperator that shall be evaluated.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#Divergence-Free-Reconstruction-Operators","page":"Function Operators","title":"Divergence-Free Reconstruction Operators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"For gradient-robust discretizations of certain classical non-divergence-conforming ansatz spaces, reconstruction operators are available that map a discretely divergence-free H1 function to a pointwise divergence-free H(div) function. Currently, such operators are implemented for the vector-valued Crouzeix-Raviart (H1CR) and Bernardi–Raugel (H1BR) finite element types, as well as for the P2-bubble (H1P2B) element in two dimensions.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Example: Reconst{HDIVRT0{d}, Identity} reconstructs the identity operator into HDIVRT0, and is available for H1BR{d} and H1CR{d} for d = 1, 2.","category":"page"},{"location":"functionoperators/#Operator-Pairs-(Experimental)","page":"Function Operators","title":"Operator Pairs (Experimental)","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Two function operators can be combined into an OperatorPair, allowing you to provide two operators in each argument of an assembly pattern. Both operators must be well-defined on the relevant element geometries and finite element spaces, and their actions must be compatible with the input and result fields. This feature is experimental and may have limitations in some cases. An OperatorTriple is also available for combining three operators.","category":"page"},{"location":"quadrature/#Quadrature","page":"Quadrature","title":"Quadrature","text":"","category":"section"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"A quadrature rule consists of a set of points (coordinates of evaluation points in the reference geometry) and associated weights. Constructors are provided for various AbstractElementGeometries (from ExtendableGrids) and for different orders; some element types support generic formulas for arbitrary order. See below for a detailed list.","category":"page"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"abstract type QuadratureRule{T<:Real, ET<:ExtendableGrids.AbstractElementGeometry}\n\nAbstract type for quadrature rules for a certain NumberType and element geometry\n\n\n\n\n\n","category":"type"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{ET}, Tuple{T}, Tuple{Any, Any}} where {T, ET}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"constructor that puts the provided xref and weights w into a quadrature rule\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.AbstractElementGeometry0D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry0D}\n\nConstructs 0D quadrature rule of specified order (always point evaluation).\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.AbstractElementGeometry1D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry1D}\n\nConstructs 1D quadrature rule of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.Parallelepiped3D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelepiped3D}\n\nConstructs quadrature rule on Parallelepiped3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.Parallelogram2D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelogram2D}\n\nConstructs quadrature rule on Parallelogram2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.Tetrahedron3D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Tetrahedron3D}\n\nConstructs quadrature rule on Tetrahedron3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.Triangle2D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Triangle2D}\n\nConstructs quadrature rule on Triangle2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.SQuadratureRule","page":"Quadrature","title":"ExtendableFEMBase.SQuadratureRule","text":"struct SQuadratureRule{T<:Real, ET<:ExtendableGrids.AbstractElementGeometry, dim, npoints} <: QuadratureRule{T<:Real, ET<:ExtendableGrids.AbstractElementGeometry}\n\nA concrete quadrature rule for a given element geometry and number type.\n\nIt represents a set of quadrature (integration) points and weights for a specific reference element geometry (such as an interval, triangle, quadrilateral, tetrahedron, or hexahedron) and number type.\n\nFields\n\nname::String: A descriptive name for the quadrature rule (e.g., \"midpoint rule\", \"Gauss rule order 3\").\nxref::Vector{Vector{T}}: Reference coordinates of the quadrature points, given as a vector of coordinate vectors (one per point, each of length dim).\nw::Vector{T}: Weights associated with each quadrature point, typically summing to the measure of the reference element.\n\nType Parameters\n\nT <: Real: Number type for coordinates and weights (e.g., Float64, Rational{Int}).\nET <: AbstractElementGeometry: The reference element geometry type (e.g., Edge1D, Triangle2D).\ndim: The topological dimension of the element geometry.\nnpoints: The number of quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"quadrature/#Base.eltype-Union{Tuple{QuadratureRule{T, ET}}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.AbstractElementGeometry}","page":"Quadrature","title":"Base.eltype","text":"eltype(\n    _::QuadratureRule{T<:Real, ET<:ExtendableGrids.AbstractElementGeometry}\n) -> Any\n\n\nCustom eltype function for QuadratureRule{T,ET}.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Base.show-Tuple{IO, QuadratureRule}","page":"Quadrature","title":"Base.show","text":"show(io::IO, Q::QuadratureRule)\n\n\nCustom show function for QuadratureRule{T,ET} that prints some information.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.VertexRule","page":"Quadrature","title":"ExtendableFEMBase.VertexRule","text":"VertexRule(\n    ET::Type{ExtendableGrids.Edge1D};\n    ...\n) -> ExtendableFEMBase.SQuadratureRule{Float64, ExtendableGrids.Edge1D, 1}\nVertexRule(\n    ET::Type{ExtendableGrids.Edge1D},\n    order;\n    T\n) -> ExtendableFEMBase.SQuadratureRule{Float64, ExtendableGrids.Edge1D, 1}\n\n\nConstructs a quadrature rule that evaluates at the vertices of the reference element geometry ET.\n\nThis rule is not optimal for numerical integration, but is especially useful for nodal interpolation, visualization, and extracting nodal values in finite element computations. The order parameter determines the inclusion of higher-order nodes (e.g., edge, face or cell nodes for higher-order Lagrange elements).\n\nArguments\n\nET::Type{<:AbstractElementGeometry}: The reference element geometry (e.g., Edge1D, Triangle2D, Parallelogram2D, Tetrahedron3D, Parallelepiped3D).\norder::Integer: Polynomial order of the finite element (default: 1). Higher orders include additional points corresponding to edge, face, or cell dofs.\nT: Number type for the coordinates and weights (default: Float64).\n\nReturns\n\nA quadrature rule containing the nodal points (xref) and equal weights (w), matching the dof structure of the corresponding Lagrange element.\n\n\n\n\n\n","category":"function"},{"location":"quadrature/#ExtendableFEMBase.integrate!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{T}, Tuple{AbstractArray{T}, ExtendableGrids.ExtendableGrid{Tv, Ti}, Type{<:ExtendableGrids.AssemblyType}, Any}} where {T, Tv, Ti}","page":"Quadrature","title":"ExtendableFEMBase.integrate!","text":"integrate!(\n    integral4items::AbstractArray{T},\n    grid::ExtendableGrids.ExtendableGrid{Tv, Ti},\n    AT::Type{<:ExtendableGrids.AssemblyType},\n    integrand;\n    offset,\n    bonus_quadorder,\n    quadorder,\n    regions,\n    time,\n    items,\n    force_quadrature_rule,\n    kwargs...\n)\n\n\nCompute cellwise (or per-entity) integrals of a user-supplied integrand over entities of type AT in the given grid, writing the result for each entity into integral4items.\n\nArguments\n\nintegral4items::AbstractArray{T}: Preallocated array to store the integral for each entity (e.g., cell, edge, or face). The shape should be compatible with the number of entities and the integrand's output dimension.\ngrid::ExtendableGrid{Tv, Ti}: The grid or mesh over which to integrate.\nAT::Type{<:AssemblyType}: The entity type to integrate over (e.g., ON_CELLS, ON_EDGES, ON_FACES).\nintegrand!: A function with signature integrand!(result, qpinfo) that computes the integrand at a quadrature point. The function should write its output into result (a preallocated vector) and use qpinfo to access quadrature point data.\n\nKeyword Arguments\n\noffset: Offset(s) for writing into integral4items (default: [0]).\nbonus_quadorder: Additional quadrature order to add to quadorder (default: 0).\nquadorder: Quadrature order (default: 0).\nregions: Restrict integration to these region indices (default: [], meaning all regions).\nitems: Restrict integration to these item numbers (default: [], meaning all items).\ntime: Time value to be passed to qpinfo (default: 0).\nforce_quadrature_rule: Use this quadrature rule instead of the default (default: nothing).\nAdditional keyword arguments (kwargs...) are forwarded to the quadrature point info constructor.\n\nNotes\n\nThe function loops over all specified entities (cells, edges, or faces), applies the quadrature rule, and accumulates the result for each entity in integral4items.\nThe integrand function is called at each quadrature point and should write its output in-place to the provided result vector.\nFor total (global) integrals, use integrate instead, which is more memory-efficient.\nThe shape of integral4items determines whether the result is stored as a vector per entity or as a matrix (e.g., for multiple components).\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.integrate-Tuple{ExtendableGrids.ExtendableGrid, Type{<:ExtendableGrids.AssemblyType}, Any, Int64}","page":"Quadrature","title":"ExtendableFEMBase.integrate","text":"integrate(\n    grid::ExtendableGrids.ExtendableGrid,\n    AT::Type{<:ExtendableGrids.AssemblyType},\n    integrand!,\n    resultdim::Int64;\n    T,\n    kwargs...\n) -> Union{Float64, Vector{Float64}}\n\n\nCompute the total integral of a user-supplied integrand over entities of type AT in the given grid.\n\nArguments\n\ngrid::ExtendableGrid: The grid or mesh over which to integrate.\nAT::Type{<:AssemblyType}: The entity type to integrate over (e.g., ON_CELLS, ON_EDGES).\nintegrand!: A function with signature integrand!(result, qpinfo) that computes the integrand at a quadrature point. The function should write its output into result (a preallocated vector) and use qpinfo to access quadrature point data.\nresultdim::Int: The length of the result vector expected from integrand! (i.e., the number of components to integrate).\n\nKeyword Arguments\n\nT: The number type for accumulation (default: Float64).\nquadorder: Quadrature order (default: 0).\nregions: Restrict integration to these region indices (default: [], meaning all regions).\nitems: Restrict integration to these item numbers (default: [], meaning all items).\ntime: Time value to be passed to qpinfo (default: 0).\nparams: Parameter array to be passed to qpinfo (default: []).\nAdditional keyword arguments are forwarded to the quadrature point info constructor.\n\nReturns\n\nIf resultdim == 1, returns a scalar value (the total integral).\nIf resultdim > 1, returns a vector of length resultdim (componentwise integrals).\n\nNotes\n\nThis function is memory-efficient and accumulates the total integral directly, without storing per-entity results. For cellwise or per-entity integration, use integrate! instead.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.ref_integrate!-Tuple{AbstractArray, Type{<:ExtendableGrids.AbstractElementGeometry}, Int64, Function}","page":"Quadrature","title":"ExtendableFEMBase.ref_integrate!","text":"ref_integrate!(\n    integral::AbstractArray,\n    EG::Type{<:ExtendableGrids.AbstractElementGeometry},\n    order::Int64,\n    integrand::Function\n)\n\n\nIntegration for reference basis functions on reference domains (merely for testing stuff).\n\nNote: area of reference geometry is not multiplied\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Accumulating-Vector-(internal,-for-completeness)","page":"Quadrature","title":"Accumulating Vector (internal, for completeness)","text":"","category":"section"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Internally, global integration uses an accumulating vector and calls cell-wise integration routines.","category":"page"},{"location":"quadrature/#ExtendableFEMBase.AccumulatingVector","page":"Quadrature","title":"ExtendableFEMBase.AccumulatingVector","text":"struct AccumulatingVector{T} <: AbstractArray{T, 2}\n\nvector that is acting as an AbstractArray{T, 2} and  automatically accumulates all values from the second dimension\n\nAV[k,j] += s for any j results in AV.entries[k] += s\n\n\n\n\n\n","category":"type"},{"location":"fespace/#FESpace","page":"FESpace","title":"FESpace","text":"","category":"section"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"A finite element space (FESpace) represents the set of all functions that can be expressed using a particular finite element type on a given computational grid. In ExtendableFEMBase, constructing a finite element space requires only specifying the finite element type and the grid; all necessary degree-of-freedom (dof) mappings are generated automatically on first access. ","category":"page"},{"location":"fespace/#ExtendableFEMBase.AbstractFiniteElement","page":"FESpace","title":"ExtendableFEMBase.AbstractFiniteElement","text":"abstract type AbstractFiniteElement\n\nroot type for finite element types\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.AbstractH1FiniteElement","page":"FESpace","title":"ExtendableFEMBase.AbstractH1FiniteElement","text":"abstract type AbstractH1FiniteElement <: AbstractFiniteElement\n\nroot type for H1-conforming finite element types\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.AbstractH1FiniteElementWithCoefficients","page":"FESpace","title":"ExtendableFEMBase.AbstractH1FiniteElementWithCoefficients","text":"abstract type AbstractH1FiniteElementWithCoefficients <: AbstractH1FiniteElement\n\nroot type for H1-conforming finite element types with additional coefficients\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.AbstractHcurlFiniteElement","page":"FESpace","title":"ExtendableFEMBase.AbstractHcurlFiniteElement","text":"abstract type AbstractHcurlFiniteElement <: AbstractFiniteElement\n\nroot type for Hcurl-conforming finite element types with additional coefficients\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.AbstractHdivFiniteElement","page":"FESpace","title":"ExtendableFEMBase.AbstractHdivFiniteElement","text":"abstract type AbstractHdivFiniteElement <: AbstractFiniteElement\n\nroot type for Hdiv-conforming finite element types\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.FESpace","page":"FESpace","title":"ExtendableFEMBase.FESpace","text":"struct FESpace{Tv, Ti, FEType<:AbstractFiniteElement,AT<:AssemblyType}\n\tname::String                          \n\tbroken::Bool                         \n\tndofs::Int                            \n\tcoffset::Int                          \n\txgrid::ExtendableGrid[Tv,Ti}           \n\tdofgrid::ExtendableGrid{Tv,Ti}\t      \n\tdofmaps::Dict{Type{<:AbstractGridComponent},Any} \n    interpolators::Dict{Type{<:AssemblyType}, Any} \nend\n\nA finite element space representing the global collection of degrees of freedom (DOFs) for a given finite element type and assembly type on a computational grid.\n\nFESpace encapsulates the mapping between mesh entities (cells, faces, edges, etc.) and DOFs, as well as metadata and auxiliary structures needed for assembly, interpolation, and evaluation of finite element functions.\n\nType Parameters\n\nTv: Value type for grid coordinates (e.g., Float64).\nTi: Integer type for grid indices (e.g., Int64).\nFEType: The finite element type (e.g., H1P1).\nAT: The assembly type (e.g., ON_CELLS).\n\nFields\n\nname::String: Name of the finite element space.\nbroken::Bool: Whether the space is \"broken\" (discontinuous across elements).\nndofs::Int64: Total number of global degrees of freedom.\ncoffset::Int: Offset for component DOFs (for vector-valued or mixed spaces).\nxgrid::ExtendableGrid{Tv, Ti}: Reference to the computational grid.\ndofgrid::ExtendableGrid{Tv, Ti}: Grid used for DOF numbering (may be a subgrid of xgrid).\ndofmaps::Dict{Type{<:AbstractGridComponent}, Any}: Dictionary of DOF maps for different grid components (cells, faces, edges, etc.).\ninterpolators::Dict{Type{<:AssemblyType}, Any}: Dictionary of interpolation operators for different assembly types.\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.FESpace-Union{Tuple{ExtendableGrids.ExtendableGrid{Tv, Ti}}, Tuple{AT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, AT<:ExtendableGrids.AssemblyType}","page":"FESpace","title":"ExtendableFEMBase.FESpace","text":"FESpace{FEType, AT}(xgrid::ExtendableGrid{Tv, Ti}; name = \"\", regions = nothing, broken::Bool = false)\n\nConstructs a finite element space (FESpace) of the given finite element type (FEType) and assembly type (AT) on the provided computational grid.\n\nThe FESpace represents the global collection of degrees of freedom (DOFs) for the specified finite element type and assembly type, and manages the mapping between mesh entities (cells, faces, edges, etc.) and DOFs.\nThe broken switch allows the creation of a \"broken\" (discontinuous) finite element space, where basis functions are not required to be continuous across element boundaries.\nThe regions argument can be used to restrict the space to a subset of the grid.\nIf no AT is provided, the space is generated on cells (ON_CELLS).\n\nArguments\n\nxgrid::ExtendableGrid{Tv, Ti}: The computational grid on which the finite element space is defined.\n\nKeyword Arguments\n\n`name::String: Name for the finite element space (for identification and debugging) (default: \"\", triggers automatic generation from FEType and broken).\nregions: Optional subset of the grid to restrict the space (default: all regions).\nbroken: Whether to create a broken (discontinuous) space (default: false).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.eltype-Union{Tuple{FESpace{Tv, Ti, FEType, APT}}, Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"Base.eltype","text":"eltype(\n    _::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT}\n) -> Type{FEType} where FEType<:AbstractFiniteElement\n\n\nCustom eltype function for FESpace returns the finite element type parameter of the finite element space.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.get!-Tuple{FESpace, Type{<:DofMap}}","page":"FESpace","title":"Base.get!","text":"get!(FES::FESpace, DM::Type{<:DofMap}) -> Any\n\n\nTo be called by getindex. This triggers lazy creation of  non-existing dofmaps\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.getindex-Tuple{FESpace, Type{<:DofMap}}","page":"FESpace","title":"Base.getindex","text":"Base.getindex(FES::FESpace,DM::Type{<:DofMap})\n\nGeneric method for obtaining dofmap. This method is mutating in the sense that non-existing dofmaps are created on demand. Due to the fact that components are stored as Any the return value triggers type instability.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.setindex!-Tuple{FESpace, Any, Type{<:DofMap}}","page":"FESpace","title":"Base.setindex!","text":"setindex!(FES::FESpace, v, DM::Type{<:DofMap}) -> Any\n\n\nSet new dofmap\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{IO, FESpace{Tv, Ti, FEType, APT}}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"Base.show","text":"show(\n    io::IO,\n    FES::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT}\n)\n\n\nCustom show function for FESpace that prints some information and all available dofmaps.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.assemblytype-Union{Tuple{FESpace{Tv, Ti, FEType, APT}}, Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"ExtendableFEMBase.assemblytype","text":"assemblytype(\n    _::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT}\n) -> Any\n\n\nreturns the assembly type parameter of the finite element space, i.e. on which entities of the grid the finite element is defined.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.broken-Tuple{FESpace}","page":"FESpace","title":"ExtendableFEMBase.broken","text":"broken(FES::FESpace) -> Bool\n\n\nreturns true if the finite element space is broken, false if not\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.coffset-Tuple{FESpace}","page":"FESpace","title":"ExtendableFEMBase.coffset","text":"coffset(FES::FESpace) -> Int64\n\n\nreturns the offset between the degrees of freedom of each component (i.e. the number of scalar degrees of freedom that influence a component, vector-valued degrees of freedom are stored at the end).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.count_ndofs-Tuple{Any, Any, Bool}","page":"FESpace","title":"ExtendableFEMBase.count_ndofs","text":"count_ndofs(\n    xgrid,\n    FEType,\n    broken::Bool\n) -> Tuple{Int64, Int64}\n\n\ncounts the total number of degrees of freedom for the FEType for the whole grid\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.dofgrid-Tuple{FESpace}","page":"FESpace","title":"ExtendableFEMBase.dofgrid","text":"dofgrid(FES::FESpace) -> ExtendableGrids.ExtendableGrid\n\n\nreturns the dofgrid of the finite element space.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_AT-Union{Tuple{FESpace{Tv, Ti, FEType, AT}}, Tuple{AT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType, AT}","page":"FESpace","title":"ExtendableFEMBase.get_AT","text":"get_AT(_::FESpace{Tv, Ti, FEType, AT}) -> Any\n\n\nreturns the support of the finite element space\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_FEType-Union{Tuple{FESpace{Tv, Ti, FEType, AT}}, Tuple{AT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType, AT}","page":"FESpace","title":"ExtendableFEMBase.get_FEType","text":"get_FEType(_::FESpace{Tv, Ti, FEType, AT}) -> Any\n\n\nreturns the finite element type of the finite element space\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_basis-Tuple{Type{<:ExtendableGrids.AssemblyType}, Type{<:AbstractFiniteElement}, Type{<:ExtendableGrids.AbstractElementGeometry}}","page":"FESpace","title":"ExtendableFEMBase.get_basis","text":"get_basis(\n    AT::Type{<:ExtendableGrids.AssemblyType},\n    FEType::Type{<:AbstractFiniteElement},\n    EG::Type{<:ExtendableGrids.AbstractElementGeometry}\n) -> ExtendableFEMBase.var\"#closure#249\"{_A, Int64, ExtendableFEMBase.var\"#closure#232\"{1}} where _A\n\n\nreturns the closure function of form\n\nclosure(refbasis, xref)\n\nthat computes the evaluations of the basis functions on the reference geometry\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_basissubset-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{Type{<:ExtendableGrids.AssemblyType}, FESpace{Tv, Ti, FEType, APT}, Type{<:ExtendableGrids.AbstractElementGeometry}}, Tuple{Type{<:ExtendableGrids.AssemblyType}, FESpace{Tv, Ti, FEType, APT}, Type{<:ExtendableGrids.AbstractElementGeometry}, Any}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"ExtendableFEMBase.get_basissubset","text":"get_basissubset(\n    ::Type{<:ExtendableGrids.AssemblyType},\n    FE::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT},\n    ::Type{<:ExtendableGrids.AbstractElementGeometry}\n) -> ExtendableFEMBase.var\"#closure#260\"{_A, Int64} where _A\nget_basissubset(\n    ::Type{<:ExtendableGrids.AssemblyType},\n    FE::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT},\n    ::Type{<:ExtendableGrids.AbstractElementGeometry},\n    xgrid\n) -> Union{ExtendableFEMBase.var\"#21#22\", ExtendableFEMBase.var\"#closure#270\"{_A, _B, _C, Int64, Int64} where {_A, _B, _C}}\n\n\nreturns a closure function of the form\n\nclosure(subset_ids::Array{Int, 1}, cell)\n\nwhich returns the ids of the local basis functions needed on the cell. Usually, subset_ids = 1:ndofs (meaning that all basis functions on the reference cells are used),\n\nSee e.g. the 3D implementation of BDM1 or H1P3 where different basis functions are chosen depending on the face orientations (which in 3D is not just a sign)\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_coefficients-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{Type{<:ExtendableGrids.AssemblyType}, FESpace{Tv, Ti, FEType, APT}, Type{<:ExtendableGrids.AbstractElementGeometry}}, Tuple{Type{<:ExtendableGrids.AssemblyType}, FESpace{Tv, Ti, FEType, APT}, Type{<:ExtendableGrids.AbstractElementGeometry}, Any}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"ExtendableFEMBase.get_coefficients","text":"get_coefficients(\n    ::Type{<:ExtendableGrids.AssemblyType},\n    FE::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT},\n    ::Type{<:ExtendableGrids.AbstractElementGeometry}\n) -> ExtendableFEMBase.var\"#closure#221\"\nget_coefficients(\n    ::Type{<:ExtendableGrids.AssemblyType},\n    FE::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT},\n    ::Type{<:ExtendableGrids.AbstractElementGeometry},\n    xgrid\n) -> ExtendableFEMBase.var\"#closure#225\"\n\n\nreturns the coefficients for local evaluations of finite element functions ( see e.g. h1v_br.jl for a use-case)\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_edim-Tuple{Type{<:AbstractFiniteElement}}","page":"FESpace","title":"ExtendableFEMBase.get_edim","text":"get_edim(FEType::Type{<:AbstractFiniteElement}) -> Any\n\n\nreturns the element dimension of the finite element\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_ncomponents-Tuple{FESpace}","page":"FESpace","title":"ExtendableFEMBase.get_ncomponents","text":"get_ncomponents(FES::FESpace) -> Any\n\n\nreturns the number of components of the FESpace (= number of components of its FEType)\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_ndofs-Tuple{Type{<:ExtendableGrids.AssemblyType}, Type{<:AbstractFiniteElement}, Type{<:ExtendableGrids.AbstractElementGeometry}}","page":"FESpace","title":"ExtendableFEMBase.get_ndofs","text":"get_ndofs(\n    AT::Type{<:ExtendableGrids.AssemblyType},\n    FEType::Type{<:AbstractFiniteElement},\n    EG::Type{<:ExtendableGrids.AbstractElementGeometry}\n) -> Any\n\n\nreturns the number of degrees of freedom for the given AssemblyType, FEType and geometry\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_ndofs_all-Tuple{Type{<:ExtendableGrids.AssemblyType}, Type{<:AbstractFiniteElement}, Type{<:ExtendableGrids.AbstractElementGeometry}}","page":"FESpace","title":"ExtendableFEMBase.get_ndofs_all","text":"get_ndofs_all(\n    AT::Type{<:ExtendableGrids.AssemblyType},\n    FEType::Type{<:AbstractFiniteElement},\n    EG::Type{<:ExtendableGrids.AbstractElementGeometry}\n) -> Int64\n\n\nreturns the total number of degrees of freedom for the given AssemblyType, FEType and geometry\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_polynomialorder-Tuple{Type{<:ExtendableGrids.AssemblyType}, Type{<:AbstractFiniteElement}, Type{<:ExtendableGrids.AbstractElementGeometry}}","page":"FESpace","title":"ExtendableFEMBase.get_polynomialorder","text":"get_polynomialorder(\n    AT::Type{<:ExtendableGrids.AssemblyType},\n    FE::Type{<:AbstractFiniteElement},\n    EG::Type{<:ExtendableGrids.AbstractElementGeometry}\n) -> Int64\n\n\nreturns the expected polynomial order of the basis functions (used to determine default quadrature orders)\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.interior_dofs_offset-Tuple{Type{<:ExtendableGrids.AssemblyType}, Type{<:AbstractFiniteElement}, Type{<:ExtendableGrids.AbstractElementGeometry}}","page":"FESpace","title":"ExtendableFEMBase.interior_dofs_offset","text":"interior_dofs_offset(\n    AT::Type{<:ExtendableGrids.AssemblyType},\n    FE::Type{<:AbstractFiniteElement},\n    EG::Type{<:ExtendableGrids.AbstractElementGeometry}\n) -> Int64\n\n\nreturns the offset for the interior degrees of freedom (all vertex, face and edge dofs are assumed to come first and before that number)\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.isdefined-Tuple{Type{<:AbstractFiniteElement}, Type{<:ExtendableGrids.AbstractElementGeometry}}","page":"FESpace","title":"ExtendableFEMBase.isdefined","text":"isdefined(\n    FEType::Type{<:AbstractFiniteElement},\n    EG::Type{<:ExtendableGrids.AbstractElementGeometry}\n) -> Bool\n\n\ntells if FEType is defined on this ElementGeometry\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.name-Tuple{FESpace}","page":"FESpace","title":"ExtendableFEMBase.name","text":"name(FES::FESpace) -> String\n\n\nreturns the name of the finite element space.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.ndofs-Tuple{FESpace}","page":"FESpace","title":"ExtendableFEMBase.ndofs","text":"ndofs(FES::FESpace) -> Int64\n\n\nreturns the total number of degrees of freedom of the finite element space.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.xgrid-Tuple{FESpace}","page":"FESpace","title":"ExtendableFEMBase.xgrid","text":"xgrid(FES::FESpace) -> ExtendableGrids.ExtendableGrid\n\n\nreturns the computational grid of the finite element space.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#DofMaps","page":"FESpace","title":"DofMaps","text":"","category":"section"},{"location":"fespace/#ExtendableFEMBase.BEdgeDofs","page":"FESpace","title":"ExtendableFEMBase.BEdgeDofs","text":"abstract type BEdgeDofs <: DofMap\n\nKey type describing the dofs for each boundary edge of the dofgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.BEdgeDofsParent","page":"FESpace","title":"ExtendableFEMBase.BEdgeDofsParent","text":"abstract type BEdgeDofsParent <: DofMap\n\nKey type describing the dofs for each boundary edge of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.BFaceDofs","page":"FESpace","title":"ExtendableFEMBase.BFaceDofs","text":"abstract type BFaceDofs <: DofMap\n\nKey type describing the dofs for each boundary face of the dofgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.BFaceDofsParent","page":"FESpace","title":"ExtendableFEMBase.BFaceDofsParent","text":"abstract type BFaceDofsParent <: DofMap\n\nKey type describing the dofs for each boundary face of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.CellDofs","page":"FESpace","title":"ExtendableFEMBase.CellDofs","text":"abstract type CellDofs <: DofMap\n\nKey type describing the dofs for each cell of the dofgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.CellDofsParent","page":"FESpace","title":"ExtendableFEMBase.CellDofsParent","text":"abstract type CellDofsParent <: DofMap\n\nKey type describing the dofs for each cell of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.DofMap","page":"FESpace","title":"ExtendableFEMBase.DofMap","text":"abstract type DofMap <: ExtendableGrids.AbstractGridAdjacency\n\nA DofMap encodes the association of global DoF indices to mesh entities of a given type (e.g., cells, faces, edges) for a particular finite element space. This mapping is essential for assembling system matrices and vectors, applying boundary conditions, and extracting solution values. DofMaps are typically not constructed directly by users. Instead, they are generated/managed internally by the finite element space and accessed as needed for assembly or evaluation tasks.\n\nImplementation\n\nAll concrete DofMap subtypes (e.g., CellDofs, FaceDofs, EdgeDofs, etc.) specify the mesh entity type to which DoFs are attached.\nDofMaps are stored as ExtendableGrids.AbstractGridAdjacency (usually VariableTargetAdjacency, SerialVariableTargetAdjacency or AbstractGridIntegerArray2D) objects within the finite element space and are generated automatically as needed.\nThe appropriate DofMap for a given assembly type can be accessed via FESpace[DofMapSubtype].\n\nExample\n\ncell_dofs = FESpace[CellDofs]   # Get the cell-based DoF map\nface_dofs = FESpace[FaceDofs]   # Get the face-based DoF map\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.DofMapPatternSegment","page":"FESpace","title":"ExtendableFEMBase.DofMapPatternSegment","text":"struct DofMapPatternSegment\n\nPattern segment of a dofmap sequence\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.DofType","page":"FESpace","title":"ExtendableFEMBase.DofType","text":"abstract type DofType\n\nAbstract type for all dof types\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.DofType-Tuple{Char}","page":"FESpace","title":"ExtendableFEMBase.DofType","text":"DofType(c::Char) -> Union{Nothing, Type}\n\n\nparses a Char into a DofType\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.DofTypeEdge","page":"FESpace","title":"ExtendableFEMBase.DofTypeEdge","text":"abstract type DofTypeEdge <: ExtendableFEMBase.DofType\n\nDof connected to an edge\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.DofTypeFace","page":"FESpace","title":"ExtendableFEMBase.DofTypeFace","text":"abstract type DofTypeFace <: ExtendableFEMBase.DofType\n\nDof connected to a face\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.DofTypeInterior","page":"FESpace","title":"ExtendableFEMBase.DofTypeInterior","text":"abstract type DofTypeInterior <: ExtendableFEMBase.DofType\n\nDof connected to the interior of an item\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.DofTypeNode","page":"FESpace","title":"ExtendableFEMBase.DofTypeNode","text":"abstract type DofTypeNode <: ExtendableFEMBase.DofType\n\nDof connected to a single vertex\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.DofTypePCell","page":"FESpace","title":"ExtendableFEMBase.DofTypePCell","text":"abstract type DofTypePCell <: ExtendableFEMBase.DofType\n\nDof connected to a parent cell\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.EdgeDofs","page":"FESpace","title":"ExtendableFEMBase.EdgeDofs","text":"abstract type EdgeDofs <: DofMap\n\nKey type describing the dofs for each edge of the dofgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.EdgeDofsParent","page":"FESpace","title":"ExtendableFEMBase.EdgeDofsParent","text":"abstract type EdgeDofsParent <: DofMap\n\nKey type describing the dofs for each edge of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.FaceDofs","page":"FESpace","title":"ExtendableFEMBase.FaceDofs","text":"abstract type FaceDofs <: DofMap\n\nKey type describing the dofs for each face of the dofgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.FaceDofsParent","page":"FESpace","title":"ExtendableFEMBase.FaceDofsParent","text":"abstract type FaceDofsParent <: DofMap\n\nKey type describing the dofs for each face of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.ParsedDofMap","page":"FESpace","title":"ExtendableFEMBase.ParsedDofMap","text":"struct ParsedDofMap\n\nParsed dofmap, basically a sequence of DofMapPatternSegment\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.ParsedDofMap-Tuple{String, Any, Type{<:ExtendableGrids.AbstractElementGeometry}}","page":"FESpace","title":"ExtendableFEMBase.ParsedDofMap","text":"ParsedDofMap(\n    pattern::String,\n    ncomponents,\n    EG::Type{<:ExtendableGrids.AbstractElementGeometry}\n) -> ExtendableFEMBase.ParsedDofMap\n\n\nparses a dofmap string (defined in each finite element definition file) and generated a ParsedDofMap for a certain number of components and the given geometry\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.Dofmap4AssemblyType-Tuple{FESpace, Type{<:ExtendableGrids.AssemblyType}}","page":"FESpace","title":"ExtendableFEMBase.Dofmap4AssemblyType","text":"Dofmap4AssemblyType(\n    FES::FESpace,\n    AT::Type{<:ExtendableGrids.AssemblyType}\n) -> Any\n\n\nyields the coressponding dofmap of the FESpace for a given AssemblyType (assumed with respect to the (parent)grid of the FESpace)\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.Dofmap4AssemblyType-Tuple{Type{ON_CELLS}}","page":"FESpace","title":"ExtendableFEMBase.Dofmap4AssemblyType","text":"Dofmap4AssemblyType(_::Type{ON_CELLS}) -> Type{CellDofs}\n\n\nDefault Dofmap for AssemblyType\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.EffAT4AssemblyType-Tuple{Type{ON_CELLS}, Type{ON_CELLS}}","page":"FESpace","title":"ExtendableFEMBase.EffAT4AssemblyType","text":"EffAT4AssemblyType(\n    _::Type{ON_CELLS},\n    _::Type{ON_CELLS}\n) -> Type{ON_CELLS}\n\n\nEffective AssemblyType (on the subgrid) for two AssemblyTypes where the first one is related to where the finite element functions live and the second one to where something should be assembled both with respect to the common parent grid (e.g. face-based finite elements live on a subgrid of all faces, where the faces are the cells in this subgrid, and they cannot be evaluated over the cells of the parentgrid, but on the faces of the parengrid, which are the cells in the subgrid)\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.ItemEdges4DofMap-Tuple{Type{CellDofs}}","page":"FESpace","title":"ExtendableFEMBase.ItemEdges4DofMap","text":"ItemEdges4DofMap(\n    _::Type{CellDofs}\n) -> Type{ExtendableGrids.CellEdges}\n\n\nItemEdges grid component for dofmaps\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.ItemGeometries4DofMap-Tuple{Type{CellDofs}}","page":"FESpace","title":"ExtendableFEMBase.ItemGeometries4DofMap","text":"ItemGeometries4DofMap(\n    _::Type{CellDofs}\n) -> Type{ExtendableGrids.CellGeometries}\n\n\nItemGeomtries grid component for dofmaps\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.ParentDofmap4Dofmap-Tuple{Type{CellDofs}}","page":"FESpace","title":"ExtendableFEMBase.ParentDofmap4Dofmap","text":"ParentDofmap4Dofmap(\n    _::Type{CellDofs}\n) -> Type{CellDofsParent}\n\n\nParent Dofmap for Dofmap\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.Sub2Sup4DofMap-Tuple{Type{<:DofMap}}","page":"FESpace","title":"ExtendableFEMBase.Sub2Sup4DofMap","text":"Sub2Sup4DofMap(\n    _::Type{<:DofMap}\n) -> Type{ExtendableGrids.BEdgeEdges}\n\n\nSubItemEdges grid component for dofmaps\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.SuperItemNodes4DofMap-Tuple{Type{CellDofs}}","page":"FESpace","title":"ExtendableFEMBase.SuperItemNodes4DofMap","text":"SuperItemNodes4DofMap(\n    _::Type{CellDofs}\n) -> Type{ExtendableGrids.CellNodes}\n\n\nItemNodes grid component for dofmaps\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.UCG4DofMap-Tuple{Type{CellDofs}}","page":"FESpace","title":"ExtendableFEMBase.UCG4DofMap","text":"UCG4DofMap(\n    _::Type{CellDofs}\n) -> Type{ExtendableGrids.UniqueCellGeometries}\n\n\nUnique geometry grid component for dofmaps\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.boundarydofs-Tuple{Any}","page":"FESpace","title":"ExtendableFEMBase.boundarydofs","text":"boundarydofs(FES; dofmap, regions) -> Any\n\n\nreturns an array with the number of all dofs associated to a boundary dofmap (default: BFaceDofs) and certain boundary regions (default: all regions)\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_ndofs-Tuple{ExtendableFEMBase.ParsedDofMap, Type{ExtendableFEMBase.DofTypeNode}}","page":"FESpace","title":"ExtendableFEMBase.get_ndofs","text":"get_ndofs(\n    P::ExtendableFEMBase.ParsedDofMap,\n    _::Type{ExtendableFEMBase.DofTypeNode}\n) -> Int64\n\n\ntotal number of dofs of the DofType\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_ndofs4c-Tuple{ExtendableFEMBase.ParsedDofMap, Type{ExtendableFEMBase.DofTypeNode}}","page":"FESpace","title":"ExtendableFEMBase.get_ndofs4c","text":"get_ndofs4c(\n    P::ExtendableFEMBase.ParsedDofMap,\n    _::Type{ExtendableFEMBase.DofTypeNode}\n) -> Int64\n\n\ntotal number of dofs of the DofType for a single component\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.init_broken_dofmap!-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{FESpace{Tv, Ti, FEType, APT}, Union{Type{BFaceDofs}, Type{FaceDofs}}}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"ExtendableFEMBase.init_broken_dofmap!","text":"init_broken_dofmap!(\n    FES::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT},\n    DM::Union{Type{BFaceDofs}, Type{FaceDofs}}\n) -> ExtendableGrids.VariableTargetAdjacency\n\n\ngenerates the BFaceDofs or FaceDofs DofMap for a broken FESpace based on the pattern of the FEType \n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.init_dofmap!-Tuple{FESpace, Type{<:DofMap}}","page":"FESpace","title":"ExtendableFEMBase.init_dofmap!","text":"init_dofmap!(FES::FESpace, DM::Type{<:DofMap}) -> Any\n\n\ngenerates the requested DofMap for the FESpace\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.init_dofmap_from_pattern!-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{FESpace{Tv, Ti, FEType, APT}, Type{<:DofMap}}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"ExtendableFEMBase.init_dofmap_from_pattern!","text":"init_dofmap_from_pattern!(\n    FES::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT},\n    DM::Type{<:DofMap}\n) -> Any\n\n\ngenerates the DofMap for the FESpace based on the pattern of the FEType \n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.parse_pattern-Tuple{String}","page":"FESpace","title":"ExtendableFEMBase.parse_pattern","text":"parse_pattern(\n    pattern::String\n) -> Vector{ExtendableFEMBase.DofMapPatternSegment}\n\n\nsplits a pattern string into pairs of single chars and Ints and generated a sequence of DofMapPatternSegments\n\n\n\n\n\n","category":"method"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"The following DofMap subtypes are available and are used as keys to access the dofmap via FESpace[DofMap] (which is equivalent to FESpace.dofmaps[DofMap]).","category":"page"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"DofMap Explanation\nCellDofs degrees of freedom for on each cell\nFaceDofs degrees of freedom for each face\nEdgeDofs degrees of freedom for each edge (in 3D)\nBFaceDofs degrees of freedom for each boundary face\nBEdgeDofs degrees of freedom for each boundary edge (in 3D)","category":"page"},{"location":"feevaluator/#FEEvaluator","page":"FEEvaluator","title":"FEEvaluator","text":"","category":"section"},{"location":"feevaluator/","page":"FEEvaluator","title":"FEEvaluator","text":"The FEEvaluator provides a unified interface for evaluating finite element basis functions, their derivatives, and related quantities for a given function operator, quadrature rule, and mesh entity. It manages the storage and reuse of basis evaluations both on the reference element (where derivatives are computed via automatic differentiation) and on the current mesh item. The mesh item context can be updated dynamically using the update! function.","category":"page"},{"location":"feevaluator/#ExtendableFEMBase.FEEvaluator-Union{Tuple{FEAPT}, Tuple{EG}, Tuple{FEType}, Tuple{TvR}, Tuple{TiG}, Tuple{TvG}, Tuple{FESpace{TvG, TiG, FEType, FEAPT}, Type{<:??}, QuadratureRule{TvR, EG}}, Tuple{FESpace{TvG, TiG, FEType, FEAPT}, Type{<:??}, QuadratureRule{TvR, EG}, Any}} where {TvG, TiG, TvR, FEType<:AbstractFiniteElement, EG<:ExtendableGrids.AbstractElementGeometry, FEAPT<:ExtendableGrids.AssemblyType}","page":"FEEvaluator","title":"ExtendableFEMBase.FEEvaluator","text":"function FEEvaluator(FE::FESpace, operator::AbstractFunctionOperator, qrule::QuadratureRule; T = Float64, AT = ON_CELLS, L2G = nothing)\n\nConstruct a finite element basis function evaluator for a given finite element space, operator, and quadrature rule.\n\nArguments\n\nFE::FESpace: The finite element space whose basis functions are to be evaluated.\noperator::AbstractFunctionOperator: The operator to apply to the basis functions (e.g., Identity, Gradient, etc.).\nqrule::QuadratureRule: The quadrature rule specifying the evaluation points (quadrature points) on the reference element.\nxgrid: (optional, defaults to FE.dofgrid) The grid on which the FE space is defined. Used for geometric information.\nL2G: (optional) A local-to-global transformation object. If not provided, it is constructed automatically.\nT: (optional, default Float64) The floating-point type for computations.\nAT: (optional, default ON_CELLS) The assembly type, specifying the geometric entity (cells, faces, etc.) for evaluation.\n\nReturns\n\nA FEEvaluator object that can efficiently evaluate (and cache) the values of the specified operator applied to the FE basis functions at the quadrature points of each cell (or other entity). The evaluator supports fast updates to new cells via update_basis!.\n\nUsage\n\nAfter construction, call update_basis!(FEB, cellid) to update the evaluator to a new cell.\nAccess the evaluated values via FEB.cvals[component, dof, qp], where:\ncomponent: the output component (e.g., vector or matrix entry)\ndof: the local basis function index\nqp: the quadrature point index\n\nNotes\n\nFor matrix-valued operators (e.g., Gradient), the result is stored as a long vector in component-wise order.\n\nExample\n\nFEB = FEEvaluator(FE, Gradient, qrule)\nfor cell in 1:ncells\n    update_basis!(FEB, cell)\n    # Access FEB.cvals for basis gradients at quadrature points\nend\n\n\n\n\n\n","category":"method"},{"location":"feevaluator/#ExtendableFEMBase.eval_febe!","page":"FEEvaluator","title":"ExtendableFEMBase.eval_febe!","text":"\teval_febe!(result, FEBE::FEBasisEvaluator, j::Int, i::Int, offset::Int = 0, factor = 1)\n\nEvaluates the linear combination of the basisfunction with given coefficients at the i-th quadrature point and writes the (possibly vector-valued) evaluation into result (beginning at offset and with the specified factor).\n\n\n\n\n\n","category":"function"},{"location":"feevaluator/#ExtendableFEMBase.eval_febe!-2","page":"FEEvaluator","title":"ExtendableFEMBase.eval_febe!","text":"\teval_febe!(result, FEBE::FEBasisEvaluator, j::Int, i::Int, offset::Int = 0, factor = 1)\n\nEvaluate the j-th basis function of the FEBasisEvaluator at the i-th quadrature point and writes the (possibly vector-valued) evaluation into result (beginning at offset and with the specified factor).\n\n\n\n\n\n","category":"function"},{"location":"feevaluator/#ExtendableFEMBase.update_basis!-Tuple{FEEvaluator, Any}","page":"FEEvaluator","title":"ExtendableFEMBase.update_basis!","text":"function update_basis!(FEBE::FEEvaluator, item::Integer)\n\nSets FEBE.citem[] = item and updates the basis.\n\n\n\n\n\n","category":"method"},{"location":"feevaluator/#ExtendableFEMBase.update_basis!-Union{Tuple{ExtendableFEMBase.SingleFEEvaluator{<:Real, <:Real, <:Integer, operator, FEType}}, Tuple{FEType}, Tuple{operator}} where {operator, FEType}","page":"FEEvaluator","title":"ExtendableFEMBase.update_basis!","text":"function update_basis!(FEBE::SingleFEEvaluator)\n\nUpdates the basis for the current item FEBE.citem[].\n\n\n\n\n\n","category":"method"},{"location":"plutostatichtml_examples/LowLevelPoisson/","page":"Low level Poisson","title":"Low level Poisson","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"94ce8bde3a99bdac13d0be8499a12c2c7703b86eae5c3a6f4d49d727d1e2809f\"\n    julia_version = \"1.11.5\"\n-->\n<pre class='language-julia'><code class='language-julia'>begin\n    using ExtendableFEMBase\n    using ExtendableGrids\n    using ExtendableSparse\n    using GridVisualize\n    using PlutoVista\n    GridVisualize.default_plotter!(PlutoVista)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-PlutoVista\">PlutoVista</pre>\n\n\n<div class=\"markdown\"><h1 id=\"Tutorial-notebook:-Poisson-problem\">Tutorial notebook: Poisson problem</h1><p>This notebook demonstrates how to implement the Poisson problem with the low level structures provided by ExtendableFEMBase. The Poisson problem with homogeneous Dirichlet boundary data seeks <span class=\"tex\">\\(u\\)</span> such that</p><p class=\"tex\">$$\\begin{aligned}\n\t- \\mu \\Delta u = f.\n\\end{aligned}$$</p><p>The weak formulation seeks <span class=\"tex\">\\(u \\in V := H^1_0(\\Omega)\\)</span> such that</p><p class=\"tex\">$$\\begin{aligned}\n\t\\mu (\\nabla u, \\nabla v) = (f, v)\n\t\\quad \\text{for all } v \\in V\n\\end{aligned}$$</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    ## PDE data\n    μ = 1.0\n    f = x -&gt; x[1] - x[2]\n\n    ## discretization parameters\n    nref = 9\n    order = 1\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-f\">1</pre>\n\n<pre class='language-julia'><code class='language-julia'>tricontour(xgrid[Coordinates], xgrid[CellNodes], sol.entries[1:num_nodes(xgrid)]; levels = 5, resolution = (500, 500))</code></pre>\n<div style=\"white-space:nowrap;\"><div id=\"a1ef72de-5cb2-11f0-23c4-1b0990070106\" style=\"width: 440.0px; height: 440.0px; display: inline-block; \"></div><canvas height=\"475.0\" id=\"a1ef72de-5cb2-11f0-23c4-1b0990070106cbar\" style=\"display: inline-block; \" width=\"60,\"></canvas></div>\n<script>\n   // overwrite handleKeyPress and others\n// kind of modeled after https://kitware.github.io/vtk-js/api/Rendering_Core_Follower.html \n\nfunction vtkMyInteractorStyleTrackballCamera2D(publicAPI, model)\n{\n    model.classHierarchy.push('vtkMyInteractorStyleTrackballCamera2D');\n    publicAPI.handleKeyPress = (k) => {}\n    publicAPI.handleMouseRotate= (renderer, pos) => {}\n    publicAPI.handleMouseSpin= (renderer, pos) => {renderer.resetCamera()}\n}\n\nfunction vtkMyInteractorStyleTrackballCamera(publicAPI, model)\n{\n    model.classHierarchy.push('vtkMyInteractorStyleTrackballCamera');\n    publicAPI.handleKeyPress = (k) => {}\n    publicAPI.handleMouseSpin= (renderer, pos) => {renderer.resetCamera()}\n}\n\nfunction extend2d(publicAPI, model, initialValues = {})\n{\n    vtk.Interaction.Style.vtkInteractorStyleTrackballCamera.extend(publicAPI, model, initialValues);\n    vtkMyInteractorStyleTrackballCamera2D(publicAPI, model);\n}\n\nfunction extend3d(publicAPI, model, initialValues = {})\n{\n    vtk.Interaction.Style.vtkInteractorStyleTrackballCamera.extend(publicAPI, model, initialValues);\n    vtkMyInteractorStyleTrackballCamera(publicAPI, model);\n}\n\n\nfunction setinteractorstyle(interactor, camstyle)\n{\n    const mynewInstance2d = vtk.macro.newInstance(extend2d, 'vtkMyInteractorStyleTrackballCamera2D');\n    const mynewInstance3d = vtk.macro.newInstance(extend3d, 'vtkMyInteractorStyleTrackballCamera');\n    if (camstyle==\"2D\")\n        //        var style=vtk.Interaction.Style.vtkMyInteractorStyleImage.newInstance()\n        var style=mynewInstance2d()\n    else\n    //        var style=vtk.Interaction.Style.vtkInteractorStyleTrackballCamera.newInstance()\n        var style=mynewInstance3d()\n    \n    interactor.setInteractorStyle(style)\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\nfunction add_outline_dataset(win,opoints,opolys,ocolors)\n{\n    var ocolorData = vtk.Common.Core.vtkDataArray.newInstance({\n        name: 'Colors',\n        values: ocolors,\n        numberOfComponents: 4,\n    });\n    \n    if (win.outline_dataset==undefined)\n    {\n        win.outline_dataset = vtk.Common.DataModel.vtkPolyData.newInstance();\n        var actor = vtk.Rendering.Core.vtkActor.newInstance();\n\tvar mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n\tmapper.setInputData(win.outline_dataset);\n        mapper.setColorModeToDirectScalars()\n        actor.setForceTranslucent(true) //  https://discourse.vtk.org/t/wireframe-not-visible-behind-transparent-surfaces/6671\n\tactor.setMapper(mapper);\n        win.renderer.addActor(actor);\n    }\n    win.outline_dataset.getPoints().setData(opoints, 3);\n    win.outline_dataset.getPolys().setData(opolys,1);\n    win.outline_dataset.getCellData().setActiveScalars('Colors');\n    win.outline_dataset.getCellData().setScalars(ocolorData);        \n    win.outline_dataset.modified()\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\nfunction add_cell_dataset(win,points,polys,colors,aspect)\n{            \n    { // colored cells\n        if (colors!=\"none\")\n        {\n            if (win.cell_color_dataset == undefined)\n            {\n                win.cell_color_dataset = vtk.Common.DataModel.vtkPolyData.newInstance();\n                var actor = vtk.Rendering.Core.vtkActor.newInstance();\n                var mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n                mapper.setInputData(win.cell_color_dataset);\n                mapper.setColorModeToDirectScalars()\n                actor.setScale([1,aspect,1])\n                actor.setMapper(mapper);\n                win.renderer.addActor(actor);\n            }\n            \n            var colorData = vtk.Common.Core.vtkDataArray.newInstance({\n                name: 'Colors',\n                values: colors,\n                numberOfComponents: 3,\n            });\n            \n            win.cell_color_dataset.getPoints().setData(points, 3);\n            win.cell_color_dataset.getPolys().setData(polys,1);\n            win.cell_color_dataset.getCellData().setActiveScalars('Colors');\n            win.cell_color_dataset.getCellData().setScalars(colorData);        \n            win.cell_color_dataset.modified()\n        }\n    }\n    { // edges of cells\n        if (win.cell_edge_dataset == undefined)\n        {\n            \n            win.cell_edge_dataset = vtk.Common.DataModel.vtkPolyData.newInstance();\n            var actor = vtk.Rendering.Core.vtkActor.newInstance();\n\t    var mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n            mapper.setColorModeToDefault()\n\t    actor.getProperty().setRepresentation(1);\n\t    actor.getProperty().setColor(0, 0, 0);\n\t    actor.getProperty().setLineWidth(1);\n            actor.setScale([1,aspect,1])\n\t    mapper.setInputData(win.cell_edge_dataset);\n\t    actor.setMapper(mapper);\n\t    win.renderer.addActor(actor);\n            win.axis_actor=actor\n        }\n        \n        win.cell_edge_dataset.getPoints().setData(points, 3);\n        win.cell_edge_dataset.getPolys().setData(polys,1);\n        win.cell_edge_dataset.modified()\n    }\n}\n\n\n\nfunction plutovtkplot(uuid,jsdict,invalidation)\n{\n    \n    if (window[uuid+\"data\"] == undefined)\n    {\n        window[uuid+\"data\"]={}\n\n        var win=window[uuid+\"data\"]\n        win.renderWindow = vtk.Rendering.Core.vtkRenderWindow.newInstance();\n        win.renderer = vtk.Rendering.Core.vtkRenderer.newInstance();\n        \n        // OpenGlRenderWindow\n        win.openGlRenderWindow = vtk.Rendering.OpenGL.vtkRenderWindow.newInstance();\n        win.renderWindow.addView(win.openGlRenderWindow);\n        win.renderer.setBackground(1,1,1)\n        \n        // Interactor\n        win.interactor = vtk.Rendering.Core.vtkRenderWindowInteractor.newInstance();\n        win.interactor.setView(win.openGlRenderWindow);\n        \n        //ensure to plot to the right place\n        var rootContainer = document.getElementById(uuid);\n        win.openGlRenderWindow.setContainer(rootContainer);\n        const dims = rootContainer.getBoundingClientRect();\t\n        win.openGlRenderWindow.setSize(dims.width, dims.height);\n        win.interactor.bindEvents(rootContainer);\n        win.renderWindow.addRenderer(win.renderer)\n\n        // The invalidation promise is resolved when the cell starts rendering a newer output.\n        // We use it to release the WebGL context.\n        // (More info at https://plutocon2021-demos.netlify.app/fonsp%20%E2%80%94%20javascript%20inside%20pluto or https://observablehq.com/@observablehq/invalidation )\n        invalidation.then(() => {\n            win.renderWindow.delete();\n            win.openGlRenderWindow.delete();\n            win.interactor.delete();\n        });\n    }\n    \n\n    var win=window[uuid+\"data\"]\n    \n    // Loop over content of jsdict\n    for (var cmd = 1 ; cmd <= jsdict[\"cmdcount\"] ; cmd++)\n    {\n        \n        /////////////////////////////////////////////////////////////////\n        if (jsdict[cmd]==\"tricontour\")\n        {\n    \t    var points=jsdict[cmd+\"points\"]\n \t    var polys=jsdict[cmd+\"polys\"]\n            var isopoints=jsdict[cmd+\"isopoints\"]\n \t    var isolines=jsdict[cmd+\"isolines\"]\n            var colors=jsdict[cmd+\"colors\"]\n            var gridscale=jsdict[cmd+\"gridscale\"]\n            var aspect=jsdict[cmd+\"aspect\"]\n            \n            vtk.Common.Core.vtkMatrixBuilder\n                .buildFromRadian()\n                .scale(gridscale,gridscale,gridscale)\n                .apply(points);\n\n            vtk.Common.Core.vtkMatrixBuilder\n                .buildFromRadian()\n                .scale(gridscale,gridscale,gridscale)\n                .apply(isopoints);\n\n            \n            \n            { // Gouraud shaded triangles\n                if (win.color_triangle_dataset == undefined)\n                {\n                    win.color_triangle_dataset = vtk.Common.DataModel.vtkPolyData.newInstance();\n                    var actor = vtk.Rendering.Core.vtkActor.newInstance();\n                    var mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n                    mapper.setInputData(win.color_triangle_dataset);\n                    mapper.setColorModeToDirectScalars()\n                    actor.setMapper(mapper);\n                    actor.setScale(1,aspect,1)\n                    win.renderer.addActor(actor);\n                    \n                    // the axis actor is later used to read axis bounds\n                    win.axis_actor=actor\n                }\n                \n                var colorData = vtk.Common.Core.vtkDataArray.newInstance({\n                    name: 'Colors',\n                    values: colors,\n                    numberOfComponents: 3,\n                });\n                \n                win.color_triangle_dataset.getPoints().setData(points, 3);\n                win.color_triangle_dataset.getPolys().setData(polys,1);\n                win.color_triangle_dataset.getPointData().setActiveScalars('Colors');\n                win.color_triangle_dataset.getPointData().setScalars(colorData);        \n                win.color_triangle_dataset.modified()\n            }\n\n            if (isolines != \"none\")\n            { // Optional isolines\n                \n                //https://discourse.vtk.org/t/manually-create-polydata-in-vtk-js/885/4\n                \n                if (win.isoline_dataset == undefined)\n                {\n                    win.isoline_dataset=vtk.Common.DataModel.vtkPolyData.newInstance();\n                    var mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n                    var actor = vtk.Rendering.Core.vtkActor.newInstance();\n                    mapper.setInputData(win.isoline_dataset);\n                    actor.setMapper(mapper);\n                    actor.getProperty().setColor(0, 0, 0)\n                    actor.setScale(1,aspect,1)\n                    win.renderer.addActor(actor);\n                }\n                \n                win.isoline_dataset.getPoints().setData(isopoints, 3);\n                win.isoline_dataset.getLines().setData(isolines);\n                win.isoline_dataset.modified()\n            }\n        }\n        /////////////////////////////////////////////////////////////////\n        else if (jsdict[cmd]==\"quiver\")\n        { // 2D quiver\n            var qpoints=jsdict[cmd+\"points\"]\n \t    var qlines=jsdict[cmd+\"lines\"]\n            \n            if (win.quiver_dataset == undefined)\n            {\n                win.quiver_dataset=vtk.Common.DataModel.vtkPolyData.newInstance();\n                var mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n                var actor = vtk.Rendering.Core.vtkActor.newInstance();\n                mapper.setInputData(win.quiver_dataset);\n                actor.setMapper(mapper);\n                actor.getProperty().setColor(0, 0, 0)\n                win.renderer.addActor(actor);\n\n                if (win.axis_actor == undefined)\n                {\n                    win.axis_actor=actor\n                }\n            }\n            \n            win.quiver_dataset.getPoints().setData(qpoints, 3);\n\t    win.quiver_dataset.getLines().setData(qlines);\n\t    win.quiver_dataset.modified()\n        }\n        /////////////////////////////////////////////////////////////////\n        else if (jsdict[cmd]==\"tetcontour\")\n        {\n\n            var points=jsdict[cmd+\"points\"]\n \t    var polys=jsdict[cmd+\"polys\"]\n            var colors=jsdict[cmd+\"colors\"]\n\n\n            var outline=jsdict[cmd+\"outline\"]\n    \t    var opoints=jsdict[cmd+\"opoints\"]\n \t    var opolys=jsdict[cmd+\"opolys\"]\n            var ocolors=jsdict[cmd+\"ocolors\"]\n            var transparent=jsdict[cmd+\"transparent\"]\n            var gridscale=jsdict[cmd+\"gridscale\"]\n\n\n            vtk.Common.Core.vtkMatrixBuilder\n                .buildFromRadian()\n                .scale(gridscale,gridscale,gridscale)\n                .apply(points);\n\n            vtk.Common.Core.vtkMatrixBuilder\n                .buildFromRadian()\n                .scale(gridscale,gridscale,gridscale)\n                .apply(opoints);\n\n\n            { // isosurfaces and plane sections\n                \n                if (win.iso_plane_dataset == undefined)\n                {\n                    win.iso_plane_dataset = vtk.Common.DataModel.vtkPolyData.newInstance();\n                    var actor = vtk.Rendering.Core.vtkActor.newInstance();\n                    var mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n                    mapper.setInputData(win.iso_plane_dataset);\n                    mapper.setColorModeToDirectScalars()\n                    if (transparent==1)\n                    {\n                        actor.setForceTranslucent(true) //  https://discourse.vtk.org/t/wireframe-not-visible-behind-transparent-surfaces/6671\n                    }\n                    actor.setMapper(mapper);\n                    win.renderer.addActor(actor);\n                    win.axis_actor=actor\n                }\n                \n                if (transparent==1)\n                {\n                    var colorData = vtk.Common.Core.vtkDataArray.newInstance({\n                        name: 'Colors',\n                        values: colors,\n                        numberOfComponents: 4,\n                    });\n                }\n                else\n                {\n                    var colorData = vtk.Common.Core.vtkDataArray.newInstance({\n                        name: 'Colors',\n                        values: colors,\n                        numberOfComponents: 3,\n                    });\n                }\n                win.iso_plane_dataset.getPoints().setData(points, 3);\n                win.iso_plane_dataset.getPolys().setData(polys,1);\n                win.iso_plane_dataset.getPointData().setActiveScalars('Colors');\n                win.iso_plane_dataset.getPointData().setScalars(colorData);        \n                win.iso_plane_dataset.modified()\n            }\n\n            \n            if (outline==1)\n            {\n                add_outline_dataset(win,opoints,opolys,ocolors)\n            }\n        }\n        /////////////////////////////////////////////////////////////////\n        else if (jsdict[cmd]==\"trimesh\")\n        {\n\n    \t    var points=jsdict[cmd+\"points\"]\n \t    var polys=jsdict[cmd+\"polys\"]\n            var colors=jsdict[cmd+\"colors\"]\n            var lines=jsdict[cmd+\"lines\"]\n            var gridscale=jsdict[cmd+\"gridscale\"]\n            var linecolors=jsdict[cmd+\"linecolors\"]\n            var aspect=jsdict[cmd+\"aspect\"]\n            zshift=zshift*gridscale\n\n            var zshift=points[3]\n            vtk.Common.Core.vtkMatrixBuilder\n                .buildFromRadian()\n                .translate(0,0,-zshift)\n                .scale(gridscale,gridscale,gridscale)\n                .apply(points);\n\n\n            add_cell_dataset(win,points, polys, colors,aspect)\n\n\n            \n            if (lines != \"none\")\n            { // boundary edges\n\n                if (linecolors!=\"none\")\n                {\n                    var linecolorData = vtk.Common.Core.vtkDataArray.newInstance({\n                        name: 'Colors',\n                        values: linecolors,\n                        numberOfComponents: 3,\n                    });\n                }\n                \n                if (win.boundary_edge_dataset == undefined)\n                {\n                    win.boundary_edge_dataset=vtk.Common.DataModel.vtkPolyData.newInstance();\n                    var mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n                    var actor = vtk.Rendering.Core.vtkActor.newInstance();\n                    mapper.setInputData(win.boundary_edge_dataset);\n                    actor.setMapper(mapper);\n                    actor.setScale([1,aspect,1])\n                    actor.getProperty().setColor(0, 0, 0)\n\t\t    actor.getProperty().setLineWidth(3);\n                    win.renderer.addActor(actor);\n                }\n\n                \n                win.boundary_edge_dataset.getPoints().setData(Array.from(points), 3);\n                win.boundary_edge_dataset.getLines().setData(lines);\n                var pts=win.boundary_edge_dataset.getPoints().getData();\n\n                vtk.Common.Core.vtkMatrixBuilder\n                    .buildFromRadian()\n                    .translate(0,0,zshift)\n                    .apply(pts);\n\n                if (linecolors!=\"none\")\n                {\n                    win.boundary_edge_dataset.getCellData().setActiveScalars('Colors');\n                    win.boundary_edge_dataset.getCellData().setScalars(linecolorData);\n                }\n                win.boundary_edge_dataset.modified()\n            }\n\n        }\n        /////////////////////////////////////////////////////////////////\n        else if (jsdict[cmd]==\"tetmesh\")\n        {\n    \t    var points=jsdict[cmd+\"points\"]\n \t    var polys=jsdict[cmd+\"polys\"]\n            var colors=jsdict[cmd+\"colors\"]\n            var gridscale=jsdict[cmd+\"gridscale\"]\n\n            \n            var outline=jsdict[cmd+\"outline\"]\n    \t    var opoints=jsdict[cmd+\"opoints\"]\n \t    var opolys=jsdict[cmd+\"opolys\"]\n            var ocolors=jsdict[cmd+\"ocolors\"]\n\n            add_cell_dataset(win,points, polys, colors,1.0)\n\n            vtk.Common.Core.vtkMatrixBuilder\n                .buildFromRadian()\n                .scale(gridscale,gridscale,gridscale)\n                .apply(points);\n\n            vtk.Common.Core.vtkMatrixBuilder\n                .buildFromRadian()\n                .scale(gridscale,gridscale,gridscale)\n                .apply(opoints);\n\n            \n            if (outline==1)\n            {\n                add_outline_dataset(win,opoints,opolys,ocolors)\n            }\n\n        }\n        /////////////////////////////////////////////////////////////////\n        else if (jsdict[cmd]==\"axis\")\n        {\n            var axisfontsize= jsdict[cmd+\"axisfontsize\"] \n            var tickfontsize= jsdict[cmd+\"tickfontsize\"]\n            if (win.cubeAxes == undefined)\n            {\n \t        var camstyle=jsdict[cmd+\"cam\"]\n \t        var zoom=jsdict[cmd+\"zoom\"]\n                var xlabel=jsdict[cmd+\"xlabel\"]\n                var ylabel=jsdict[cmd+\"ylabel\"]\n                var zlabel=jsdict[cmd+\"zlabel\"]\n                \n                win.cubeAxes = vtk.Rendering.Core.vtkCubeAxesActor.newInstance();\n  \t        win.renderer.addActor(win.cubeAxes);\n\n                \n                win.interactor.initialize();\n                setinteractorstyle(win.interactor,camstyle)\n                \n\n                var camera=win.renderer.getActiveCamera()\n                if (camstyle==\"3D\")\n                {\n                    camera.roll(-30);\n                    camera.elevation(-60);\n                }\n                else\n                    camera.setParallelProjection(true)\n                    \n                win.cubeAxes.setCamera(camera);\n                \n                win.cubeAxes.setAxisLabels([xlabel,ylabel,zlabel])\n                if (camstyle==\"2D\")\n                    win.cubeAxes.setGridLines(false)\n\n                win.cubeAxes.setTickTextStyle({fontColor: \"black\"})\n                win.cubeAxes.setTickTextStyle({fontFamily: \"Arial\"})\n                win.cubeAxes.setTickTextStyle({fontSize: tickfontsize})\n                \n                win.cubeAxes.setAxisTextStyle({fontColor: \"black\"})\n                win.cubeAxes.setAxisTextStyle({fontFamily: \"Arial\"})\n                win.cubeAxes.setAxisTextStyle({fontSize: axisfontsize})\n                \n                win.cubeAxes.getProperty().setColor(0.75,0.75,0.75);\n                var databounds=win.axis_actor.getBounds()\n\t        win.cubeAxes.setDataBounds(databounds);\n\n                win.renderer.resetCamera();\n                camera.zoom(zoom)\n            }\n        }\n        /////////////////////////////////////////////////////////////////\n        else if (jsdict[cmd]==\"triplot\")\n        {// Experimental\n\n            if (win.triplot_dataset == undefined)\n            {\n                win.triplot_dataset = vtk.Common.DataModel.vtkPolyData.newInstance();\n                var actor = vtk.Rendering.Core.vtkActor.newInstance();\n                var mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n                mapper.setInputData(win.triplot_dataset);\n                actor.setMapper(mapper);\n                win.renderer.addActor(actor);\n                win.axis_actor=actor\n            }\n            \n    \t    var points=jsdict[cmd+\"points\"]\n \t    var polys=jsdict[cmd+\"polys\"]\n            win.triplot_dataset.getPoints().setData(points, 3);\n            win.triplot_dataset.getPolys().setData(polys,1);\n            win.triplot_dataset.modified()\n        }\n        /////////////////////////////////////////////////////////////////\n        else if (jsdict[cmd]==\"plot\")\n        {// Experimental\n    \t    var points=jsdict[cmd+\"points\"]\n \t    var lines=jsdict[cmd+\"lines\"]\n            \n            var actor = vtk.Rendering.Core.vtkActor.newInstance();\n            var mapper = vtk.Rendering.Core.vtkMapper.newInstance();\n\n            win.plotdataset=vtk.Common.DataModel.vtkPolyData.newInstance();\n            win.plotdataset.getPoints().setData(points, 3);\n            win.plotdataset.getLines().setData(lines);\n            mapper.setInputData(dataset);\n            actor.setMapper(mapper);\n            actor.getProperty().setColor(0, 0, 0)\n            win.renderer.addActor(actor);\n        }\n    }\n    win.renderWindow.render()\n}\n\n    \n\n   /* Canvas based color bar for vtk plots */\nfunction canvascolorbar(uuid,w,h,cbdict)\n{\n    var hpad=0.1*h\n    var h0=hpad\n    var h1=h-hpad\n    var dh=h1-h0\n    var canvas = document.getElementById(uuid);\n    var ctx = canvas.getContext(\"2d\");\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.textBaseline = \"middle\"\n    ctx.textAlign = \"left\"\n\n    if (cbdict[\"cbar\"]==1) /*gradient colorbar for contour plots */\n    {\n        var cstops=cbdict[\"cbar_stops\"]\n        var colors=cbdict[\"cbar_colors\"]\n        var levels=cbdict[\"cbar_levels\"]\n        var legendfontsize=cbdict[\"cbar_fontsize\"]\n        ctx.font = `${legendfontsize}px Arial`\n\n        var grad = ctx.createLinearGradient(0,h1, 0, h0);\n        var icol=0\n        for (var i=0;i<cstops.length;i++)\n        {\n            var color=`rgba(${colors[icol]},${colors[icol+1]},${colors[icol+2]})`;\n            grad.addColorStop(cstops[i],color);\n            icol+=3\n        }\n        ctx.fillStyle = grad;\n        ctx.fillRect(0,h0,0.5*w,dh);\n\n\n        ctx.strokeStyle = \"rgb(0,0,0)\"\n        ctx.fillStyle = \"rgb(0,0,0)\"\n        var lmin=levels[0]\n        var lmax=levels[levels.length-1]\n        for (var i=0;i<levels.length;i++)\n        {\n            var hlev=h1-dh*(levels[i]-lmin)/(lmax-lmin)\n    \t    ctx.beginPath();\n            ctx.moveTo(0, hlev);\n            ctx.lineTo(0.6*w,hlev);\n     \t    ctx.stroke();\n            ctx.fillText(levels[i].toPrecision(3),0.7*w,hlev)\n        }\n        \n    }\n    /* discontinuous colorbars for cell and boundary region numbers*/\n    else if (cbdict[\"cbar\"]==2) \n    {\n        var cstops=cbdict[\"cbar_stops\"]\n        var colors=cbdict[\"cbar_colors\"]\n        var levels=cbdict[\"cbar_levels\"]\n        var legendfontsize=cbdict[\"cbar_fontsize\"]\n        ctx.font = `${legendfontsize}px Arial`\n\n        // Region markers\n        if (cstops!=undefined)\n        {\n            var lmin=levels[0]\n            var lmax=levels[levels.length-1]+1\n            \n            var icol=0\n            var hl=dh*(levels[2]-levels[1])/(lmax-lmin)\n            for (var i=0;i<levels.length;i++)\n            {\n                var hlev=h1-dh*(levels[i]-lmin)/(lmax-lmin)\n                var color=`rgba(${colors[icol]},${colors[icol+1]},${colors[icol+2]})`;\n                ctx.strokeStyle = color\n                ctx.fillStyle = color\n                ctx.fillRect(0,hlev,0.4*w,-hl)\n                icol+=3\n            }\n            \n            ctx.strokeStyle = \"rgb(0,0,0)\"\n            ctx.fillStyle = \"rgb(0,0,0)\"\n            for (var i=0;i<levels.length;i++)\n            {\n                var hlev=h1-dh*(levels[i]-lmin)/(lmax-lmin)-0.5*hl\n                ctx.fillText(`${levels[i]}`,0.5*w,hlev)\n            }\n        }\n        \n        // edge markers\n        var cstops=cbdict[\"ecbar_stops\"]\n        var colors=cbdict[\"ecbar_colors\"]\n        var levels=cbdict[\"ecbar_levels\"]\n        if (cstops!=undefined)\n        {\n            var lmin=levels[0]\n            var lmax=levels[levels.length-1]+1\n            \n            var icol=0\n            var hl=dh*(levels[2]-levels[1])/(lmax-lmin)\n            for (var i=0;i<levels.length;i++)\n            {\n                var hlev=h1-dh*(levels[i]-lmin)/(lmax-lmin)\n                var color=`rgba(${colors[icol]},${colors[icol+1]},${colors[icol+2]})`;\n                ctx.strokeStyle = color\n                ctx.fillStyle = color\n                ctx.fillRect(w,hlev,0.4*w,-hl)\n                icol+=3\n            }\n            \n            ctx.strokeStyle = \"rgb(0,0,0)\"\n            ctx.fillStyle = \"rgb(0,0,0)\"\n            for (var i=0;i<levels.length;i++)\n            {\n                var hlev=h1-dh*(levels[i]-lmin)/(lmax-lmin)-0.5*hl\n                ctx.fillText(`${levels[i]}`,1.5*w,hlev)\n            }\n        }\n    }\n}\n\n   const jsdict = /* See the documentation for AbstractPlutoDingetjes.Display.published_to_js */ getPublishedObject(\"419454a2-5cb2-11f0-0526-95f5938aced4/f0ac001f0343a958\")\n   plutovtkplot(\"a1ef72de-5cb2-11f0-23c4-1b0990070106\",jsdict,invalidation)\n   canvascolorbar(\"a1ef72de-5cb2-11f0-23c4-1b0990070106cbar\",20,500.0,jsdict)        \n   </script>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    ## call low level solver\n    sol = solve_poisson_lowlevel(FES, μ, f)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-sol\">FEVector information\n====================\n   block  |  ndofs \t|     min  /  max    \t| FEType \t\t (name/tag)\n [    1]  |  263169\t| -1.21e-02/1.21e-02  \t| H1Pk{1,2,1}  \t (#1)</pre>\n\n<pre class='language-julia'><code class='language-julia'>function solve_poisson_lowlevel(FES, μ, f)\n\n    Solution = FEVector(FES)\n    FES = Solution[1].FES\n    A = FEMatrix(FES, FES)\n    b = FEVector(FES)\n    println(\"Assembling operators...\")\n    @time assemble!(A.entries, b.entries, FES, f, μ)\n\n    ## fix boundary dofs\n    println(\"Assembling boundary data...\")\n    @time begin\n        BFaceDofs::Adjacency{Int32} = FES[ExtendableFEMBase.BFaceDofs]\n        nbfaces::Int = num_sources(BFaceDofs)\n        AM::ExtendableSparseMatrix{Float64, Int64} = A.entries\n        dof_j::Int = 0\n        for bface in 1:nbfaces\n            for j in 1:num_targets(BFaceDofs, 1)\n                dof_j = BFaceDofs[j, bface]\n                AM[dof_j, dof_j] = 1.0e60\n                b.entries[dof_j] = 0\n            end\n        end\n    end\n    ExtendableSparse.flush!(A.entries)\n\n    ## solve\n    println(\"Solving linear system...\")\n    @time copyto!(Solution.entries, A.entries \\ b.entries)\n\n    return Solution\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-solve_poisson_lowlevel\">solve_poisson_lowlevel (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    ## create finite element space\n    FEType = H1Pk{1, 2, order}\n\n    ## prepare finite element space and dofmaps\n    println(\"Creating FESpace...\")\n    @time FES = FESpace{FEType}(xgrid)\n    FES\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-FES\">FESpace information\n===================\n     name = H1Pk{1,2,1}\n   FEType = H1Pk{1,2,1}\n  FEClass = ExtendableFEMBase.AbstractH1FiniteElement\n    ndofs = 263169\n\n\nDofMaps\n==========\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    ## create grid\n    X = LinRange(0, 1, 2^nref + 1)\n    Y = LinRange(0, 1, 2^nref + 1)\n    println(\"Creating grid...\")\n    @time xgrid = simplexgrid(X, Y)\n    println(\"Preparing FaceNodes...\")\n    @time xgrid[FaceNodes]\n    println(\"Preparing CellVolumes...\")\n    @time xgrid[CellVolumes]\n    xgrid\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-xgrid\">ExtendableGrids.ExtendableGrid{Float64, Int32};\ndim: 2 nodes: 263169 cells: 524288 bfaces: 2048\n\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>function assemble!(A::ExtendableSparseMatrix, b::Vector, FES, f, μ = 1)\n\n    xgrid = FES.xgrid\n    EG = xgrid[UniqueCellGeometries][1]\n    FEType = eltype(FES)\n    L2G = L2GTransformer(EG, xgrid, ON_CELLS)\n\n    ## dofmap\n    CellDofs = FES[ExtendableFEMBase.CellDofs]\n\n    ## quadrature formula\n    qf = QuadratureRule{Float64, EG}(2 * (get_polynomialorder(FEType, EG) - 1))\n    weights::Vector{Float64} = qf.w\n    xref::Vector{Vector{Float64}} = qf.xref\n    nweights::Int = length(weights)\n\n    ## FE basis evaluator\n    FEBasis_∇ = FEEvaluator(FES, Gradient, qf)\n    ∇vals = FEBasis_∇.cvals\n    FEBasis_id = FEEvaluator(FES, Identity, qf)\n    idvals = FEBasis_id.cvals\n\n\n    cellvolumes = xgrid[CellVolumes]\n\n    ## ASSEMBLY LOOP\n    function barrier(EG, L2G::L2GTransformer)\n        ## barrier function to avoid allocations by EG dispatch\n\n        ndofs4cell::Int = get_ndofs(ON_CELLS, FEType, EG)\n        Aloc = zeros(Float64, ndofs4cell, ndofs4cell)\n        ncells::Int = num_cells(xgrid)\n        dof_j::Int, dof_k::Int = 0, 0\n        x::Vector{Float64} = zeros(Float64, 2)\n\n        for cell in 1:ncells\n            ## update FE basis evaluators\n            FEBasis_∇.citem[] = cell\n            update_basis!(FEBasis_∇)\n\n            ## assemble local stiffness matrix\n            for j in 1:ndofs4cell, k in j:ndofs4cell\n                temp = 0\n                for qp in 1:nweights\n                    temp += weights[qp] * dot(view(∇vals, :, j, qp), view(∇vals, :, k, qp))\n                end\n                Aloc[j, k] = temp\n            end\n            Aloc .*= μ * cellvolumes[cell]\n\n            ## add local matrix to global matrix\n            for j in 1:ndofs4cell\n                dof_j = CellDofs[j, cell]\n                for k in j:ndofs4cell\n                    dof_k = CellDofs[k, cell]\n                    if abs(Aloc[j, k]) &gt; 1.0e-15\n                        # write into sparse matrix, only lines with allocations\n                        rawupdateindex!(A, +, Aloc[j, k], dof_j, dof_k)\n                        if k &gt; j\n                            rawupdateindex!(A, +, Aloc[j, k], dof_k, dof_j)\n                        end\n                    end\n                end\n            end\n            fill!(Aloc, 0)\n\n            ## assemble right-hand side\n            update_trafo!(L2G, cell)\n            for j in 1:ndofs4cell\n                ## right-hand side\n                temp = 0\n                for qp in 1:nweights\n                    ## get global x for quadrature point\n                    eval_trafo!(x, L2G, xref[qp])\n                    ## evaluate (f(x), v_j(x))\n                    temp += weights[qp] * idvals[1, j, qp] * f(x)\n                end\n                ## write into global vector\n                dof_j = CellDofs[j, cell]\n                b[dof_j] += temp * cellvolumes[cell]\n            end\n        end\n        return\n    end\n    barrier(EG, L2G)\n    return flush!(A)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-assemble!\">assemble! (generic function with 2 methods)</pre>\n<div class='manifest-versions'>\n<p>Built with Julia 1.11.5 and</p>\nExtendableFEMBase 0.2.0<br>\nExtendableGrids 1.2.3<br>\nExtendableSparse 1.2.1<br>\nGridVisualize 1.5.1<br>\nPlutoVista 1.0.1\n</div>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"module_examples/Example280_BasisPlotter/#280-:-Basis-Plotter","page":"Example280_BasisPlotter","title":"280 : Basis-Plotter","text":"","category":"section"},{"location":"module_examples/Example280_BasisPlotter/","page":"Example280_BasisPlotter","title":"Example280_BasisPlotter","text":"(source code)","category":"page"},{"location":"module_examples/Example280_BasisPlotter/","page":"Example280_BasisPlotter","title":"Example280_BasisPlotter","text":"This example plots all the basis functions of a H1 finite element on Edge1D or Triangle2D as unicode plots. This is the result with the default parameters (dim = 1, order = 3):","category":"page"},{"location":"module_examples/Example280_BasisPlotter/","page":"Example280_BasisPlotter","title":"Example280_BasisPlotter","text":"(Image: )","category":"page"},{"location":"module_examples/Example280_BasisPlotter/","page":"Example280_BasisPlotter","title":"Example280_BasisPlotter","text":"module Example280_BasisPlotter\n\nusing ExtendableFEMBase\nusing ExtendableGrids\n\n# everything is wrapped in a main function\nfunction main(; dim = 1, order = 3)\n\n    # generate two grids\n    @assert dim in [1, 2] \"dim must be 1 or 2\"\n    refgeom = dim == 1 ? Edge1D : Triangle2D\n    xgrid = reference_domain(refgeom)\n\n    # set finite element type and get some information\n    FEType = H1Pk{1, dim, order}\n    ndofs = get_ndofs(ON_CELLS, FEType, refgeom)\n    FEType = H1Pk{ndofs, dim, order}\n\n    # generate FEVector with ncomponents = ndofs\n    # that will carry one basis function in each component\n    FEFunc = FEVector(FESpace{FEType}(xgrid))\n    coffsets = ExtendableFEMBase.get_local_coffsets(FEType, ON_CELLS, refgeom)\n    for j in 1:ndofs\n        FEFunc[1][j + coffsets[j]] = 1\n    end\n\n    # plot\n    return println(stdout, unicode_scalarplot(FEFunc[1]; title = \"φ\", ylim = (-0.5, 1), resolution = dim == 1 ? (40, 10) : (20, 15), nrows = order))\nend\nend","category":"page"},{"location":"module_examples/Example280_BasisPlotter/","page":"Example280_BasisPlotter","title":"Example280_BasisPlotter","text":"","category":"page"},{"location":"module_examples/Example280_BasisPlotter/","page":"Example280_BasisPlotter","title":"Example280_BasisPlotter","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples_intro/#About-the-Examples","page":"Introduction","title":"About the Examples","text":"","category":"section"},{"location":"examples_intro/","page":"Introduction","title":"Introduction","text":"The provided examples are designed with the following goals in mind:","category":"page"},{"location":"examples_intro/","page":"Introduction","title":"Introduction","text":"They can be run directly from the Julia REPL.\nEach example is implemented as a Julia module, named similarly to the file's basename.\nExamples can serve as starting points for your own projects.\nSome examples include test cases that are integrated into the test suite.\nAssembly and solve times (especially for the first run) may be significantly higher due to Julia's just-in-time compilation.","category":"page"},{"location":"examples_intro/#Running-the-examples","page":"Introduction","title":"Running the examples","text":"","category":"section"},{"location":"examples_intro/","page":"Introduction","title":"Introduction","text":"In order to run ExampleXXX, perform the following steps:","category":"page"},{"location":"examples_intro/","page":"Introduction","title":"Introduction","text":"Download the example file (e.g., using the source code link at the top of the page).\nEnsure all required packages are installed in your Julia environment.\nIn the Julia REPL, run:","category":"page"},{"location":"examples_intro/","page":"Introduction","title":"Introduction","text":"julia> include(\"ExampleXXX.jl\")\njulia> ExampleXXX.main()","category":"page"},{"location":"examples_intro/","page":"Introduction","title":"Introduction","text":"Some examples provide visual output via the optional argument Plotter = PyPlot or Plotter = GLMakie (these require the corresponding plotting package to be installed and loaded).","category":"page"},{"location":"meshing/#Meshing","page":"Meshing","title":"Meshing","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Meshes in ExtendableFEMBase are represented using the ExtendableGrid type. For detailed information on grid structures and constructors, refer to the ExtendableGrids.jl documentation.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"To generate simplex grids, you can use external tools such as SimplexGridFactory.jl.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Each cell, face, and edge in a mesh is associated with an AbstractElementGeometry (as defined in ExtendableGrids.jl). These geometries are used to dispatch key functionality, including local-to-global transformations, enumeration rules, basis function definitions, volume calculations, and mesh refinements. See below for a list of supported element geometries.","category":"page"},{"location":"meshing/#Recognized-Geometries-and-Reference-Domains","page":"Meshing","title":"Recognized Geometries and Reference Domains","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The following list contains all subtypes of ExtendableGrids.AbstractElementGeometries and their reference domains for which the package offers finite elements on them.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Edge1D-:-AbstractElementGeometry1D","page":"Meshing","title":"Edge1D <: AbstractElementGeometry1D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[1]-----[2]               [1] = [0]\n                          [2] = [1]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Triangle2D","page":"Meshing","title":"Triangle2D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[3]                 \n | \\   \n |   \\                    [1] = [0,0]\n |     \\                  [2] = [1,0]\n |       \\                [3] = [0,1]\n |         \\ \n[1]--------[2]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Parallelogram2D-:-Quadrilateral2D","page":"Meshing","title":"Parallelogram2D <: Quadrilateral2D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[4]--------[3]               \n |          |             [1] = [0,0]\n |          |             [2] = [1,0]\n |          |             [3] = [1,1]\n |          |             [4] = [0,1]\n[1]--------[2]\n\nNote: most finite elements only work as intended on Parallelogram2D\n      since the local<>global map stays affine in this case","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Tetrahedron3D","page":"Meshing","title":"Tetrahedron3D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[4]                 \n |\\\\   \n | \\ \\                    [1] = [0,0,0]\n |  \\  \\                  [2] = [1,0,0]\n |   \\   \\                [3] = [0,1,0]\n | _-[3]-_ \\              [4] = [0,0,1]\n[1]--------[2]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Parallelepiped3D-:-Hexahedron3D","page":"Meshing","title":"Parallelepiped3D <: Hexahedron3D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"    [8]--------[7]        [1] = [0,0,0]\n   / |        / |         [2] = [1,0,0]\n[5]--------[6]  |         [3] = [1,1,0]\n |   |      |   |         [4] = [0,1,0]\n |   |      |   |         [5] = [0,0,1]\n |  [4]-----|--[3]        [6] = [1,0,1]\n | /        | /           [7] = [1,1,1]\n[1]--------[2]            [8] = [0,1,1]\n\nNote: most finite elements only work as intended on Parallelepiped3D\n      since the local<>global map stays affine in this case","category":"page"},{"location":"module_examples/Example200_LowLevelPoisson/#200-:-Poisson-Problem","page":"Example200_LowLevelPoisson","title":"200 : Poisson Problem","text":"","category":"section"},{"location":"module_examples/Example200_LowLevelPoisson/","page":"Example200_LowLevelPoisson","title":"Example200_LowLevelPoisson","text":"(source code)","category":"page"},{"location":"module_examples/Example200_LowLevelPoisson/","page":"Example200_LowLevelPoisson","title":"Example200_LowLevelPoisson","text":"This example computes the solution u of the two-dimensional Poisson problem","category":"page"},{"location":"module_examples/Example200_LowLevelPoisson/","page":"Example200_LowLevelPoisson","title":"Example200_LowLevelPoisson","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example200_LowLevelPoisson/","page":"Example200_LowLevelPoisson","title":"Example200_LowLevelPoisson","text":"with right-hand side f(xy) equiv xy and homogeneous Dirichlet boundary conditions on the unit square domain Omega on a given grid.","category":"page"},{"location":"module_examples/Example200_LowLevelPoisson/","page":"Example200_LowLevelPoisson","title":"Example200_LowLevelPoisson","text":"When run, this script also measures runtimes for grid generation, assembly and solving (direct/UMFPACK) for different refinement levels.","category":"page"},{"location":"module_examples/Example200_LowLevelPoisson/","page":"Example200_LowLevelPoisson","title":"Example200_LowLevelPoisson","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example200_LowLevelPoisson/","page":"Example200_LowLevelPoisson","title":"Example200_LowLevelPoisson","text":"(Image: )","category":"page"},{"location":"module_examples/Example200_LowLevelPoisson/","page":"Example200_LowLevelPoisson","title":"Example200_LowLevelPoisson","text":"module Example200_LowLevelPoisson\n\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\nusing UnicodePlots\nusing Test #\n\nfunction main(;\n        maxnref = 8,\n        order = 2,\n        Plotter = nothing,\n        mu = 1.0,\n        rhs = x -> x[1] - x[2]\n    )\n    # Finite element type\n    FEType = H1Pk{1, 2, order}\n\n    # run once on a tiny mesh for compiling\n    X = LinRange(0, 1, 4)\n    xgrid = simplexgrid(X, X)\n    fe_space = FESpace{FEType}(xgrid)\n    solution, time_assembly, time_solve = solve_poisson_lowlevel(fe_space, mu, rhs)\n\n    # loop over uniform refinements + timings\n    plt = GridVisualizer(; Plotter = Plotter, layout = (1, 1), clear = true, resolution = (500, 500))\n    loop_allocations = 0\n    for level in 1:maxnref\n        X = LinRange(0, 1, 2^level + 1)\n        time_grid = @elapsed xgrid = simplexgrid(X, X)\n        time_facenodes = @elapsed xgrid[FaceNodes]\n        fe_space = FESpace{FEType}(xgrid)\n        println(\"\\nLEVEL = $level, ndofs = $(fe_space.ndofs)\\n\")\n        if level < 4\n            println(stdout, unicode_gridplot(xgrid))\n        end\n        time_dofmap = @elapsed fe_space[CellDofs]\n        solution, time_assembly, time_solve = solve_poisson_lowlevel(fe_space, mu, rhs)\n\n        # plot statistics\n        println(stdout, barplot([\"Grid\", \"FaceNodes\", \"celldofs\", \"Assembly\", \"Solve\"], [time_grid, time_facenodes, time_dofmap, time_assembly, time_solve], title = \"Runtimes\"))\n\n        # plot\n        if Plotter !== nothing\n            scalarplot!(plt[1, 1], xgrid, view(solution.entries, 1:num_nodes(xgrid)), limits = (-0.0125, 0.0125))\n        else\n            solution_grad = continuify(solution[1], Gradient)\n            println(stdout, unicode_scalarplot(solution[1]))\n        end\n    end\n\n    return solution, plt\nend\n\n\nfunction solve_poisson_lowlevel(fe_space, mu, rhs)\n    solution = FEVector(fe_space)\n    stiffness_matrix = FEMatrix(fe_space, fe_space)\n    rhs_vector = FEVector(fe_space)\n    println(\"Assembling...\")\n    time_assembly = @elapsed @time begin\n        loop_allocations = assemble!(stiffness_matrix.entries, rhs_vector.entries, fe_space, rhs, mu)\n\n        # fix boundary dofs\n        begin\n            bdofs = boundarydofs(fe_space)\n            for dof in bdofs\n                stiffness_matrix.entries[dof, dof] = 1.0e60\n                rhs_vector.entries[dof] = 0\n            end\n        end\n        ExtendableSparse.flush!(stiffness_matrix.entries)\n    end\n\n    # solve\n    println(\"Solving linear system...\")\n    time_solve = @elapsed @time copyto!(solution.entries, stiffness_matrix.entries \\ rhs_vector.entries)\n\n    return solution, time_assembly, time_solve\nend\n\nfunction assemble!(A::ExtendableSparseMatrix, b::Vector, fe_space, rhs, mu = 1)\n    xgrid = fe_space.xgrid\n    EG = xgrid[UniqueCellGeometries][1]\n    FEType = eltype(fe_space)\n    L2G = L2GTransformer(EG, xgrid, ON_CELLS)\n\n    # quadrature formula\n    qf = QuadratureRule{Float64, EG}(2 * (get_polynomialorder(FEType, EG) - 1))\n    weights::Vector{Float64} = qf.w\n    xref::Vector{Vector{Float64}} = qf.xref\n    nweights::Int = length(weights)\n    cellvolumes = xgrid[CellVolumes]\n\n    # FE basis evaluator and dofmap\n    FEBasis_∇ = FEEvaluator(fe_space, Gradient, qf)\n    ∇vals = FEBasis_∇.cvals\n    FEBasis_id = FEEvaluator(fe_space, Identity, qf)\n    idvals = FEBasis_id.cvals\n    celldofs = fe_space[CellDofs]\n\n    # ASSEMBLY LOOP\n    loop_allocations = 0\n    function barrier(EG, L2G::L2GTransformer)\n        # barrier function to avoid allocations by type dispatch\n        ndofs4cell::Int = get_ndofs(ON_CELLS, FEType, EG)\n        Aloc = zeros(Float64, ndofs4cell, ndofs4cell)\n        ncells::Int = num_cells(xgrid)\n        dof_j::Int, dof_k::Int = 0, 0\n        x::Vector{Float64} = zeros(Float64, 2)\n\n        return loop_allocations += @allocated for cell in 1:ncells\n            # update FE basis evaluators\n            FEBasis_∇.citem[] = cell\n            update_basis!(FEBasis_∇)\n\n            # assemble local stiffness matrix\n            for j in 1:ndofs4cell, k in j:ndofs4cell\n                temp = 0\n                for qp in 1:nweights\n                    temp += weights[qp] * dot(view(∇vals, :, j, qp), view(∇vals, :, k, qp))\n                end\n                Aloc[j, k] = temp\n            end\n            Aloc .*= mu * cellvolumes[cell]\n\n            # add local matrix to global matrix\n            for j in 1:ndofs4cell\n                dof_j = celldofs[j, cell]\n                for k in j:ndofs4cell\n                    dof_k = celldofs[k, cell]\n                    if abs(Aloc[j, k]) > 1.0e-15\n                        # write into sparse matrix, only lines with allocations\n                        rawupdateindex!(A, +, Aloc[j, k], dof_j, dof_k)\n                        if k > j\n                            rawupdateindex!(A, +, Aloc[j, k], dof_k, dof_j)\n                        end\n                    end\n                end\n            end\n            fill!(Aloc, 0)\n\n            # assemble right-hand side\n            update_trafo!(L2G, cell)\n            for j in 1:ndofs4cell\n                # right-hand side\n                temp = 0\n                for qp in 1:nweights\n                    # get global x for quadrature point\n                    eval_trafo!(x, L2G, xref[qp])\n                    # evaluate (f(x), v_j(x))\n                    temp += weights[qp] * idvals[1, j, qp] * rhs(x)\n                end\n                # write into global vector\n                dof_j = celldofs[j, cell]\n                b[dof_j] += temp * cellvolumes[cell]\n            end\n        end\n    end\n    barrier(EG, L2G)\n    flush!(A)\n    return loop_allocations\nend\n\nfunction generateplots(dir = pwd(); Plotter = nothing, kwargs...)\n    ~, plt = main(; Plotter = Plotter, kwargs...)\n    scene = GridVisualize.reveal(plt)\n    return GridVisualize.save(joinpath(dir, \"example200.png\"), scene; Plotter = Plotter)\nend\n\nfunction runtests(;\n        order = 2,\n        mu = 1.0,\n        rhs = x -> x[1] - x[2],\n        kwargs...\n    )\n    FEType = H1Pk{1, 2, order}\n    X = LinRange(0, 1, 64)\n    xgrid = simplexgrid(X, X)\n    fe_space = FESpace{FEType}(xgrid)\n    stiffness_matrix = FEMatrix(fe_space, fe_space)\n    rhs_vector = FEVector(fe_space)\n    @info \"ndofs = $(fe_space.ndofs)\"\n    # first assembly causes allocations when filling sparse matrix\n    loop_allocations = assemble!(stiffness_matrix.entries, rhs_vector.entries, fe_space, rhs, mu)\n    @info \"allocations in 1st assembly: $loop_allocations\"\n    # second assembly in same matrix should have allocation-free inner loop\n    loop_allocations = assemble!(stiffness_matrix.entries, rhs_vector.entries, fe_space, rhs, mu)\n    @info \"allocations in 2nd assembly: $loop_allocations\"\n    return @test loop_allocations == 0\nend #module","category":"page"},{"location":"module_examples/Example200_LowLevelPoisson/","page":"Example200_LowLevelPoisson","title":"Example200_LowLevelPoisson","text":"","category":"page"},{"location":"module_examples/Example200_LowLevelPoisson/","page":"Example200_LowLevelPoisson","title":"Example200_LowLevelPoisson","text":"This page was generated using Literate.jl.","category":"page"},{"location":"plutostatichtml_examples/LowLevelNavierStokes/","page":"Low level Navier-Stokes","title":"Low level Navier-Stokes","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"a0c36f13b2f5defa9c787d838cf791d680ffe6338dd21e676efe6d6c8705dbc7\"\n    julia_version = \"1.11.5\"\n-->\n\n\n\n\n<div class=\"markdown\"><h1 id=\"Tutorial-notebook:-Navier–Stokes-problem\">Tutorial notebook: Navier–Stokes problem</h1><p>Consider the Navier-Stokes problem that seeks <span class=\"tex\">\\(u\\)</span> and <span class=\"tex\">\\(p\\)</span> such that</p><p class=\"tex\">$$\\begin{aligned}\n\t- \\mu \\Delta u + (u \\cdot \\nabla) u + \\nabla p &amp;= f\\\\\n\t\t\t\\mathrm{div}(u) &amp; = 0.\n\\end{aligned}$$</p><p>The weak formulation seeks <span class=\"tex\">\\(u \\in V := H^1_0(\\Omega)\\)</span> and <span class=\"tex\">\\(p \\in Q := L^2_0(\\Omega)\\)</span> such that</p><p class=\"tex\">$$\\begin{aligned}\n\t\\mu (\\nabla u, \\nabla v) + ((u \\cdot \\nabla) u, v) - (p, \\mathrm{div}(v)) &amp; = (f, v)\n\t&amp; \\text{for all } v \\in V\\\\\n\t(q, \\mathrm{div}(u)) &amp; = 0\n\t&amp; \\text{for all } q \\in Q\\\\\n\\end{aligned}$$</p><p>This tutorial notebook compute a planar lattice flow with inhomogeneous Dirichlet boundary conditions (which requires some modification above). Newton's method with automatic differentation is used to handle the nonlinear convection term.</p></div>\n\n\n<div class=\"markdown\"><p>This is a plot of the computed velocity and pressure:</p></div>\n\n\n<pre class=\"code-output documenter-example-output\" id=\"var-hash399166\">2-element Vector{PlutoVTKPlot}:\n PlutoVTKPlot(Dict{String, Any}(\"2axisfontsize\" =&gt; 10, \"1\" =&gt; \"tricontour\", \"2ylabel\" =&gt; \"y\", \"2\" =&gt; \"axis\", \"cbar_levels\" =&gt; [6.123233995736766e-17, 0.16667347690578882, 0.3333469538115776, 0.5000204307173663, 0.6666939076231551, 0.833367384528944, 1.0000408614347327], \"cbar\" =&gt; 1, \"2xlabel\" =&gt; \"x\", \"2zlabel\" =&gt; \"z\", \"cbar_stops\" =&gt; [0.0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09  …  0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.0], \"2zoom\" =&gt; 1.0…), 300.0, 300.0, false, (title = \"\", titlefontsize = 12, axisfontsize = 10, tickfontsize = 10, xlabel = \"x\", ylabel = \"y\", zlabel = \"z\", aspect = 1.0, zoom = 1.0, legendfontsize = 10, colorbarticks = :default, clear = false, levels = 5), \"c075609a-5cb2-11f0-2df5-8bfe35267ffd\")\n PlutoVTKPlot(Dict{String, Any}(\"2axisfontsize\" =&gt; 10, \"1\" =&gt; \"tricontour\", \"2ylabel\" =&gt; \"y\", \"2\" =&gt; \"axis\", \"cbar_levels\" =&gt; [-0.5064542228750328, -0.33763730567358835, -0.1688203884721439, -3.4712706993289544e-6, 0.16881344593074513, 0.3376303631321897, 0.5064472803336342], \"cbar\" =&gt; 1, \"2xlabel\" =&gt; \"x\", \"2zlabel\" =&gt; \"z\", \"cbar_stops\" =&gt; [0.0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09  …  0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.0], \"2zoom\" =&gt; 1.0…), 300.0, 300.0, false, (title = \"\", titlefontsize = 12, axisfontsize = 10, tickfontsize = 10, xlabel = \"x\", ylabel = \"y\", zlabel = \"z\", aspect = 1.0, zoom = 1.0, legendfontsize = 10, colorbarticks = :default, clear = false, levels = 5), \"c12437b6-5cb2-11f0-0ce5-23714aeabba1\")</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    ## PDE data\n    const μ = 1.0e-2\n    function f!(fval, x, t) # right-hand side\n        fval[1] = 8.0 * π * π * μ * exp(-8.0 * π * π * μ * t) * sin(2.0 * π * x[1]) * sin(2.0 * π * x[2])\n        fval[2] = 8.0 * π * π * μ * exp(-8.0 * π * π * μ * t) * cos(2.0 * π * x[1]) * cos(2.0 * π * x[2])\n        return nothing\n    end\n\n    # exact velocity (for boundary data and error calculation)\n    function u!(uval, qpinfo)\n        x = qpinfo.x\n        t = qpinfo.time\n        uval[1] = exp(-8.0 * π * π * μ * t) * sin(2.0 * π * x[1]) * sin(2.0 * π * x[2])\n        uval[2] = exp(-8.0 * π * π * μ * t) * cos(2.0 * π * x[1]) * cos(2.0 * π * x[2])\n        return nothing\n    end\n\n    ## discretization parameters\n    const nref = 5\n    const teval = 0\n    const order = 2\n\n    ## prepare error calculation\n    function p!(pval, x, t) # exact pressure (for error calculation)\n        pval[1] = exp(-16 * pi * pi * μ * t) * (cos(4 * pi * x[1]) - cos(4 * pi * x[2])) / 4\n        return nothing\n    end\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-μ\">p! (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    ## create grid\n    X = LinRange(0, 1, 2^nref + 1)\n    Y = LinRange(0, 1, 2^nref + 1)\n    println(\"Creating grid...\")\n    @time xgrid = simplexgrid(X, Y)\n    println(\"Preparing FaceNodes...\")\n    @time xgrid[FaceNodes]\n    println(\"Preparing CellVolumes...\")\n    @time xgrid[CellVolumes]\n    xgrid\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-xgrid\">ExtendableGrids.ExtendableGrid{Float64, Int32};\ndim: 2 nodes: 1089 cells: 2048 bfaces: 128\n\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    ## create finite element space (Taylor--Hood)\n    FETypes = [H1Pk{2, 2, order}, H1Pk{1, 2, order - 1}]\n\n    ## prepare finite element space and dofmaps\n    println(\"Creating FESpace...\")\n    @time FES = [FESpace{FETypes[1]}(xgrid; name = \"velocity space\"), FESpace{FETypes[2]}(xgrid; name = \"pressure space\")]\n    FES\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-FES\">2-element Vector{FESpace{Float64, Int32, FEType, ON_CELLS} where FEType&lt;:AbstractFiniteElement}:\n \nFESpace information\n===================\n     name = velocity space\n   FEType = H1Pk{2,2,2}\n  FEClass = ExtendableFEMBase.AbstractH1FiniteElement\n    ndofs = 8450\n\n\nDofMaps\n==========\n\n \nFESpace information\n===================\n     name = pressure space\n   FEType = H1Pk{1,2,1}\n  FEClass = ExtendableFEMBase.AbstractH1FiniteElement\n    ndofs = 1089\n\n\nDofMaps\n==========\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    ## call low level solver\n    sol, u_init = solve_stokes_lowlevel(FES, μ, f!)\n    sol\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-u_init\">FEVector information\n====================\n   block  |  ndofs \t|     min  /  max    \t| FEType \t\t (name/tag)\n [    1]  |    8450\t| -1.00e+00/1.00e+00  \t| velocity space  \t (#1)\n [    2]  |    1089\t| -5.06e-01/5.06e-01  \t| pressure space  \t (#2)</pre>\n\n<pre class='language-julia'><code class='language-julia'>function solve_stokes_lowlevel(FES, μ, f!)\n\n    println(\"Initializing system...\")\n    Solution = FEVector(FES)\n    A = FEMatrix(FES)\n    b = FEVector(FES)\n    @time update_system! = prepare_assembly!(A, b, FES[1], FES[2], Solution, f!, μ)\n    @time update_system!(true, false)\n    Alin = deepcopy(A) # = keep linear part of system matrix\n    blin = deepcopy(b) # = keep linear part of right-hand side\n\n    println(\"Prepare boundary conditions...\")\n    @time begin\n        u_init = FEVector(FES)\n        interpolate!(u_init[1], u!; time = teval)\n\n        fixed_dofs = [size(A.entries, 1)] # fix one pressure dof = last dof\n        BFaceDofs::Adjacency{Int32} = FES[1][ExtendableFEMBase.BFaceDofs]\n        nbfaces::Int = num_sources(BFaceDofs)\n        AM::ExtendableSparseMatrix{Float64, Int64} = A.entries\n        dof_j::Int = 0\n        for bface in 1:nbfaces\n            for j in 1:num_targets(BFaceDofs, 1)\n                dof_j = BFaceDofs[j, bface]\n                push!(fixed_dofs, dof_j)\n            end\n        end\n    end\n\n\n    for it in 1:20\n        ## solve\n        println(\"\\nITERATION $it\\n=============\")\n        println(\"Solving linear system...\")\n        @time copyto!(Solution.entries, A.entries \\ b.entries)\n        res = A.entries.cscmatrix * Solution.entries .- b.entries\n        for dof in fixed_dofs\n            res[dof] = 0\n        end\n        linres = norm(res)\n        println(\"linear residual = $linres\")\n\n        fill!(A.entries.cscmatrix.nzval, 0)\n        fill!(b.entries, 0)\n        println(\"Updating linear system...\")\n        @time begin\n            update_system!(false, true)\n            A.entries.cscmatrix += Alin.entries.cscmatrix\n            b.entries .+= blin.entries\n        end\n\n        ## fix boundary dofs\n        for dof in fixed_dofs\n            AM[dof, dof] = 1.0e60\n            b.entries[dof] = 1.0e60 * u_init.entries[dof]\n        end\n        ExtendableSparse.flush!(A.entries)\n\n        ## calculate nonlinear residual\n        res = A.entries.cscmatrix * Solution.entries .- b.entries\n        for dof in fixed_dofs\n            res[dof] = 0\n        end\n        nlres = norm(res)\n        println(\"nonlinear residual = $nlres\")\n        if nlres &lt; max(1.0e-12, 20 * linres)\n            break\n        end\n    end\n\n    return Solution, u_init\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-solve_stokes_lowlevel\">solve_stokes_lowlevel (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>function prepare_assembly!(A, b, FESu, FESp, Solution, f, μ = 1)\n\n    A = A.entries\n    b = b.entries\n    Solution = Solution.entries\n    xgrid = FESu.xgrid\n    EG = xgrid[UniqueCellGeometries][1]\n    FEType_u = eltype(FESu)\n    FEType_p = eltype(FESp)\n    L2G = L2GTransformer(EG, xgrid, ON_CELLS)\n    cellvolumes = xgrid[CellVolumes]\n    ncells::Int = num_cells(xgrid)\n\n    ## dofmap\n    CellDofs_u = FESu[ExtendableFEMBase.CellDofs]\n    CellDofs_p = FESp[ExtendableFEMBase.CellDofs]\n    offset_p = FESu.ndofs\n\n    ## quadrature formula\n    qf = QuadratureRule{Float64, EG}(3 * get_polynomialorder(FEType_u, EG) - 1)\n    weights::Vector{Float64} = qf.w\n    xref::Vector{Vector{Float64}} = qf.xref\n    nweights::Int = length(weights)\n\n    ## FE basis evaluator\n    FEBasis_∇u = FEEvaluator(FESu, Gradient, qf)\n    ∇uvals = FEBasis_∇u.cvals\n    FEBasis_idu = FEEvaluator(FESu, Identity, qf)\n    iduvals = FEBasis_idu.cvals\n    FEBasis_idp = FEEvaluator(FESp, Identity, qf)\n    idpvals = FEBasis_idp.cvals\n\n    ## prepare automatic differentation of convection operator\n    function operator!(result, input)\n        # result = (u ⋅ ∇)u\n        result[1] = input[1] * input[3] + input[2] * input[4]\n        return result[2] = input[1] * input[5] + input[2] * input[6]\n    end\n    result = Vector{Float64}(undef, 2)\n    input = Vector{Float64}(undef, 6)\n    tempV = zeros(Float64, 2)\n    Dresult = DiffResults.JacobianResult(result, input)\n    cfg = ForwardDiff.JacobianConfig(operator!, result, input, ForwardDiff.Chunk{6}())\n    jac = DiffResults.jacobian(Dresult)\n    value = DiffResults.value(Dresult)\n\n\n    ## ASSEMBLY LOOP\n    function barrier(EG, L2G::L2GTransformer, linear::Bool, nonlinear::Bool)\n        ## barrier function to avoid allocations caused by L2G\n\n        ndofs4cell_u::Int = get_ndofs(ON_CELLS, FEType_u, EG)\n        ndofs4cell_p::Int = get_ndofs(ON_CELLS, FEType_p, EG)\n        Aloc = zeros(Float64, ndofs4cell_u, ndofs4cell_u)\n        Bloc = zeros(Float64, ndofs4cell_u, ndofs4cell_p)\n        dof_j::Int, dof_k::Int = 0, 0\n        fval::Vector{Float64} = zeros(Float64, 2)\n        x::Vector{Float64} = zeros(Float64, 2)\n\n        for cell in 1:ncells\n            ## update FE basis evaluators\n            update_basis!(FEBasis_∇u, cell)\n            update_basis!(FEBasis_idu, cell)\n            update_basis!(FEBasis_idp, cell)\n\n            ## assemble local stiffness matrix (symmetric)\n            if (linear)\n                for j in 1:ndofs4cell_u, k in 1:ndofs4cell_u\n                    temp = 0\n                    for qp in 1:nweights\n                        temp += weights[qp] * dot(view(∇uvals, :, j, qp), view(∇uvals, :, k, qp))\n                    end\n                    Aloc[k, j] = μ * temp\n                end\n\n                ## assemble div-pressure coupling\n                for j in 1:ndofs4cell_u, k in 1:ndofs4cell_p\n                    temp = 0\n                    for qp in 1:nweights\n                        temp -= weights[qp] * (∇uvals[1, j, qp] + ∇uvals[4, j, qp]) *\n                            idpvals[1, k, qp]\n                    end\n                    Bloc[j, k] = temp\n                end\n                Bloc .*= cellvolumes[cell]\n\n                ## assemble right-hand side\n                update_trafo!(L2G, cell)\n                for j in 1:ndofs4cell_u\n                    ## right-hand side\n                    temp = 0\n                    for qp in 1:nweights\n                        ## get global x for quadrature point\n                        eval_trafo!(x, L2G, xref[qp])\n                        ## evaluate (f(x), v_j(x))\n                        f!(fval, x, teval)\n                        temp += weights[qp] * dot(view(iduvals, :, j, qp), fval)\n                    end\n                    ## write into global vector\n                    dof_j = CellDofs_u[j, cell]\n                    b[dof_j] += temp * cellvolumes[cell]\n                end\n            end\n\n            ## assemble nonlinear term\n            if (nonlinear)\n                for qp in 1:nweights\n                    fill!(input, 0)\n                    for j in 1:ndofs4cell_u\n                        dof_j = CellDofs_u[j, cell]\n                        for d in 1:2\n                            input[d] += Solution[dof_j] * iduvals[d, j, qp]\n                        end\n                        for d in 1:4\n                            input[2 + d] += Solution[dof_j] * ∇uvals[d, j, qp]\n                        end\n                    end\n\n                    ## evaluate jacobian\n                    ForwardDiff.chunk_mode_jacobian!(Dresult, operator!, result, input, cfg)\n\n                    # update matrix\n                    for j in 1:ndofs4cell_u\n                        # multiply ansatz function with local jacobian\n                        fill!(tempV, 0)\n                        for d in 1:2\n                            tempV[1] += jac[1, d] * iduvals[d, j, qp]\n                            tempV[2] += jac[2, d] * iduvals[d, j, qp]\n                        end\n                        for d in 1:4\n                            tempV[1] += jac[1, 2 + d] * ∇uvals[d, j, qp]\n                            tempV[2] += jac[2, 2 + d] * ∇uvals[d, j, qp]\n                        end\n\n                        # multiply test function operator evaluation\n                        for k in 1:ndofs4cell_u\n                            Aloc[k, j] += dot(tempV, view(iduvals, :, k, qp)) * weights[qp]\n                        end\n                    end\n\n                    # update rhs\n                    mul!(tempV, jac, input)\n                    tempV .-= value\n                    for j in 1:ndofs4cell_u\n                        dof_j = CellDofs_u[j, cell]\n                        b[dof_j] += dot(tempV, view(iduvals, :, j, qp)) * weights[qp] * cellvolumes[cell]\n                    end\n                end\n            end\n\n            ## add local matrices to global matrix\n            Aloc .*= cellvolumes[cell]\n            for j in 1:ndofs4cell_u\n                dof_j = CellDofs_u[j, cell]\n                for k in 1:ndofs4cell_u\n                    dof_k = CellDofs_u[k, cell]\n                    rawupdateindex!(A, +, Aloc[j, k], dof_j, dof_k)\n                end\n                if (linear)\n                    for k in 1:ndofs4cell_p\n                        dof_k = CellDofs_p[k, cell] + offset_p\n                        rawupdateindex!(A, +, Bloc[j, k], dof_j, dof_k)\n                        rawupdateindex!(A, +, Bloc[j, k], dof_k, dof_j)\n                    end\n                end\n            end\n            fill!(Aloc, 0)\n            fill!(Bloc, 0)\n        end\n        return\n    end\n\n    function update_system!(linear::Bool, nonlinear::Bool)\n        barrier(EG, L2G, linear, nonlinear)\n        return flush!(A)\n    end\n    return update_system!\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-prepare_assembly!\">prepare_assembly! (generic function with 2 methods)</pre>\n<div class='manifest-versions'>\n<p>Built with Julia 1.11.5 and</p>\nDiffResults 1.1.0<br>\nExtendableFEMBase 0.2.0<br>\nExtendableGrids 1.2.3<br>\nExtendableSparse 1.2.1<br>\nForwardDiff 0.10.38<br>\nGridVisualize 1.5.1<br>\nLinearAlgebra 1.11.0<br>\nPlutoVista 1.0.1\n</div>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"module_examples/Example290_InterpolationBetweenMeshes/#290-:-Interpolation-Between-Meshes","page":"Example290_InterpolationBetweenMeshes","title":"290 : Interpolation Between Meshes","text":"","category":"section"},{"location":"module_examples/Example290_InterpolationBetweenMeshes/","page":"Example290_InterpolationBetweenMeshes","title":"Example290_InterpolationBetweenMeshes","text":"(source code)","category":"page"},{"location":"module_examples/Example290_InterpolationBetweenMeshes/","page":"Example290_InterpolationBetweenMeshes","title":"Example290_InterpolationBetweenMeshes","text":"This example demonstrates the interpolation between meshes feature. Here, we interpolate a function with the P2 element of a coarse triangulation and then interpolate this P2 function on two uniform refinements into some P1 function. Then, both finite element functions are plotted.","category":"page"},{"location":"module_examples/Example290_InterpolationBetweenMeshes/","page":"Example290_InterpolationBetweenMeshes","title":"Example290_InterpolationBetweenMeshes","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example290_InterpolationBetweenMeshes/","page":"Example290_InterpolationBetweenMeshes","title":"Example290_InterpolationBetweenMeshes","text":"(Image: )","category":"page"},{"location":"module_examples/Example290_InterpolationBetweenMeshes/","page":"Example290_InterpolationBetweenMeshes","title":"Example290_InterpolationBetweenMeshes","text":"module Example290_InterpolationBetweenMeshes\n\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing GridVisualize\n\n# function to interpolate\nfunction u!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = sin(4 * pi * x[1]) * sin(4 * pi * x[2])\n    return result[2] = cos(4 * pi * x[1]) * cos(4 * pi * x[2])\nend\n\n# everything is wrapped in a main function\nfunction main(; ν = 1.0e-3, nrefs = 4, Plotter = nothing)\n\n    # generate two grids\n    xgrid1 = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n    xgrid2 = uniform_refine(xgrid1, 3; store_parents = true)\n\n    @show xgrid1 xgrid2\n\n    # set finite element types for the two grids\n    FEType1 = H1Pk{2, 2, 2}\n    FEType2 = H1Pk{2, 2, 1}\n\n    # generate coressponding finite element spaces and FEVectors\n    FES1 = FESpace{FEType1}(xgrid1)\n    FES2 = FESpace{FEType2}(xgrid2)\n    FEFunction1 = FEVector(FES1)\n    FEFunction2 = FEVector(FES2)\n\n    # interpolate function onto first grid\n    @time interpolate!(FEFunction1[1], u!)\n    @time interpolate!(FEFunction2[1], u!)\n\n    # interpolate onto other grid\n    @time lazy_interpolate!(FEFunction2[1], FEFunction1)\n    @time lazy_interpolate!(FEFunction2[1], FEFunction1; use_cellparents = true)\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1, 2), clear = true, resolution = (800, 400))\n    scalarplot!(p[1, 1], xgrid1, view(nodevalues(FEFunction1[1]), 1, :), levels = 11, title = \"u_h ($FEType1, coarse grid)\")\n    scalarplot!(p[1, 2], xgrid2, view(nodevalues(FEFunction2[1]), 1, :), levels = 11, title = \"u_h ($FEType2, fine grid)\")\n\n    return p\nend\n\nfunction generateplots(dir = pwd(); Plotter = nothing, kwargs...)\n    plt = main(; Plotter = Plotter, kwargs...)\n    scene = GridVisualize.reveal(plt)\n    return GridVisualize.save(joinpath(dir, \"example290.png\"), scene; Plotter = Plotter)\nend\n\nend","category":"page"},{"location":"module_examples/Example290_InterpolationBetweenMeshes/","page":"Example290_InterpolationBetweenMeshes","title":"Example290_InterpolationBetweenMeshes","text":"","category":"page"},{"location":"module_examples/Example290_InterpolationBetweenMeshes/","page":"Example290_InterpolationBetweenMeshes","title":"Example290_InterpolationBetweenMeshes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fems/#Implemented-Finite-Elements","page":"List of Finite Elements","title":"Implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"This page provides an overview of the finite element type hierarchy and lists all finite elements currently implemented in ExtendableFEMBase.","category":"page"},{"location":"fems/#The-Finite-Element-Type-Hierarchy","page":"List of Finite Elements","title":"The Finite Element Type Hierarchy","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Finite elements in ExtendableFEMBase are organized as leaves in an abstract type hierarchy. The complete type tree is as follows:","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"AbstractFiniteElement\n├─ AbstractH1FiniteElement\n│  ├─ AbstractH1FiniteElementWithCoefficients\n│  │  ├─ H1P1TEB\n│  │  └─ H1BR\n│  ├─ H1CR\n│  ├─ H1MINI\n│  ├─ L2P0\n│  ├─ L2P1\n│  ├─ H1P1\n│  ├─ H1P2\n│  ├─ H1P2B\n│  ├─ H1P3\n│  ├─ H1Pk\n│  ├─ H1Q1\n│  └─ H1Q2\n├─ AbstractHcurlFiniteElement\n│  ├─ HCURLN0\n│  └─ HCURLN1\n└─ AbstractHdivFiniteElement\n   ├─ HDIVBDM1\n   ├─ HDIVBDM2\n   ├─ HDIVRT0\n   ├─ HDIVRT1\n   ├─ HDIVRTk\n   └─ HDIVRTkENRICH","category":"page"},{"location":"fems/#Remarks","page":"List of Finite Elements","title":"Remarks","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Each finite element type depends on one, two, or three parameters. The first parameter is always the number of components (ncomponents), which determines whether the element is scalar- or vector-valued. Some elements also require the parameter edim <: Int if their structure differs by spatial dimension. Arbitrary order elements require a third parameter specifying the polynomial order.\nEach finite element provides a set of basis functions in reference coordinates for each applicable AbstractElementGeometry, as well as degree-of-freedom (dof) maps for each mesh entity.\nDiscontinuous (broken) finite elements can be created using the broken switch in the FESpace constructor.\nThe element type determines how basis functions are transformed from local to global coordinates and how FunctionOperators are evaluated.\nAdditional continuity properties of element types lead to more specialized basis function sets:\nAbstractH1FiniteElement types provide evaluations of nonzero basis functions on faces/boundary faces.\nAbstractHdivFiniteElement types provide evaluations of nonzero normal fluxes of basis functions on faces/boundary faces.\nAbstractHcurlFiniteElement types provide evaluations of nonzero tangential fluxes of basis functions on edges/boundary edges.\nEach finite element has its own standard interpolation routine interpolate! (see Finite Element Interpolations), which can be applied to a function with the signature function(result, qpinfo). The specific interpolation behavior is described for each element below.","category":"page"},{"location":"fems/#List-of-Implemented-Finite-Elements","page":"List of Finite Elements","title":"List of Implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The following table summarizes all finite elements currently implemented in ExtendableFEMBase and indicates the reference geometries on which they are available. For each entry, the dofmap pattern for cell degrees of freedom is shown in brackets, along with the number of local degrees of freedom for a vector-valued realization. Click on an FEType to view more details.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"FEType Triangle2D Parallelogram2D Tetrahedron3D Parallelepiped3D\nAbstractH1FiniteElementWithCoefficients    \nH1BR ✓ (N1f1, 9) ✓ (N1f1, 12) ✓ (N1f1, 16) \nH1P1TEB ✓ (N1f1, 9)  ✓ (N1e1, 18) \nAbstractH1FiniteElement    \nH1BUBBLE ✓ (I1, 2) ✓ (I1, 2) ✓ (I1, 3) \nH1CR ✓ (F1, 6) ✓ (F1, 8) ✓ (F1, 12) \nH1MINI ✓ (N1I1, 8) ✓ (N1I1, 10) ✓ (N1I1, 15) \nL2P0 ✓ (I1, 2) ✓ (I1, 2) ✓ (I1, 3) ✓ (I1, 3)\nL2P1 ✓ (I3, 6) ✓ (I3, 6) ✓ (I4, 12) ✓ (I4, 12)\nH1P1 ✓ (N1, 6)  ✓ (N1, 12) \nH1P2 ✓ (N1F1, 12)  ✓ (N1E1, 30) \nH1P2B ✓ (N1F1I1, 14)   \nH1P3 ✓ (N1F2I1, 20)  ✓ (N1E2F1, 60) \nH1Pk ✓ (order-dep)   \nH1Q1 ✓ (N1, 6) ✓ (N1, 8) ✓ (N1, 12) ✓ (N1, 24)\nH1Q2 ✓ (N1F1, 12) ✓ (N1F1I1, 18) ✓ (N1E1, 30) \nAbstractHcurlFiniteElement    \nHCURLN0 ✓ (f1, 3) ✓ (f1, 4) ✓ (e1, 6) \nHCURLN1 ✓ (f1, 6)   \nAbstractHdivFiniteElement    \nHDIVBDM1 ✓ (f2, 6) ✓ (f2, 8) ✓ (f3, 12) \nHDIVBDM2 ✓ (f3i3, 12)   \nHDIVRT0 ✓ (f1, 3) ✓ (f1, 4) ✓ (f1, 4) ✓ (f1, 6)\nHDIVRT1 ✓ (f2i2, 8)  ✓ (f3i3, 15) \nHDIVRTk ✓ (order-dep)   \nHDIVRTkENRICH ✓ (order-dep)  ✓ (order-dep) ","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Note: The dofmap pattern describes how local degrees of freedom are associated with grid entities and provides insight into the continuity properties of the element. Here, \"N\" or \"n\" denotes nodes, \"F\" or \"f\" denotes faces, \"E\" or \"e\" denotes edges, and \"I\" denotes interior degrees of freedom (i.e., those without continuity across elements). Capital letters indicate that each component has its own degree of freedom, while lowercase letters mean only one degree of freedom is associated with the entity. For example, \"N1f1\" (as in the Bernardi-Raugel element) means that each node has one dof per component and each face has a single dof. Typically, finite elements involving lowercase letters are only defined for vector-valued cases (i.e., the number of components must match the element dimension), while those with only capital letters are available for any number of components.","category":"page"},{"location":"fems/#H1-conforming-finite-elements","page":"List of Finite Elements","title":"H1-conforming finite elements","text":"","category":"section"},{"location":"fems/#P0-finite-element","page":"List of Finite Elements","title":"P0 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Piecewise constant finite element that has one degree of freedom on each cell of the grid. (It is masked as a H1-conforming finite element, because it uses the same operator evaluations.)","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space preserves the cell integrals.","category":"page"},{"location":"fems/#ExtendableFEMBase.L2P0","page":"List of Finite Elements","title":"ExtendableFEMBase.L2P0","text":"abstract type L2P0{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nPiecewise constant polynomials on cells.\n\nallowed ElementGeometries:\n\nany\n\n\n\n\n\n","category":"type"},{"location":"fems/#P1-finite-element","page":"List of Finite Elements","title":"P1 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The lowest-order Courant finite element that has a degree of freedom on each vertex of the grid. On simplices the basis functions coincide with the linear barycentric coordinates. Only the L2P1 element is also defined on quads.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes.","category":"page"},{"location":"fems/#ExtendableFEMBase.L2P1","page":"List of Finite Elements","title":"ExtendableFEMBase.L2P1","text":"abstract type L2P1{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nDiscontinuous piecewise first-order linear polynomials (same as H1P1 but enforces broken = true).\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.H1P1","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P1","text":"abstract type H1P1{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nContinuous piecewise first-order linear polynomials.\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Q1-finite-element","page":"List of Finite Elements","title":"Q1 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The lowest-order finite element that has a degree of freedom on each vertex of the grid. On simplices the basis functions coincide with the linear barycentric coordinates. This element is also defined on quads.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes.","category":"page"},{"location":"fems/#ExtendableFEMBase.H1Q1","page":"List of Finite Elements","title":"ExtendableFEMBase.H1Q1","text":"abstract type Q1P1{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nContinuous piecewise first-order polynomials on simplices and quads, can be used for mixed geometries.\n\nallowed ElementGeometries:\n\nEdge1D (P1 space)\nTriangle2D (P1 space)\nQuadrilateral2D (Q1 space)\nTetrahedron3D (P1 space)\nHexahedron3D (Q1 space)\n\n\n\n\n\n","category":"type"},{"location":"fems/#MINI-finite-element","page":"List of Finite Elements","title":"MINI finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The mini finite element adds cell bubles to the P1 element that are e.g. beneficial to define inf-sup stable finite element pairs for the Stokes problem.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its cell integral.","category":"page"},{"location":"fems/#ExtendableFEMBase.H1MINI","page":"List of Finite Elements","title":"ExtendableFEMBase.H1MINI","text":"abstract type H1MINI{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nMini finite element.\n\nallowed element geometries:\n\nTriangle2D (linear polynomials + cubic cell bubble)\nQuadrilateral2D (Q1 space + quartic cell bubble)\nTetrahedron3D (linear polynomials + cubic cell bubble)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P1TEB-finite-element","page":"List of Finite Elements","title":"P1TEB finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"This element adds tangent-weighted edge bubbles to the P1 finite element and therefore is only available as a vector-valued element.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves face integrals of its tangential flux.","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P1TEB","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P1TEB","text":"abstract type H1P1TEB{edim} <: AbstractH1FiniteElementWithCoefficients where {edim<:Int}\n\nvector-valued (ncomponents = edim) element that uses P1 functions + tangential-weighted edge bubbles as suggested by [Diening, L., Storn, J. & Tscherpel, T., \"Fortin operator for the Taylor–Hood element\", Num. Math. 150, 671–689 (2022)]\n\n(is inf-sup stable for Stokes if paired with continuous P1 pressure space, less degrees of freedom than MINI)\n\nallowed ElementGeometries:\n\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Bernardi-Raugel-(BR)-finite-element","page":"List of Finite Elements","title":"Bernardi-Raugel (BR) finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The Bernardi-Raugel adds normal-weighted face bubbles to the P1 finite element and therefore is only available as a vector-valued element.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves face integrals of its normal flux.","category":"page"},{"location":"fems/#ExtendableFEMBase.H1BR","page":"List of Finite Elements","title":"ExtendableFEMBase.H1BR","text":"abstract type H1BR{edim} <: AbstractH1FiniteElementWithCoefficients where {edim<:Int}\n\nvector-valued (ncomponents = edim) Bernardi–Raugel element (first-order polynomials + normal-weighted face bubbles)\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear + normal-weighted face bubbles)\nQuadrilateral2D (Q1 space + normal-weighted face bubbles)\nTetrahedron3D (piecewise linear + normal-weighted face bubbles)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P2-finite-element","page":"List of Finite Elements","title":"P2 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The P2 finite element method on simplices equals quadratic polynomials. On the Triangle2D shape the degrees of freedom are associated with the three vertices and the three faces of the triangle. On the Tetrahedron3D shape the degrees of freedom are associated with the four verties and the six edges.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its face/edge integrals in 2D/3D.","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P2","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P2","text":"abstract type H1P2{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Q2-finite-element","page":"List of Finite Elements","title":"Q2 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"A second order finite element. On simplices it equals the P2 finite element, and on Quadrilateral2D it has 9 degrees of freedom (vertices, faces and one cell bubble).","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves lowest order face moments and (only on quads) also the cell integreal mean.","category":"page"},{"location":"fems/#ExtendableFEMBase.H1Q2","page":"List of Finite Elements","title":"ExtendableFEMBase.H1Q2","text":"abstract type H1Q2{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials on simplices and quads. Can be used with mixed geometries (in 2D).\n\nallowed ElementGeometries:\n\nEdge1D (P2 space)\nTriangle2D (P2 space)\nQuadrilateral2D (Q2 space with cell bubble)\nTetrahedron3D (P2 space)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P2B-finite-element","page":"List of Finite Elements","title":"P2B finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The P2B finite element adds additional cell bubles (in 2D and 3D) and face bubbles (only in 3D) that are e.g. used to define inf-sup stable finite element pairs for the Stokes problem.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its cell and face integrals in 2D and also edge integrals in 3D.","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P2B","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P2B","text":"abstract type H1P2B{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials.\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#P3-finite-element","page":"List of Finite Elements","title":"P3 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The P3 finite element method on simplices equals cubic polynomials. On the Triangle2D shape the degrees of freedom are associated with the three vertices, the three faces (double dof) of the triangle and the cell itself (one cell bubble).","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves cell and face integrals in 2D.","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P3","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P3","text":"abstract type H1P3{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise third-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Pk-finite-element-(experimental)","page":"List of Finite Elements","title":"Pk finite element (experimental)","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The Pk finite element method generically generates polynomials of arbitrary order k on simplices (Edge1D, Triangle2D so far).","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves cell and face integrals in 2D (moment order depends on the order and the element dimension).","category":"page"},{"location":"fems/#ExtendableFEMBase.H1Pk","page":"List of Finite Elements","title":"ExtendableFEMBase.H1Pk","text":"abstract type H1PK{ncomponents,edim,order} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int,order<:Int}\n\nContinuous piecewise polynomials of arbitrary order >= 1 with ncomponents components in edim space dimensions.\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Crouzeix-Raviart-(CR)-finite-element","page":"List of Finite Elements","title":"Crouzeix-Raviart (CR) finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The Crouzeix-Raviart element associates one lowest-order function with each face. On the Triangle2D shape, the basis function of a face is one minus two times the nodal basis function of the opposite node. ","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space preserves its face integrals.","category":"page"},{"location":"fems/#ExtendableFEMBase.H1CR","page":"List of Finite Elements","title":"ExtendableFEMBase.H1CR","text":"abstract type H1CR{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nCrouzeix-Raviart element (only continuous at face centers).\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear, similar to P1)\nQuadrilateral2D (similar to Q1 space)\nTetrahedron3D (piecewise linear, similar to P1)\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hdiv-conforming-finite-elements","page":"List of Finite Elements","title":"Hdiv-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"These Raviart-Thomas and Brezzi-Douglas-Marini finite elements of lower order and their standard interpolations are available:","category":"page"},{"location":"fems/#ExtendableFEMBase.HDIVRT0","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVRT0","text":"abstract type HDIVRT0{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Raviart-Thomas space.\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\nHexahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVBDM1","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVBDM1","text":"abstract type HDIVBDM1{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Brezzi-Douglas-Marini space\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVRT1","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVRT1","text":"abstract type HDIVRT1{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) Raviart-Thomas space of order 1.\n\nallowed ElementGeometries:\n\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVBDM2","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVBDM2","text":"abstract type HDIVBDM2{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) Brezzi-Douglas-Marini space of order 2\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVRTk","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVRTk","text":"abstract type HDIVRTk{edim, order} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) Raviart-Thomas space of arbitrary order.\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVRTkENRICH","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVRTkENRICH","text":"abstract type HDIVRTkENRICH{k,edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nInternal (normal-zero) Hdiv-conforming vector-valued (ncomponents = edim) Raviart-Thomas space of order k ≥ 1 with the additional orthogonality property that their divergences are L2-orthogonal on P_{k-edim+1}. Example: HDIVRTkENRICH{1,2} gives the edim interior RT1 bubbles (= normal-trace-free) on a triangle, their divergences have integral mean zero; HDIVRTkENRICH{2,2} gives three RT2 bubbles on a triangle whose divergences are L2-orthogonal onto all P1 functions. The maximal order for k is 4 on a Triangle2D (edim = 2) and 3 on Tetrahedron3D (edim = 3). These spaces have no approximation power on their own, but can be used as enrichment spaces in divergence-free schemes for incompressible Stokes problems.\n\nallowed ElementGeometries:\n\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hcurl-conforming-finite-elements","page":"List of Finite Elements","title":"Hcurl-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"So far only the lowest order Nedelec element is available in 2D and 3D. On Triangle2D it has one degree of freedom for each face (i.e. the rotated RT0 element), on Tetrahedron3D it has one degree of freedom associated to each of the six edges.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Its standard interpolation of a given functions preserves its tangential face/edge integrals.","category":"page"},{"location":"fems/#ExtendableFEMBase.HCURLN0","page":"List of Finite Elements","title":"ExtendableFEMBase.HCURLN0","text":"abstract type HCURLN0{edim} <: AbstractHcurlFiniteElement where {edim<:Int}\n\nHcurl-conforming vector-valued (ncomponents = edim) lowest-order Nedelec space of first kind.\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HCURLN1","page":"List of Finite Elements","title":"ExtendableFEMBase.HCURLN1","text":"abstract type HCURLN1{edim} <: AbstractHcurlFiniteElement where {edim<:Int}\n\nHcurl-conforming vector-valued (ncomponents = edim) Nedelec space of first kind and order 1.\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Incomplete-finite-elements-without-approximation-power","page":"List of Finite Elements","title":"Incomplete finite elements without approximation power","text":"","category":"section"},{"location":"fems/#ExtendableFEMBase.H1BUBBLE","page":"List of Finite Elements","title":"ExtendableFEMBase.H1BUBBLE","text":"abstract type H1BUBBLE{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nPiecewise bubbles (=zero at boundary)\n\nallowed element geometries:\n\nEdge1D (one quadratic bubble)\nTriangle2D (one cubic bubble)\nQuadrilateral2D (one quartic bubble)\nTetrahedron3D (one cubic bubble)\n\n\n\n\n\n","category":"type"},{"location":"notebooks_intro/#About-the-notebooks","page":"About the notebooks","title":"About the notebooks","text":"","category":"section"},{"location":"notebooks_intro/","page":"About the notebooks","title":"About the notebooks","text":"This sections contains Pluto.jl notebooks.","category":"page"},{"location":"notebooks_intro/","page":"About the notebooks","title":"About the notebooks","text":"Please note, that in the html version, interactive elements like sliders are disabled. Navigation via the table of contents does work, though.","category":"page"},{"location":"module_examples/Example205_LowLevelSpaceTimePoisson/#205-:-Space-Time-FEM-for-Heat-Equation","page":"Example205_LowLevelSpaceTimePoisson","title":"205 : Space-Time FEM for Heat Equation","text":"","category":"section"},{"location":"module_examples/Example205_LowLevelSpaceTimePoisson/","page":"Example205_LowLevelSpaceTimePoisson","title":"Example205_LowLevelSpaceTimePoisson","text":"(source code)","category":"page"},{"location":"module_examples/Example205_LowLevelSpaceTimePoisson/","page":"Example205_LowLevelSpaceTimePoisson","title":"Example205_LowLevelSpaceTimePoisson","text":"This example computes the solution u of the two-dimensional heat equation","category":"page"},{"location":"module_examples/Example205_LowLevelSpaceTimePoisson/","page":"Example205_LowLevelSpaceTimePoisson","title":"Example205_LowLevelSpaceTimePoisson","text":"beginaligned\nu_t - Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example205_LowLevelSpaceTimePoisson/","page":"Example205_LowLevelSpaceTimePoisson","title":"Example205_LowLevelSpaceTimePoisson","text":"with a (possibly space- and time-depepdent) right-hand side f and homogeneous Dirichlet boundary and initial conditions on the unit square domain Omega on a given grid with space-time finite element methods based on tensorized ansatz functions.","category":"page"},{"location":"module_examples/Example205_LowLevelSpaceTimePoisson/","page":"Example205_LowLevelSpaceTimePoisson","title":"Example205_LowLevelSpaceTimePoisson","text":"(Image: )","category":"page"},{"location":"module_examples/Example205_LowLevelSpaceTimePoisson/","page":"Example205_LowLevelSpaceTimePoisson","title":"Example205_LowLevelSpaceTimePoisson","text":"module Example205_LowLevelSpaceTimePoisson\n\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\nusing UnicodePlots\nusing Test #\n\n# data for Poisson problem\nconst μ = (t) -> 1.0e-1 * t + 1 * max(0, (1 - 2 * t))\nconst f = (x, t) -> sin(3 * pi * x[1]) * 4 * t - cos(3 * pi * x[2]) * 4 * (1 - t)\n\nfunction main(; dt = 0.01, Tfinal = 1, level = 5, order = 1, Plotter = nothing, produce_movie = false)\n\n    # Finite element type\n    FEType_time = H1Pk{1, 1, order}\n    FEType_space = H1Pk{1, 2, order}\n\n    # time grid\n    T = LinRange(0, Tfinal, round(Int, Tfinal / dt + 1))\n    grid_time = simplexgrid(T)\n\n    # space grid\n    X = LinRange(0, 1, 2^level + 1)\n    grid_space = simplexgrid(X, X)\n\n    # FESpaces for time and space\n    FES_time = FESpace{FEType_time}(grid_time)\n    FES_space = FESpace{FEType_space}(grid_space)\n\n    # solve\n    sol = solve_poisson_lowlevel(FES_time, FES_space, μ, f)\n\n    # visualize\n    if produce_movie\n        @info \"Producing movie...\"\n        vis = GridVisualizer(Plotter = Plotter)\n        movie(vis, file = \"example205_video.mp4\") do vis\n            for tj in 2:length(T)\n                t = T[tj]\n                first = (tj - 1) * FES_space.ndofs + 1\n                last = tj * FES_space.ndofs\n                scalarplot!(vis, grid_space, view(sol, first:last), title = \"t = $(Float16(t))\")\n                reveal(vis)\n            end\n        end\n        return sol, vis\n    else\n        @info \"Plotting at five times...\"\n        plot_timesteps = [2, round(Int, length(T) / 4 + 0.25), round(Int, length(T) / 2 + 0.5), round(Int, length(T) - length(T) / 4), FES_time.ndofs]\n        plt = GridVisualizer(; Plotter = Plotter, layout = (1, length(plot_timesteps)), clear = true, resolution = (200 * length(plot_timesteps), 200))\n        for tj in 1:length(plot_timesteps)\n            t = plot_timesteps[tj]\n            first = (t - 1) * FES_space.ndofs + 1\n            last = t * FES_space.ndofs\n            scalarplot!(plt[1, tj], grid_space, view(sol, first:last), title = \"t = $(T[t])\")\n        end\n        return sol, plt\n    end\n\nend\n\n\nfunction solve_poisson_lowlevel(FES_time, FES_space, μ, f)\n    ndofs_time = FES_time.ndofs\n    ndofs_space = FES_space.ndofs\n    ndofs_total = ndofs_time * ndofs_space\n    sol = zeros(Float64, ndofs_total)\n\n    A = ExtendableSparseMatrix{Float64, Int64}(ndofs_total, ndofs_total)\n    b = zeros(Float64, ndofs_total)\n\n    println(\"Assembling...\")\n    time_assembly = @elapsed @time begin\n        loop_allocations = assemble!(A, b, FES_time, FES_space, f, μ)\n\n        # fix homogeneous boundary dofs\n        bdofs = boundarydofs(FES_space)\n        for sdof in bdofs\n            for dof_t in 1:ndofs_time\n                dof = (dof_t - 1) * ndofs_space + sdof\n                A[dof, dof] = 1.0e60\n                b[dof] = 0\n            end\n        end\n\n        # fix initial value by zero\n        for j in 1:ndofs_space\n            A[j, j] = 1.0e60\n            b[j] = 0\n        end\n        ExtendableSparse.flush!(A)\n    end\n\n    @info \".... spy plot of system matrix:\\n$(UnicodePlots.spy(sparse(A.cscmatrix)))\"\n\n    # solve\n    println(\"Solving linear system...\")\n    time_solve = @elapsed @time copyto!(sol, A \\ b)\n\n    # compute linear residual\n    @show norm(A * sol - b)\n\n    return sol\nend\n\nfunction assemble!(A::ExtendableSparseMatrix, b::Vector, FES_time, FES_space, f, μ = 1)\n\n    # get space and time grids\n    grid_time = FES_time.xgrid\n    grid_space = FES_space.xgrid\n\n    # get number of degrees of freedom\n    ndofs_time = FES_time.ndofs\n    ndofs_space = FES_space.ndofs\n\n    # get local to global maps\n    EG_time = grid_time[UniqueCellGeometries][1]\n    EG_space = grid_space[UniqueCellGeometries][1]\n    L2G_time = L2GTransformer(EG_time, grid_time, ON_CELLS)\n    L2G_space = L2GTransformer(EG_space, grid_space, ON_CELLS)\n\n    # get finite element types\n    FEType_time = eltype(FES_time)\n    FEType_space = eltype(FES_space)\n\n    # quadrature formula in space\n    qf_space = QuadratureRule{Float64, EG_space}(2 * (get_polynomialorder(FEType_space, EG_space) - 1))\n    weights_space::Vector{Float64} = qf_space.w\n    xref_space::Vector{Vector{Float64}} = qf_space.xref\n    nweights_space::Int = length(weights_space)\n    cellvolumes_space = grid_space[CellVolumes]\n\n    # quadrature formula in time\n    qf_time = QuadratureRule{Float64, EG_time}(2 * (get_polynomialorder(FEType_time, EG_time) - 1))\n    weights_time::Vector{Float64} = qf_time.w\n    xref_time::Vector{Vector{Float64}} = qf_time.xref\n    nweights_time::Int = length(weights_time)\n    cellvolumes_time = grid_time[CellVolumes]\n\n    # FE basis evaluators and dofmap for space elements\n    FEBasis_space_∇ = FEEvaluator(FES_space, Gradient, qf_space)\n    ∇vals_space = FEBasis_space_∇.cvals\n    FEBasis_space_id = FEEvaluator(FES_space, Identity, qf_space)\n    idvals_space = FEBasis_space_id.cvals\n    celldofs_space = FES_space[ExtendableFEMBase.CellDofs]\n\n    # FE basis evaluators and dofmap for time elements\n    FEBasis_time_∇ = FEEvaluator(FES_time, Gradient, qf_time)\n    ∇vals_time = FEBasis_time_∇.cvals\n    FEBasis_time_id = FEEvaluator(FES_time, Identity, qf_time)\n    idvals_time = FEBasis_time_id.cvals\n    celldofs_time = FES_time[ExtendableFEMBase.CellDofs]\n\n    # ASSEMBLY LOOP\n    loop_allocations = 0\n    function barrier(EG_time, EG_space, L2G_time::L2GTransformer, L2G_space::L2GTransformer)\n        # barrier function to avoid allocations by type dispatch\n\n        ndofs4cell_time::Int = get_ndofs(ON_CELLS, FEType_time, EG_time)\n        ndofs4cell_space::Int = get_ndofs(ON_CELLS, FEType_space, EG_space)\n        Aloc = zeros(Float64, ndofs4cell_space, ndofs4cell_space)\n        Mloc = zeros(Float64, ndofs4cell_time, ndofs4cell_time)\n        ncells_space::Int = num_cells(grid_space)\n        ncells_time::Int = num_cells(grid_time)\n        x::Vector{Float64} = zeros(Float64, 2)\n        t::Vector{Float64} = zeros(Float64, 1)\n\n        # assemble Laplacian\n        loop_allocations += @allocated for cell in 1:ncells_space\n            # update FE basis evaluators for space\n            FEBasis_space_∇.citem[] = cell\n            update_basis!(FEBasis_space_∇)\n\n            # assemble local stiffness matrix in space\n            for j in 1:ndofs4cell_space, k in 1:ndofs4cell_space\n                temp = 0\n                for qp in 1:nweights_space\n                    temp += weights_space[qp] * dot(view(∇vals_space, :, j, qp), view(∇vals_space, :, k, qp))\n                end\n                Aloc[j, k] = temp\n            end\n            Aloc .*= cellvolumes_space[cell]\n\n            # add local matrix to global matrix\n            for time_cell in 1:ncells_time\n                update_trafo!(L2G_time, time_cell)\n                for jT in 1:ndofs4cell_time, kT in 1:ndofs4cell_time\n                    dofTj = celldofs_time[jT, time_cell]\n                    dofTk = celldofs_time[kT, time_cell]\n                    for qpT in 1:nweights_time\n                        # evaluate time coordinate and μ\n                        eval_trafo!(t, L2G_time, xref_time[qpT])\n                        factor = μ(t[1]) * weights_time[qpT] * idvals_time[1, jT, qpT] * idvals_time[1, kT, qpT] * cellvolumes_time[time_cell]\n                        for j in 1:ndofs4cell_space\n                            dof_j = celldofs_space[j, cell] + (dofTj - 1) * ndofs_space\n                            for k in 1:ndofs4cell_space\n                                dof_k = celldofs_space[k, cell] + (dofTk - 1) * ndofs_space\n                                if abs(Aloc[j, k]) > 1.0e-15\n                                    # write into sparse matrix, only lines with allocations\n                                    rawupdateindex!(A, +, Aloc[j, k] * factor, dof_j, dof_k)\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n            fill!(Aloc, 0)\n\n            # assemble right-hand side\n            update_trafo!(L2G_space, cell)\n            for qp in 1:nweights_space\n                # evaluate coordinates of quadrature point in space\n                eval_trafo!(x, L2G_space, xref_space[qp])\n                for time_cell in 1:ncells_time\n                    update_trafo!(L2G_time, time_cell)\n                    for qpT in 1:nweights_time\n                        # evaluate time coordinate\n                        eval_trafo!(t, L2G_time, xref_time[qpT])\n\n                        # evaluate right-hand side in x and t\n                        fval = f(x, t[1])\n\n                        # multiply with test function and add to right-hand side\n                        for j in 1:ndofs4cell_space\n                            temp = weights_time[qpT] * weights_space[qp] * idvals_space[1, j, qp] * fval * cellvolumes_space[cell] * cellvolumes_time[time_cell]\n\n                            # write into global vector\n                            for jT in 1:ndofs4cell_time\n                                dof_j = celldofs_space[j, cell] + (celldofs_time[jT, time_cell] - 1) * ndofs_space\n                                b[dof_j] += temp * idvals_time[1, jT, qpT]\n                            end\n                        end\n                    end\n                end\n            end\n        end\n\n        # assemble time derivative\n        return loop_allocations += @allocated for time_cell in 1:ncells_time\n            # update FE basis evaluators for time derivative\n            FEBasis_time_∇.citem[] = time_cell\n            update_basis!(FEBasis_time_∇)\n\n            # assemble local convection term in time\n            for j in 1:ndofs4cell_time, k in 1:ndofs4cell_time\n                temp = 0\n                for qpT in 1:nweights_time\n                    temp += weights_time[qpT] * dot(view(∇vals_time, :, j, qpT), view(∇vals_time, :, k, qpT))\n                end\n                Mloc[j, k] = temp\n            end\n            Mloc .*= cellvolumes_time[time_cell]\n\n            # add local matrix to global matrix\n            for cell in 1:ncells_space\n                for jX in 1:ndofs4cell_space, kX in 1:ndofs4cell_space\n                    dofXj = celldofs_space[jX, cell]\n                    dofXk = celldofs_space[kX, cell]\n                    for qpX in 1:nweights_space\n                        factor = weights_space[qpX] * idvals_space[1, jX, qpX] * idvals_space[1, kX, qpX] * cellvolumes_space[cell]\n                        for j in 1:ndofs4cell_time\n                            dof_j = dofXj + (celldofs_time[j, time_cell] - 1) * ndofs_space\n                            for k in 1:ndofs4cell_time\n                                dof_k = dofXk + (celldofs_time[k, time_cell] - 1) * ndofs_space\n                                if abs(Mloc[j, k]) > 1.0e-15\n                                    # write into sparse matrix, only lines with allocations\n                                    rawupdateindex!(A, +, Mloc[j, k] * factor, dof_j, dof_k)\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n            fill!(Mloc, 0)\n        end\n    end\n    barrier(EG_time, EG_space, L2G_time, L2G_space)\n    flush!(A)\n    return loop_allocations\nend\n\nfunction generateplots(dir = pwd(); Plotter = nothing, kwargs...)\n    ~, plt = main(; Plotter = Plotter, kwargs...)\n    scene = GridVisualize.reveal(plt)\n    return GridVisualize.save(joinpath(dir, \"example205.png\"), scene; Plotter = Plotter)\nend\n\nend #module","category":"page"},{"location":"module_examples/Example205_LowLevelSpaceTimePoisson/","page":"Example205_LowLevelSpaceTimePoisson","title":"Example205_LowLevelSpaceTimePoisson","text":"","category":"page"},{"location":"module_examples/Example205_LowLevelSpaceTimePoisson/","page":"Example205_LowLevelSpaceTimePoisson","title":"Example205_LowLevelSpaceTimePoisson","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build status) (Image: ) (Image: ) (Image: DOI)","category":"page"},{"location":"#ExtendableFEMBase.jl","page":"Home","title":"ExtendableFEMBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExtendableFEMBase.jl provides foundational data structures and tools for building custom finite element solvers in Julia. The package includes flexible representations for finite element spaces, interpolators, matrices, and vectors, all designed to work seamlessly with the ExtendableGrids.jl infrastructure.","category":"page"},{"location":"#Dependencies-on-other-Julia-packages","page":"Home","title":"Dependencies on other Julia packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExtendableGrids.jl\nExtendableSparse.jl\nForwardDiff.jl\nDiffResults.jl\nUnicodePlots.jl\nDocStringExtensions.jl","category":"page"}]
}
