var documenterSearchIndex = {"docs":
[{"location":"fematrix/#FEMatrix","page":"FEMatrix","title":"FEMatrix","text":"","category":"section"},{"location":"fematrix/","page":"FEMatrix","title":"FEMatrix","text":"A FEMatrix consists of FEMatrixBlocks that share a common ExtendableSparseMatrix. Each block is associated to two FESpaces and can only write into a submatrix of the common sparse matrix specified by offsets.","category":"page"},{"location":"fematrix/","page":"FEMatrix","title":"FEMatrix","text":"Modules = [ExtendableFEMBase]\nPages = [\"fematrix.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fematrix/#ExtendableFEMBase.FEMatrix","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrix","text":"struct FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal} <: SparseArrays.AbstractSparseArray{TvM, TiM, 2}\n\nan AbstractMatrix (e.g. an ExtendableSparseMatrix) with an additional layer of several FEMatrixBlock subdivisions each carrying coefficients for their associated pair of FESpaces\n\n\n\n\n\n","category":"type"},{"location":"fematrix/#ExtendableFEMBase.FEMatrix-Tuple{FESpace, FESpace}","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrix","text":"FEMatrix{TvM,TiM}(FESX, FESY; name = \"auto\")\n\nCreates FEMatrix with one rectangular block (FESX,FESY) if FESX and FESY are single FESpaces, or a rectangular block matrix with blocks corresponding to the entries of the FESpace vectors FESX and FESY. Optionally a name for the matrix can be given.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.FEMatrix-Tuple{FESpace}","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrix","text":"FEMatrix{TvM,TiM}(name::String, FES::FESpace{TvG,TiG,FETypeX,APTX}) where {TvG,TiG,FETypeX,APTX}\n\nCreates FEMatrix with one square block (FES,FES).\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.FEMatrix-Union{Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}, Tuple{Vector{<:FESpace{TvG, TiG}}, Vector{<:FESpace{TvG, TiG}}}} where {TvM, TiM, TvG, TiG}","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrix","text":"FEMatrix{TvM,TiM}(FESX, FESY; name = \"auto\")\n\nCreates an FEMatrix with blocks coressponding to the ndofs of FESX (rows) and FESY (columns).\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.FEMatrixBlock","page":"FEMatrix","title":"ExtendableFEMBase.FEMatrixBlock","text":"struct FEMatrixBlock{TvM, TiM, TvG, TiG, FETypeX, FETypeY, APTX, APTY} <: AbstractArray{TvM, 2}\n\nblock of an FEMatrix that carries coefficients for an associated pair of FESpaces and can be assigned as an two-dimensional AbstractArray (getindex, setindex, size)\n\n\n\n\n\n","category":"type"},{"location":"fematrix/#Base.fill!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv, Ti}, Any}} where {Tv, Ti}","page":"FEMatrix","title":"Base.fill!","text":"fill!(B::FEMatrixBlock{Tv, Ti}, value)\n\n\nCustom fill function for FEMatrixBlock (only fills the already present nzval in the block, not the complete FEMatrix).\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.length-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"Base.length","text":"length(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Any\n\n\nCustom length function for FEMatrix that gives the total number of defined FEMatrixBlocks in it\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.show-Union{Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}, Tuple{IO, FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"Base.show","text":"show(\n    io::IO,\n    FEM::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n)\n\n\nCustom show function for FEMatrix that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.size-Tuple{FEMatrixBlock}","page":"FEMatrix","title":"Base.size","text":"size(FEB::FEMatrixBlock) -> Tuple{Int64, Int64}\n\n\nCustom size function for FEMatrixBlock that gives a tuple with the size of the block (that coressponds to the number of degrees of freedoms in X and Y)\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#Base.size-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"Base.size","text":"size(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Tuple{Any, Any}\n\n\nCustom size function for FEMatrix that gives a tuple with the number of rows and columns of the FEBlock overlay\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.add!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrix{Tv, Ti}, FEMatrix{Tv, Ti}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.add!","text":"add!(A::FEMatrix{Tv, Ti}, B::FEMatrix{Tv, Ti}; kwargs...)\n\n\nAdds FEMatrix/ExtendableSparseMatrix/CSCMatrix B to FEMatrix A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv, Ti}, FEMatrixBlock{Tv, Ti}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    A::FEMatrixBlock{Tv, Ti},\n    B::FEMatrixBlock{Tv, Ti};\n    factor,\n    transpose\n)\n\n\nAdds FEMatrixBlock B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv}, ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    A::FEMatrixBlock{Tv},\n    B::ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti<:Integer};\n    factor,\n    transpose\n)\n\n\nAdds ExtendableSparseMatrix B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv}, SparseArrays.SparseMatrixCSC{Tv, Ti}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    A::FEMatrixBlock{Tv},\n    cscmat::SparseArrays.SparseMatrixCSC{Tv, Ti<:Integer};\n    factor,\n    transpose\n)\n\n\nAdds SparseMatrixCSC B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, FEMatrixBlock{Tv, Ti}, AbstractVector{Tv}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    a::AbstractArray{Tv, 1},\n    B::FEMatrixBlock{Tv, Ti},\n    b::AbstractArray{Tv, 1};\n    factor,\n    transposed\n)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv}, SparseArrays.SparseMatrixCSC{Tv, Ti}, SparseArrays.SparseMatrixCSC{Tv, Ti}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    A::FEMatrixBlock{Tv},\n    cscmatB::SparseArrays.SparseMatrixCSC{Tv, Ti},\n    cscmatC::SparseArrays.SparseMatrixCSC{Tv, Ti};\n    factor,\n    transposed\n)\n\n\nAdds matrix-matrix product B times C to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEVectorBlock{Tv}, ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti}, FEVectorBlock{Tv}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    a::FEVectorBlock{Tv},\n    B::ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti<:Integer},\n    b::FEVectorBlock{Tv};\n    factor\n)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEVectorBlock{Tv}, FEMatrixBlock{Tv, Ti}, FEVectorBlock{Tv}}} where {Tv, Ti}","page":"FEMatrix","title":"ExtendableFEMBase.addblock_matmul!","text":"addblock_matmul!(\n    a::FEVectorBlock{Tv},\n    B::FEMatrixBlock{Tv, Ti},\n    b::FEVectorBlock{Tv};\n    factor,\n    transposed\n)\n\n\nAdds matrix-vector product B times b (or B' times b if transposed = true) to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.ldrdmatmul-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, AbstractVector{Tv}, ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.ldrdmatmul","text":"ldrdmatmul(\n    a1::AbstractArray{Tv, 1},\n    a2::AbstractArray{Tv, 1},\n    B::ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti<:Integer},\n    b1::AbstractArray{Tv, 1},\n    b2::AbstractArray{Tv, 1};\n    factor\n) -> Any\n\n\nComputes vector'-matrix-vector product (a1-a2)'B(b1-b2).\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.lrmatmul-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti}, AbstractVector{Tv}}} where {Tv, Ti<:Integer}","page":"FEMatrix","title":"ExtendableFEMBase.lrmatmul","text":"lrmatmul(\n    a::AbstractArray{Tv, 1},\n    B::ExtendableSparse.AbstractExtendableSparseMatrixCSC{Tv, Ti<:Integer},\n    b::AbstractArray{Tv, 1};\n    factor\n) -> Any\n\n\nComputes vector'-matrix-vector product a'Bb.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.nbcols-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"ExtendableFEMBase.nbcols","text":"nbcols(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Any\n\n\nGives the number of FEMatrixBlocks in each row.\n\n\n\n\n\n","category":"method"},{"location":"fematrix/#ExtendableFEMBase.nbrows-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"FEMatrix","title":"ExtendableFEMBase.nbrows","text":"nbrows(\n    _::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n) -> Any\n\n\nGives the number of FEMatrixBlocks in each column.\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#Finite-Element-Interpolations","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"","category":"section"},{"location":"interpolations/#Source-functions-and-QPInfo","page":"Finite Element Interpolations","title":"Source functions and QPInfo","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"The functions that can be interpolated with the methods below are expected to have a certain interface, i.e.:","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"function f!(result, qpinfo) end","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"The qpinfo argument communicates vast information of the current quadrature point:","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"qpinfo child Type Description\nqpinfo.x Vector{Real} space coordinates of quadrature point\nqpinfo.time Real current time\nqpinfo.item Integer current item that contains qpinfo.x\nqpinfo.region Integer region number of item\nqpinfo.xref Vector{Real} reference coordinates within item of qpinfo.x\nqpinfo.volume Real volume of item\nqpinfo.params Vector{Any} parameters that can be transfered via keyword arguments","category":"page"},{"location":"interpolations/#Standard-Interpolations","page":"Finite Element Interpolations","title":"Standard Interpolations","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"Each finite element has its standard interpolator that can be applied to some user-defined DataFunction. Instead of interpolating on the full cells, the interpolation can be restricted to faces or edges. ","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"It is also possible to interpolate finite element functions on one grid onto a finite element function on another grid (experimental feature, does not work for all finite elements yet and shall be extended to interpolations of operator evaluations as well in future).","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"interpolate!","category":"page"},{"location":"interpolations/#ExtendableGrids.interpolate!","page":"Finite Element Interpolations","title":"ExtendableGrids.interpolate!","text":"function ExtendableGrids.interpolate!(target::FEVectorBlock,\n\t AT::Type{<:AssemblyType},\n\t source!::Function;\n\t items = [],\n\t bonus_quadorder = 0,\n\t time = 0,\n\t kwargs...)\n\nInterpolates the given source into the finite elements space assigned to the target FEVectorBlock with the specified AssemblyType (usualy ON_CELLS). \n\nThe source functions should adhere to the interface\n\n\tsource!(result, qpinfo)\n\nThe qpinfo argument communicates vast information of the current quadrature/evaluation point.\n\nThe bonus_quadorder argument can be used to steer the quadrature order of integrals that needs to be computed for the interpolation (the default quadrature order corressponds to the polynomial order of the finite element).\n\n\n\n\n\nfunction ExtendableGrids.interpolate!(target::FEVectorBlock,\n\t source::Function;\n\t items = [],\n\t bonus_quadorder = 0,\n\t time = 0,\n\t kwargs...)\n\nInterpolates the given source function into the finite element space assigned to the target FEVectorBlock. \n\nThe source functions should adhere to the interface\n\n\tsource!(result, qpinfo)\n\nThe qpinfo argument communicates vast information of the current quadrature/evaluation point.\n\nThe bonus_quadorder argument can be used to steer the quadrature order of integrals that needs to be computed for the interpolation (the default quadrature order corressponds to the polynomial order of the finite element).\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#Nodal-Evaluations","page":"Finite Element Interpolations","title":"Nodal Evaluations","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"Usually, Plotters need nodal values, so there is a gengeric function that evaluates any finite element function at the nodes of the grids (possibly by averaging if discontinuous). In case of Identity evaluations of an H1-conforming finite element, the function nodevalues_view can generate a view into the coefficient field that avoids further allocations.","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"nodevalues!\nnodevalues\nnodevalues_view\nnodevalues_subset!","category":"page"},{"location":"interpolations/#ExtendableFEMBase.nodevalues!","page":"Finite Element Interpolations","title":"ExtendableFEMBase.nodevalues!","text":"function nodevalues!(\n\ttarget::AbstractArray{<:Real,2},\n\tsource::AbstractArray{T,1},\n\tFE::FESpace{Tv,Ti,FEType,AT},\n\toperator::Type{<:AbstractFunctionOperator} = Identity;\n\tregions::Array{Int,1} = [0],\n\tabs::Bool = false,\n\tfactor = 1,\n\ttarget_offset::Int = 0,   # start to write into target after offset\n\tzero_target::Bool = true, # target vector is zeroed\n\tcontinuous::Bool = false)\n\nEvaluates the finite element function with the coefficient vector source (interpreted as a coefficient vector for the FESpace FE) and the specified FunctionOperator at all the nodes of the (specified regions of the) grid and writes the values into target. Discontinuous (continuous = false) quantities are evaluated in all neighbouring cells of each node and then averaged. Continuous (continuous = true) quantities are only evaluated once at each node.\n\n\n\n\n\nfunction nodevalues!(\n\ttarget::AbstractArray{<:Real,2},\n\tsource::FEVectorBlock,\n\toperator::Type{<:AbstractFunctionOperator} = Identity;\n\tregions::Array{Int,1} = [0],\n\tabs::Bool = false,\n\tfactor = 1,\n\tcellwise = false,\t\t  # return cellwise nodevalues ncells x nnodes_on_cell\n\ttarget_offset::Int = 0,   # start to write into target after offset\n\tzero_target::Bool = true, # target vector is zeroed\n\tcontinuous::Bool = false)\n\nEvaluates the finite element function with the coefficient vector source and the specified FunctionOperator at all the nodes of the (specified regions of the) grid and writes the values into target. Discontinuous (continuous = false) quantities are evaluated in all neighbouring cells of each node and then averaged. Continuous (continuous = true) quantities are only evaluated once at each node.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#ExtendableFEMBase.nodevalues","page":"Finite Element Interpolations","title":"ExtendableFEMBase.nodevalues","text":"function nodevalues(\n\tsource::FEVectorBlock,\n\toperator::Type{<:AbstractFunctionOperator} = Identity;\n\tregions::Array{Int,1} = [0],\n\tabs::Bool = false,\n\tfactor = 1,\n\tnodes = [],\t\t\t\t  \n\tcellwise = false,\t\t  # return cellwise nodevalues ncells x nnodes_on_cell (only if nodes == [])\n\ttarget_offset::Int = 0,   # start to write into target after offset\n\tzero_target::Bool = true, # target vector is zeroed\n\tcontinuous::Bool = false)\n\nEvaluates the finite element function with the coefficient vector source and the specified FunctionOperator at the specified list of nodes of the grid (default = all nodes) and writes the values in that order into target. Nodes that are not part of the specified regions (default = all regions) are set to zero. Discontinuous (continuous = false) quantities are evaluated in all neighbouring cells of each node and then averaged. Continuous (continuous = true) quantities are only evaluated once at each node.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#ExtendableFEMBase.nodevalues_view","page":"Finite Element Interpolations","title":"ExtendableFEMBase.nodevalues_view","text":"function nodevalues_view(\n\tsource::FEVectorBlock,\n\toperator::Type{<:AbstractFunctionOperator} = Identity)\n\nReturns a vector of views of the nodal values of the source block (currently works for unbroken H1-conforming elements) that directly accesses the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#ExtendableFEMBase.nodevalues_subset!","page":"Finite Element Interpolations","title":"ExtendableFEMBase.nodevalues_subset!","text":"function nodevalues_subset!(\n\ttarget::AbstractArray{<:Real,2},\n\tsource::AbstractArray{T,1},\n\tFE::FESpace{Tv,Ti,FEType,AT},\n\toperator::Type{<:AbstractFunctionOperator} = Identity;\n\tregions::Array{Int,1} = [0],\n\tabs::Bool = false,\n\tfactor = 1,\n\tnodes = [],\t\t\t\t  \n\ttarget_offset::Int = 0,   # start to write into target after offset\n\tzero_target::Bool = true, # target vector is zeroed\n\tcontinuous::Bool = false)\n\nEvaluates the finite element function with the coefficient vector source (interpreted as a coefficient vector for the FESpace FE) and the specified FunctionOperator at the specified list of nodes of the grid and writes the values in that order into target. Node values for nodes that are not part of the specified regions (default = all regions) are set to zero. Discontinuous (continuous = false) quantities are evaluated in all neighbouring cells (in the specified regions) of each node and then averaged. Continuous (continuous = true) quantities are only evaluated once at each node.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#Lazy-Interpolation","page":"Finite Element Interpolations","title":"Lazy Interpolation","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"To interpolate between different finite element spaces and meshes, there is a lazy interpolation routine that works in all cases (but is not very efficient as it involves a PointeEvaluator and CellFinder):","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"lazy_interpolate!","category":"page"},{"location":"interpolations/#ExtendableFEMBase.lazy_interpolate!","page":"Finite Element Interpolations","title":"ExtendableFEMBase.lazy_interpolate!","text":"function lazy_interpolate!(\n\ttarget::FEVectorBlock{T1,Tv,Ti},\n\tsource::FEVectorBlock{T2,Tv,Ti};\n\toperator = Identity,\n\tpostprocess = nothing,\n\txtrafo = nothing,\n\titems = [],\n\tnot_in_domain_value = 1e30,\n\teps = 1e-13,\n\tuse_cellparents::Bool = false) where {T1,T2,Tv,Ti}\n\nInterpolates (operator-evaluations of) the given finite element function into the finite element space assigned to the target FEVectorBlock.  (Currently not the most efficient way as it is based on the PointEvaluation pattern and cell search. If CellParents are available in the grid components of the target grid, these parent cell information can be used to improve the search. To activate this put 'use_cellparents' = true). By some given kernel function that is conforming to the interface\n\nkernel!(result, input, qpinfo)\n\nthe operator evaluation (=input) can be further postprocessed. The qpinfo argument allows to access information at the current quadrature point.\n\nNote: discontinuous quantities at vertices of the target grid will be evaluted in the first found cell of the source grid. No averaging is performed. With eps the tolerances of the cell search via ExtendableGrids.CellFinder can be steered.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#Displace-Mesh","page":"Finite Element Interpolations","title":"Displace Mesh","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"Nodal values (e.g. of a FEVector that discretizes a displacement) can be used to displace the mesh.","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"displace_mesh!\ndisplace_mesh","category":"page"},{"location":"interpolations/#ExtendableFEMBase.displace_mesh!","page":"Finite Element Interpolations","title":"ExtendableFEMBase.displace_mesh!","text":"function displace_mesh!(xgrid::ExtendableGrid, source::FEVectorBlock; magnify = 1)\n\nMoves all nodes of the grid by adding the displacement field in source (expects a vector-valued finite element) times a magnify value.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#ExtendableFEMBase.displace_mesh","page":"Finite Element Interpolations","title":"ExtendableFEMBase.displace_mesh","text":"function displace_mesh(xgrid::ExtendableGrid, source::FEVectorBlock; magnify = 1)\n\nReturns a new grid by adding the displacement field in source (expects a vector-valued finite element) to the coordinates of the provided xgrid times a magnify value.\n\n\n\n\n\n","category":"function"},{"location":"package_index/","page":"Index","title":"Index","text":"Modules = [ExtendableFEMBase]\nOrder   = [:function, :type]","category":"page"},{"location":"fevector/#FEVector","page":"FEVector","title":"FEVector","text":"","category":"section"},{"location":"fevector/","page":"FEVector","title":"FEVector","text":"A FEVector consists of FEVectorBlocks that share a common one-dimensional array. Each block is associated to a FESpace and can only write into a region of the common array specified by offsets that stores the degrees of freedom of that FEspace.","category":"page"},{"location":"fevector/","page":"FEVector","title":"FEVector","text":"Modules = [ExtendableFEMBase]\nPages = [\"fevector.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fevector/#ExtendableFEMBase.FEVector","page":"FEVector","title":"ExtendableFEMBase.FEVector","text":"struct FEVector{T, Tv, Ti}\n\na plain array but with an additional layer of several FEVectorBlock subdivisions each carrying coefficients for their associated FESpace. The j-th block can be accessed by getindex(::FEVector, j) or by getindex(::FEVector, tag) if tags are associated. The full vector can be accessed via FEVector.entries \n\n\n\n\n\n","category":"type"},{"location":"fevector/#ExtendableFEMBase.FEVector-Union{Tuple{FESpace{Tv, Ti, FEType, APT}}, Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType, APT}","page":"FEVector","title":"ExtendableFEMBase.FEVector","text":"FEVector{T}(FES; name = nothing, tags = nothing, kwargs...) where T <: Real\n\nCreates FEVector that has one block if FES is a single FESpace, and a blockwise FEVector if FES is a vector of FESpaces. Optionally a name for the vector (as a String) or each of the blocks (as a vector of Strings), or tags (as an Array{Any}) for the blocks can be specified.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.FEVectorBlock","page":"FEVector","title":"ExtendableFEMBase.FEVectorBlock","text":"struct FEVectorBlock{T, Tv, Ti, FEType, APT} <: AbstractArray{T, 1}\n\nblock of an FEVector that carries coefficients for an associated FESpace and can be assigned as an AbstractArray (getindex, setindex, size, length)\n\n\n\n\n\n","category":"type"},{"location":"fevector/#Base.append!-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{T}, Tuple{FEVector{T}, FESpace{Tv, Ti, FEType, APT}}} where {T, Tv, Ti, FEType, APT}","page":"FEVector","title":"Base.append!","text":"append!(\n    FEF::FEVector{T},\n    FES::FESpace{Tv, Ti, FEType, APT};\n    name,\n    tag\n) -> Int64\n\n\nOverloaded append function for FEVector that adds a FEVectorBlock at the end.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.fill!-Tuple{FEVectorBlock, Any}","page":"FEVector","title":"Base.fill!","text":"fill!(b::FEVectorBlock, value)\n\n\nOverloaded fill function for FEVectorBlock (only fills the block, not the complete FEVector).\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.length-Tuple{FEVectorBlock}","page":"FEVector","title":"Base.length","text":"length(FEB::FEVectorBlock) -> Int64\n\n\nCustom length function for FEVectorBlock that gives the coressponding number of degrees of freedoms of the associated FESpace\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.length-Tuple{FEVector}","page":"FEVector","title":"Base.length","text":"length(FEF::FEVector) -> Int64\n\n\nCustom length function for FEVector that gives the number of defined FEMatrixBlocks in it\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.show-Tuple{IO, FEVector}","page":"FEVector","title":"Base.show","text":"show(io::IO, FEF::FEVector)\n\n\nCustom show function for FEVector that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#Base.view-Tuple{FEVectorBlock}","page":"FEVector","title":"Base.view","text":"returns a view of the part of the full FEVector that coressponds to the block. \n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.FESpaces-Union{Tuple{FEVector{T, Tv, Ti}}, Tuple{Ti}, Tuple{Tv}, Tuple{T}} where {T, Tv, Ti}","page":"FEVector","title":"ExtendableFEMBase.FESpaces","text":"FESpaces(\n    FEV::FEVector{T, Tv, Ti}\n) -> Vector{T} where T<:(FESpace{_A, _B} where {_B, _A})\n\n\nReturns the vector of FEspaces for the blocks of the given FEVector.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.addblock!-Tuple{FEVectorBlock, AbstractVector}","page":"FEVector","title":"ExtendableFEMBase.addblock!","text":"addblock!(\n    a::FEVectorBlock,\n    b::AbstractVector;\n    factor,\n    offset\n)\n\n\nAdds Array b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#ExtendableFEMBase.addblock!-Tuple{FEVectorBlock, FEVectorBlock}","page":"FEVector","title":"ExtendableFEMBase.addblock!","text":"addblock!(a::FEVectorBlock, b::FEVectorBlock; factor)\n\n\nAdds FEVectorBlock b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fevector/#LinearAlgebra.dot-Union{Tuple{T}, Tuple{FEVectorBlock{T}, FEVectorBlock{T}}} where T","page":"FEVector","title":"LinearAlgebra.dot","text":"dot(a::FEVectorBlock{T}, b::FEVectorBlock{T}) -> Any\n\n\nScalar product between two FEVEctorBlocks\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#PointEvaluator","page":"PointEvaluator","title":"PointEvaluator","text":"","category":"section"},{"location":"pointevaluators/","page":"PointEvaluator","title":"PointEvaluator","text":"Point evaluators allow to evaluate a finite element function (FEVector) at arbitrary points.","category":"page"},{"location":"pointevaluators/","page":"PointEvaluator","title":"PointEvaluator","text":"Modules = [ExtendableFEMBase]\nPages = [\"point_evaluator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pointevaluators/#ExtendableFEMBase.PointEvaluator","page":"PointEvaluator","title":"ExtendableFEMBase.PointEvaluator","text":"function Pointevaluator(\n\t[kernel!::Function],\n\toa_args::Array{<:Tuple{<:Any, DataType},1};\n\tkwargs...)\n\nGenerates a PointEvaluator that can evaluate the specified operator evaluations at arbitrary points. If no kernel function is given, the arguments are given directly. If a kernel is provided, the arguments are postprocessed accordingly and the kernel has to be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current evaluation point. Additionally the length of the result needs to be specified via the kwargs.\n\nEvaluation can be triggered via the evaluate function after an initialize! call.\n\nOperator evaluations are tuples that pair a tag (to identify an unknown or the position in the vector) with a FunctionOperator.\n\nKeyword arguments:\n\nresultdim: dimension of result field (default = length of operators). Default: 0\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nname: name for operator used in printouts. Default: ''PointEvaluator''\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"pointevaluators/#ExtendableFEMBase.eval_func-Tuple{PointEvaluator}","page":"PointEvaluator","title":"ExtendableFEMBase.eval_func","text":"function eval_func(PE::PointEvaluator)\n\nYields the function (result, x) -> evaluate!(result,PE,x).\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#ExtendableFEMBase.eval_func_bary-Tuple{PointEvaluator}","page":"PointEvaluator","title":"ExtendableFEMBase.eval_func_bary","text":"function eval_func_bary(PE::PointEvaluator)\n\nYields the function (result, xref, item) -> evaluate_bary!(result,PE,xref,item).\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#ExtendableFEMBase.evaluate!-Tuple{Any, PointEvaluator, Any}","page":"PointEvaluator","title":"ExtendableFEMBase.evaluate!","text":"function evaluate!(\n\tresult,\n\tPE::PointEvaluator,\n\tx\n\t)\n\nEvaluates the PointEvaluator at the specified coordinates x. (To do so it internally calls CellFinder to find the cell and the barycentric coordinates of x and calls evaluate_bary!.)\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#ExtendableFEMBase.evaluate_bary!-Tuple{Any, PointEvaluator, Any, Any}","page":"PointEvaluator","title":"ExtendableFEMBase.evaluate_bary!","text":"function evaluate_bary!(\n\tresult,\n\tPE::PointEvaluator,\n\txref, \n\titem\n\t)\n\nEvaluates the PointEvaluator at the specified reference coordinates in the cell with the specified item number.\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#ExtendableFEMBase.initialize!-Union{Tuple{UT}, Tuple{T}, Tuple{PointEvaluator{T, UT}, Any}} where {T, UT}","page":"PointEvaluator","title":"ExtendableFEMBase.initialize!","text":"function initialize!(\n\tO::PointEvaluator,\n\tsol;\n\ttime = 0,\n\tkwargs...)\n\nInitializes the PointEvaluator for the specified solution.\n\n\n\n\n\n","category":"method"},{"location":"segmentintegrators/#SegmentIntegrator","page":"SegmentIntegrator","title":"SegmentIntegrator","text":"","category":"section"},{"location":"segmentintegrators/","page":"SegmentIntegrator","title":"SegmentIntegrator","text":"Segment integrators allow to integrate a finite element function (FEVector) along arbitrary lines through mesh cells.","category":"page"},{"location":"segmentintegrators/","page":"SegmentIntegrator","title":"SegmentIntegrator","text":"Modules = [ExtendableFEMBase]\nPages = [\"segment_integrator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"segmentintegrators/#ExtendableFEMBase.SegmentIntegrator-Tuple{Any, Any, Vector{<:Tuple{Any, DataType}}}","page":"SegmentIntegrator","title":"ExtendableFEMBase.SegmentIntegrator","text":"function SegmentIntegrator(\n\tEG::ElementGeometry,\n\t[kernel!::Function],\n\toa_args::Array{<:Tuple{<:Any, DataType},1};\n\tkwargs...)\n\nGenerates an SegmentIntegrator that can intgrate over segments of the specified geometry EG. To do so, it evaluates, at each quadrature point, the specified operator evaluations, postprocesses them with the kernel function (if provided) and accumulates the results with the quadrature weights. If no kernel is given, the arguments are integrated directly. If a kernel is provided it has be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point. Additionally the length of the result needs to be specified via the kwargs.\n\nEvaluation can be triggered via the integrate_segment! function after an initialize!\n\nOperator evaluations are tuples that pair a tag (to identify an unknown or the position in the vector) with a FunctionOperator.\n\nKeyword arguments:\n\nfactor: factor that should be multiplied during assembly. Default: 1\nresultdim: dimension of result field (default = length of arguments). Default: 0\nmatrix_mode: integrator integrates basis functions of FEspace seperately to assembly a matrix that maps solution to segment integrations (requires that kernel is linear). Default: false\nname: name for operator used in printouts. Default: ''SegmentIntegrator''\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentrytolerance: threshold to add entry to sparse matrix (only in matrixmode). Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"segmentintegrators/#ExtendableFEMBase.initialize!-Union{Tuple{UT}, Tuple{T}, Tuple{SegmentIntegrator{T, UT}, Any}} where {T, UT}","page":"SegmentIntegrator","title":"ExtendableFEMBase.initialize!","text":"function initialize!(\n\tO::SegmentIntegrator{T, UT},\n\tsol;\n\ttime = 0,\n\tkwargs...)\n\nInitializes the SegmentIntegrator for the specified solution.\n\n\n\n\n\n","category":"method"},{"location":"segmentintegrators/#ExtendableFEMBase.integrate_segment!-Union{Tuple{T}, Tuple{Vector{T}, SegmentIntegrator, Array{Vector{T}, 1}, Array{Vector{T}, 1}, Any}} where T","page":"SegmentIntegrator","title":"ExtendableFEMBase.integrate_segment!","text":"function integrate_segment!(\n\tresult::Array{T,1},\n\tSI::SegmentIntegrator,\n\tw::Array{Array{T,1},1},\n\tb::Array{Array{T,1},1},\n\titem\n\t) where {T}\n\nIntegrate a segment with world coordinates w and barycentric coordinates b in the cell with the given item number.\n\n\n\n\n\n","category":"method"},{"location":"plots/#Plots","page":"Plots","title":"Plots","text":"","category":"section"},{"location":"plots/#GridVisualize/PlutoVista","page":"Plots","title":"GridVisualize/PlutoVista","text":"","category":"section"},{"location":"plots/","page":"Plots","title":"Plots","text":"Plotting is possible e.g. via Nodal Evaluations and the plot routines from ExtendableGrids.jl. In Pluto notebooks it is recommended to use PlutoVista.jl as an backend.","category":"page"},{"location":"plots/#UnicodePlots","page":"Plots","title":"UnicodePlots","text":"","category":"section"},{"location":"plots/","page":"Plots","title":"Plots","text":"For a fast and rough peak several UnicodePlots plotters are available via an extension (ExtendableFEMBaseUnicodePlotsExt) that is loaded when UnicodePlots is available.","category":"page"},{"location":"plots/","page":"Plots","title":"Plots","text":"Modules = [ExtendableFEMBase]\nPages = [\"plots.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"functionoperators/#Function-Operators","page":"Function Operators","title":"Function Operators","text":"","category":"section"},{"location":"functionoperators/#StandardFunctionOperators","page":"Function Operators","title":"StandardFunctionOperators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"StandardFunctionOperators are abstract types that encode primitive (linear) operators (like Identity, Gradient etc.) used to dispatch different evaluations of finite element basis functions.","category":"page"},{"location":"functionoperators/#List-of-primitive-operators","page":"Function Operators","title":"List of primitive operators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"StandardFunctionOperator Description Mathematically\nIdentity identity v rightarrow v\nIdentityComponent{c} identity of c-th component v rightarrow v_c\nNormalFlux normal flux (function times normal) v rightarrow v cdot vecn (only ON_FACES)\nTangentFlux tangent flux (function times tangent) v rightarrow v cdot vect (only ON_EDGES)\nGradient gradient/Jacobian (as a vector) v rightarrow nabla v\nSymmetricGradient symmetric part of the gradient v rightarrow Voigt(mathrmsym(nabla v))\nDivergence divergence v rightarrow mathrmdiv(v) = nabla cdot v\nCurlScalar curl operator 1D to 2D (rotated gradient) v rightarrow -dvdx_2dvdx_1\nCurl2D curl operator 2D to 1D v rightarrow dv_1dx_2 - dv_2dx_1\nCurl3D curl operator 3D to 3D v rightarrow nabla times v\nHessian Hesse matrix = all 2nd order derivatives (as a vector) v rightarrow D^2 v      (e.g. in 2D: xx,xy,yx,yy for each component)\nSymmetricHessian{a} symmetric part of Hesse matrix, offdiagonals scaled by a v rightarrow sym(D^2 v) (e.g. in 2D: xx,yy,a*xy for each component)\nLaplacian Laplace Operator (diagonal of Hessian) v rightarrow Delta v   (e.g. in 2D: xx,yy for each component)","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"note: Note\nAs each finite element type is transformed differently from the reference domain to the general domain, the evaluation of each function operator has to be implemented for each finite element class. Currently, not every function operator works in any dimension and for any finite element. More evaluations are added as soon as they are needed (and possibly upon request). Also, the function operators can be combined with user-defined actions to evaluate other operators that can be build from the ones available (e.g. the deviator).","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Modules = [ExtendableFEMBase]\nPages = [\"functionoperators.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"functionoperators/#ExtendableFEMBase.AbstractFunctionOperator","page":"Function Operators","title":"ExtendableFEMBase.AbstractFunctionOperator","text":"abstract type AbstractFunctionOperator\n\nroot type for FunctionOperators.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Curl2D","page":"Function Operators","title":"ExtendableFEMBase.Curl2D","text":"abstract type Curl2D <: StandardFunctionOperator\n\nevaluates the curl of some two-dimensional vector field, i.e. Curl2D((u1,u2)) = du2/dx1 - du1/dx2\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Curl3D","page":"Function Operators","title":"ExtendableFEMBase.Curl3D","text":"abstract type Curl3D <: StandardFunctionOperator\n\nevaluates the curl of some three-dimensional vector field, i.e. Curl3D(u) =  abla \times u\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.CurlScalar","page":"Function Operators","title":"ExtendableFEMBase.CurlScalar","text":"abstract type CurlScalar <: StandardFunctionOperator\n\nevaluates the curl of some scalar function in 2D, i.e. the rotated gradient.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Divergence","page":"Function Operators","title":"ExtendableFEMBase.Divergence","text":"abstract type Divergence <: StandardFunctionOperator\n\nevaluates the divergence of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Gradient","page":"Function Operators","title":"ExtendableFEMBase.Gradient","text":"abstract type Gradient <: StandardFunctionOperator\n\nevaluates the gradient of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Hessian","page":"Function Operators","title":"ExtendableFEMBase.Hessian","text":"abstract type Hessian <: StandardFunctionOperator\n\nevaluates the full Hessian of some (possibly vector-valued) finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Identity","page":"Function Operators","title":"ExtendableFEMBase.Identity","text":"abstract type Identity <: StandardFunctionOperator\n\nidentity operator: evaluates finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.IdentityComponent","page":"Function Operators","title":"ExtendableFEMBase.IdentityComponent","text":"abstract type IdentityComponent{c} <: StandardFunctionOperator\n\nidentity operator: evaluates only the c-th component of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.Laplacian","page":"Function Operators","title":"ExtendableFEMBase.Laplacian","text":"abstract type Laplacian <: StandardFunctionOperator\n\nevaluates the Laplacian of some (possibly vector-valued) finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.NormalFlux","page":"Function Operators","title":"ExtendableFEMBase.NormalFlux","text":"abstract type NormalFlux <: StandardFunctionOperator\n\nevaluates the normal-flux of the finite element function.\n\nonly available on FACES/BFACES and currently only for H1 and Hdiv elements\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.OperatorPair","page":"Function Operators","title":"ExtendableFEMBase.OperatorPair","text":"abstract type OperatorPair{<:StandardFunctionOperator,<:StandardFunctionOperator} <: StandardFunctionOperator\n\nallows to evaluate two operators in place of one, e.g. OperatorPair{Identity,Gradient}.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.OperatorTriple","page":"Function Operators","title":"ExtendableFEMBase.OperatorTriple","text":"abstract type OperatorTriple{<:StandardFunctionOperator,<:StandardFunctionOperator} <: StandardFunctionOperator\n\nallows to evaluate three operators in place of one, e.g. OperatorTriple{Identity,Gradient,Hessian}.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.SymmetricGradient","page":"Function Operators","title":"ExtendableFEMBase.SymmetricGradient","text":"abstract type SymmetricGradient{offdiagval} <: StandardFunctionOperator\n\nevaluates the symmetric part of the gradient of the finite element function and returns its Voigt compression (off-diagonals on position [j,k] and [k,j] are added together and weighted with offdiagval).\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.SymmetricHessian","page":"Function Operators","title":"ExtendableFEMBase.SymmetricHessian","text":"abstract type SymmetricHessian{offdiagval} <: StandardFunctionOperator\n\nevaluates only the symmetric part of the Hessian of some (possibly vector-valued) finite element function. A concatenation of Voigt compressed Hessians for each component of the finite element functions is returned. The weighting of the mixed derivatives can be steered with offdiagval (e.g. √2 or 1 depending on the use case).\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.TangentFlux","page":"Function Operators","title":"ExtendableFEMBase.TangentFlux","text":"abstract type TangentFlux <: StandardFunctionOperator\n\nevaluates the tangent-flux of the finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ExtendableFEMBase.TangentialGradient","page":"Function Operators","title":"ExtendableFEMBase.TangentialGradient","text":"abstract type TangentialGradient <: StandardFunctionOperator\n\nevaluates the gradient of the tangential part of some vector-valued finite element function.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#ReconstructionOperators","page":"Function Operators","title":"ReconstructionOperators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"There are special operators that allow to evaluate a primitive operator of some discrete reconstructed version of a testfunction. ","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Modules = [ExtendableFEMBase]\nPages = [\"reconstructionoperators.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"functionoperators/#ExtendableFEMBase.Reconstruct","page":"Function Operators","title":"ExtendableFEMBase.Reconstruct","text":"abstract type Reconstruct{FETypeR, O} <: ExtendableFEMBase.ReconstructionOperator\n\nreconstruction operator: evaluates a reconstructed version of the finite element function.\n\nFETypeR specifies the reconstruction space (needs to be defined for the finite element that it is applied to). O specifies the StandardFunctionOperator that shall be evaluated.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#Divergence-free-reconstruction-operators","page":"Function Operators","title":"Divergence-free reconstruction operators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"For gradient-robust discretisations of certain classical non divergence-conforming ansatz spaces, reconstruction operators are available that map a discretely divergence-free H1 function to a pointwise divergence-free Hdiv function. So far such operators are available for the vector-valued Crouzeix-Raviart (H1CR) and Bernardi–Raugel (H1BR) finite element types, as well as for the P2-bubble (H1P2B) finite element type in two dimensions.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Example: Reconst{HDIVRT0{d}, Identity} gives the reconstruction of the Identity operator into HDIVRT0 (and is available for H1BR{d} and H1CR{d} for d = 1,2)","category":"page"},{"location":"functionoperators/#Operator-Pairs-(experimental)","page":"Function Operators","title":"Operator Pairs (experimental)","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Two function operators can be put into an OperatorPair so that one can provide effectively two operators in each argument of an assembly pattern. However, the user should make sure that both operators can be evaluated together reasonably (meaning both should be well-defined on the element geometries and the finite element space where the argument will be evaluated, and the action of the operator has to operate with coressponding input and result fields). This feature is still experimental and might have issues in some cases. OperatorTriple for a combination of three operators is also available.","category":"page"},{"location":"quadrature/#Quadrature","page":"Quadrature","title":"Quadrature","text":"","category":"section"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Usually quadrature is a hidden layer as quadrature rules are chosen automatically based on the polynomial degree of the ansatz functions and the specified quadorder of the user data.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Hence, quadrature rules are only needed if the user wants write his own low-level assembly.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Quadrature rules consist of points (coordinates of evaluation points with respect to reference geometry) and weights. There are constructors for several AbstractElementGeometries (from ExtendableGrids) and different order (some have generic formulas for arbitrary order), see below for a detailed list.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Modules = [ExtendableFEMBase]\nPages = [\"quadrature.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"abstract type QuadratureRule{T<:Real, ET<:ExtendableGrids.AbstractElementGeometry}\n\nA struct that contains the name of the quadrature rule, the reference points and the weights for the parameter-determined element geometry.\n\n\n\n\n\n","category":"type"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.AbstractElementGeometry0D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry0D}\n\nConstructs 0D quadrature rule of specified order (always point evaluation).\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.AbstractElementGeometry1D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry1D}\n\nConstructs 1D quadrature rule of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.Parallelepiped3D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelepiped3D}\n\nConstructs quadrature rule on Parallelepiped3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.Parallelogram2D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelogram2D}\n\nConstructs quadrature rule on Parallelogram2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.Tetrahedron3D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Tetrahedron3D}\n\nConstructs quadrature rule on Tetrahedron3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.Triangle2D}","page":"Quadrature","title":"ExtendableFEMBase.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Triangle2D}\n\nConstructs quadrature rule on Triangle2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Base.eltype-Union{Tuple{QuadratureRule{T, ET}}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:ExtendableGrids.AbstractElementGeometry}","page":"Quadrature","title":"Base.eltype","text":"eltype(\n    _::QuadratureRule{T<:Real, ET<:ExtendableGrids.AbstractElementGeometry}\n) -> Any\n\n\nCustom eltype function for QuadratureRule{T,ET}.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Base.show-Tuple{IO, QuadratureRule}","page":"Quadrature","title":"Base.show","text":"show(io::IO, Q::QuadratureRule)\n\n\nCustom show function for QuadratureRule{T,ET} that prints some information.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.integrate!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{T}, Tuple{AbstractArray{T}, ExtendableGrids.ExtendableGrid{Tv, Ti}, Type{<:ExtendableGrids.AssemblyType}, Any}} where {T, Tv, Ti}","page":"Quadrature","title":"ExtendableFEMBase.integrate!","text":"integrate!(\n    integral4items::AbstractArray{T},\n    grid::ExtendableGrids.ExtendableGrid{Tv, Ti},\n    AT::Type{<:ExtendableGrids.AssemblyType},\n    integrand;\n    offset,\n    bonus_quadorder,\n    quadorder,\n    time,\n    items,\n    force_quadrature_rule,\n    kwargs...\n)\n\n\nIntegration that writes result on every item into integral4items.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.integrate-Tuple{ExtendableGrids.ExtendableGrid, Type{<:ExtendableGrids.AssemblyType}, Any, Int64}","page":"Quadrature","title":"ExtendableFEMBase.integrate","text":"integrate(\n    grid::ExtendableGrids.ExtendableGrid,\n    AT::Type{<:ExtendableGrids.AssemblyType},\n    integrand!,\n    resultdim::Int64;\n    T,\n    kwargs...\n) -> Union{Float64, Vector{Float64}}\n\n\nIntegration that returns total integral.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#ExtendableFEMBase.ref_integrate!-Tuple{AbstractArray, Type{<:ExtendableGrids.AbstractElementGeometry}, Int64, Function}","page":"Quadrature","title":"ExtendableFEMBase.ref_integrate!","text":"ref_integrate!(\n    integral::AbstractArray,\n    EG::Type{<:ExtendableGrids.AbstractElementGeometry},\n    order::Int64,\n    integrand::Function\n)\n\n\nIntegration for reference basis functions on reference domains (merely for testing stuff).\n\nNote: area of reference geometry is not multiplied\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Accumulating-Vector-(not-relevant-for-users,-but-for-completeness)","page":"Quadrature","title":"Accumulating Vector (not relevant for users, but for completeness)","text":"","category":"section"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Internally a global integration uses an accumulating vector and calls the cell-wise integration.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"AccumulatingVector","category":"page"},{"location":"quadrature/#ExtendableFEMBase.AccumulatingVector","page":"Quadrature","title":"ExtendableFEMBase.AccumulatingVector","text":"struct AccumulatingVector{T} <: AbstractArray{T, 2}\n\nvector that is acting as an AbstractArray{T, 2} and  automatically accumulates all values from the second dimension\n\nAV[k,j] += s for any j results in AV.entries[k] += s\n\n\n\n\n\n","category":"type"},{"location":"fespace/#FESpace","page":"FESpace","title":"FESpace","text":"","category":"section"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"To generate a finite element space only a finite element type and a grid is needed, dofmaps are generated automatically on their first demand.","category":"page"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"Modules = [ExtendableFEMBase]\nPages = [\"finiteelements.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#ExtendableFEMBase.AbstractFiniteElement","page":"FESpace","title":"ExtendableFEMBase.AbstractFiniteElement","text":"abstract type AbstractFiniteElement\n\nroot type for finite element types\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.FESpace","page":"FESpace","title":"ExtendableFEMBase.FESpace","text":"struct FESpace{Tv, Ti, FEType<:AbstractFiniteElement,AT<:AssemblyType}\n\tname::String                          # full name of finite element space (used in messages)\n\tbroken::Bool                          # if true, broken dofmaps are generated\n\tndofs::Int                            # total number of dofs\n\tcoffset::Int                          # offset for component dofs\n\txgrid::ExtendableGrid[Tv,Ti}          # link to xgrid \n\tdofgrid::ExtendableGrid{Tv,Ti}\t      # link to (sub) grid used for dof numbering (expected to be equal to or child grid of xgrid)\n\tdofmaps::Dict{Type{<:AbstractGridComponent},Any} # backpack with dofmaps\nend\n\nA struct that has a finite element type as parameter and carries dofmaps (CellDofs, FaceDofs, BFaceDofs) plus additional grid information and access to arrays holding coefficients if needed.\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.FESpace-Union{Tuple{ExtendableGrids.ExtendableGrid{Tv, Ti}}, Tuple{AT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, AT<:ExtendableGrids.AssemblyType}","page":"FESpace","title":"ExtendableFEMBase.FESpace","text":"function FESpace{FEType<:AbstractFiniteElement,AT<:AssemblyType}(\n\txgrid::ExtendableGrid{Tv,Ti};\n\tname = \"\",\n\tbroken::Bool = false)\n\nConstructor for FESpace of the given FEType, AT = ONCELLS/ONFACES/ONEDGES generates a finite elements space on the cells/faces/edges of the provided xgrid (if omitted ONCELLS is used as default). The broken switch allows to generate a broken finite element space (that is piecewise H1/Hdiv/HCurl). If no name is provided it is generated automatically from FEType. If no AT is provided, the space is generated ON_CELLS.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.eltype-Union{Tuple{FESpace{Tv, Ti, FEType, APT}}, Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"Base.eltype","text":"eltype(\n    _::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT}\n) -> Type{FEType} where FEType<:AbstractFiniteElement\n\n\nCustom eltype function for FESpace returns the finite element type parameter of the finite element space.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.get!-Tuple{FESpace, Type{<:DofMap}}","page":"FESpace","title":"Base.get!","text":"get!(FES::FESpace, DM::Type{<:DofMap}) -> Any\n\n\nTo be called by getindex. This triggers lazy creation of  non-existing dofmaps\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.getindex-Tuple{FESpace, Type{<:DofMap}}","page":"FESpace","title":"Base.getindex","text":"Base.getindex(FES::FESpace,DM::Type{<:DofMap})\n\nGeneric method for obtaining dofmap. This method is mutating in the sense that non-existing dofmaps are created on demand. Due to the fact that components are stored as Any the return value triggers type instability.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.setindex!-Tuple{FESpace, Any, Type{<:DofMap}}","page":"FESpace","title":"Base.setindex!","text":"setindex!(FES::FESpace, v, DM::Type{<:DofMap}) -> Any\n\n\nSet new dofmap\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{IO, FESpace{Tv, Ti, FEType, APT}}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"Base.show","text":"show(\n    io::IO,\n    FES::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT}\n)\n\n\nCustom show function for FESpace that prints some information and all available dofmaps.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.assemblytype-Union{Tuple{FESpace{Tv, Ti, FEType, APT}}, Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"FESpace","title":"ExtendableFEMBase.assemblytype","text":"assemblytype(\n    _::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT}\n) -> Any\n\n\nreturns the assembly type parameter of the finite element space, i.e. on which entities of the grid the finite element is defined.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.broken-Tuple{FESpace}","page":"FESpace","title":"ExtendableFEMBase.broken","text":"broken(FES::FESpace) -> Bool\n\n\nreturns true if the finite element space is broken, false if not\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_AT-Union{Tuple{FESpace{Tv, Ti, FEType, AT}}, Tuple{AT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType, AT}","page":"FESpace","title":"ExtendableFEMBase.get_AT","text":"get_AT(_::FESpace{Tv, Ti, FEType, AT}) -> Any\n\n\nreturns the support of the finite element space\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.get_FEType-Union{Tuple{FESpace{Tv, Ti, FEType, AT}}, Tuple{AT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType, AT}","page":"FESpace","title":"ExtendableFEMBase.get_FEType","text":"get_FEType(_::FESpace{Tv, Ti, FEType, AT}) -> Any\n\n\nreturns the finite element type of the finite element space\n\n\n\n\n\n","category":"method"},{"location":"fespace/#ExtendableFEMBase.ndofs-Tuple{FESpace}","page":"FESpace","title":"ExtendableFEMBase.ndofs","text":"ndofs(FES::FESpace) -> Int64\n\n\nreturns the total number of degrees of freedom of the finite element space.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#DofMaps","page":"FESpace","title":"DofMaps","text":"","category":"section"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"Modules = [ExtendableFEMBase]\nPages = [\"dofmaps.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#ExtendableFEMBase.BEdgeDofs","page":"FESpace","title":"ExtendableFEMBase.BEdgeDofs","text":"abstract type BEdgeDofs <: DofMap\n\nKey type describing the dofs for each boundary edge of the dofgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.BEdgeDofsParent","page":"FESpace","title":"ExtendableFEMBase.BEdgeDofsParent","text":"abstract type BEdgeDofsParent <: DofMap\n\nKey type describing the dofs for each boundary edge of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.BFaceDofs","page":"FESpace","title":"ExtendableFEMBase.BFaceDofs","text":"abstract type BFaceDofs <: DofMap\n\nKey type describing the dofs for each boundary face of the dofgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.BFaceDofsParent","page":"FESpace","title":"ExtendableFEMBase.BFaceDofsParent","text":"abstract type BFaceDofsParent <: DofMap\n\nKey type describing the dofs for each boundary face of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.CellDofs","page":"FESpace","title":"ExtendableFEMBase.CellDofs","text":"abstract type CellDofs <: DofMap\n\nKey type describing the dofs for each cell of the dofgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.CellDofsParent","page":"FESpace","title":"ExtendableFEMBase.CellDofsParent","text":"abstract type CellDofsParent <: DofMap\n\nKey type describing the dofs for each cell of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.DofMap","page":"FESpace","title":"ExtendableFEMBase.DofMap","text":"abstract type DofMap <: ExtendableGrids.AbstractGridAdjacency\n\nDofmaps are stored as an ExtendableGrids.AbstractGridAdjacency in the finite element space and collect information with respect to different AssemblyTypes. They are generated automatically on demand and the dofmaps associated to each subtype can be accessed via FESpace[DofMap].\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.EdgeDofs","page":"FESpace","title":"ExtendableFEMBase.EdgeDofs","text":"abstract type EdgeDofs <: DofMap\n\nKey type describing the dofs for each edge of the dofgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.EdgeDofsParent","page":"FESpace","title":"ExtendableFEMBase.EdgeDofsParent","text":"abstract type EdgeDofsParent <: DofMap\n\nKey type describing the dofs for each edge of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.FaceDofs","page":"FESpace","title":"ExtendableFEMBase.FaceDofs","text":"abstract type FaceDofs <: DofMap\n\nKey type describing the dofs for each face of the dofgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/#ExtendableFEMBase.FaceDofsParent","page":"FESpace","title":"ExtendableFEMBase.FaceDofsParent","text":"abstract type FaceDofsParent <: DofMap\n\nKey type describing the dofs for each face of the parentgrid\n\n\n\n\n\n","category":"type"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"The following DofMap subtypes are available and are used as keys to access the dofmap via FESpace[DofMap] (which is equivalent to FESpace.dofmaps[DofMap]).","category":"page"},{"location":"fespace/","page":"FESpace","title":"FESpace","text":"DofMap Explanation\nCellDofs degrees of freedom for on each cell\nFaceDofs degrees of freedom for each face\nEdgeDofs degrees of freedom for each edge (in 3D)\nBFaceDofs degrees of freedom for each boundary face\nBEdgeDofs degrees of freedom for each boundary edge (in 3D)","category":"page"},{"location":"feevaluator/#FEEvaluator","page":"FEEvaluator","title":"FEEvaluator","text":"","category":"section"},{"location":"feevaluator/","page":"FEEvaluator","title":"FEEvaluator","text":"FEEvaluators provide a structure that handles the evaluation of finite element basis functions for a given function operator, quadrature rule and item geometry. It stores the evaluations on the reference geometry (where derivatives are computed by automatic differentiation) and on the current mesh item. The current mesh item can be changed via the update! call.","category":"page"},{"location":"feevaluator/","page":"FEEvaluator","title":"FEEvaluator","text":"Modules = [ExtendableFEMBase]\nPages = [\"feevaluator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"feevaluator/#ExtendableFEMBase.FEEvaluator-Union{Tuple{FEAPT}, Tuple{EG}, Tuple{FEType}, Tuple{TvR}, Tuple{TiG}, Tuple{TvG}, Tuple{FESpace{TvG, TiG, FEType, FEAPT}, Type{<:??}, QuadratureRule{TvR, EG}}} where {TvG, TiG, TvR, FEType<:AbstractFiniteElement, EG<:ExtendableGrids.AbstractElementGeometry, FEAPT<:ExtendableGrids.AssemblyType}","page":"FEEvaluator","title":"ExtendableFEMBase.FEEvaluator","text":"function FEEvaluator(FE::FESpace, operator::AbstractFunctionOperator, qrule::QuadratureRule; T = Float64, AT = ON_CELLS, L2G = nothing)\n\nConstructs a FEEvaluator that handles evaluations of finite element basis function evaluation for the given FESpace, operator at the quadrature points of the given QuadratureRule. It has an update! function to update the evaluation upon entry to a new cell. Evaluations can be accessed via FEEvaluator.cvals[j,k,i] where i is the quadrature point id, k is the local dof number and j is the component. \n\nNote that matrix-valued operators evaluations, e.g. for Gradient, are given as a long vector (in component-wise order).\n\n\n\n\n\n","category":"method"},{"location":"feevaluator/#ExtendableFEMBase.eval_febe!","page":"FEEvaluator","title":"ExtendableFEMBase.eval_febe!","text":"\teval_febe!(result, FEBE::FEBasisEvaluator, j::Int, i::Int, offset::Int = 0, factor = 1)\n\nEvaluates the linear combination of the basisfunction with given coefficients at the i-th quadrature point and writes the (possibly vector-valued) evaluation into result (beginning at offset and with the specified factor).\n\n\n\n\n\n","category":"function"},{"location":"feevaluator/#ExtendableFEMBase.eval_febe!-2","page":"FEEvaluator","title":"ExtendableFEMBase.eval_febe!","text":"\teval_febe!(result, FEBE::FEBasisEvaluator, j::Int, i::Int, offset::Int = 0, factor = 1)\n\nEvaluate the j-th basis function of the FEBasisEvaluator at the i-th quadrature point and writes the (possibly vector-valued) evaluation into result (beginning at offset and with the specified factor).\n\n\n\n\n\n","category":"function"},{"location":"feevaluator/#ExtendableFEMBase.update_basis!-Tuple{FEEvaluator, Any}","page":"FEEvaluator","title":"ExtendableFEMBase.update_basis!","text":"function update_basis!(FEBE::FEEvaluator, item::Integer)\n\nSets FEBE.citem[] = item and updates the basis.\n\n\n\n\n\n","category":"method"},{"location":"feevaluator/#ExtendableFEMBase.update_basis!-Union{Tuple{ExtendableFEMBase.SingleFEEvaluator{<:Real, <:Real, <:Integer, operator, FEType}}, Tuple{FEType}, Tuple{operator}} where {operator, FEType}","page":"FEEvaluator","title":"ExtendableFEMBase.update_basis!","text":"function update_basis!(FEBE::SingleFEEvaluator)\n\nUpdates the basis for the current item FEBE.citem[].\n\n\n\n\n\n","category":"method"},{"location":"examples_intro/#About-the-examples","page":"About the examples","title":"About the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"The examples have been designed with the following issues in mind:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"they run from the Julia REPL\neach example is a Julia module named similar to the basename of the example file.\nan example can be used as the starting point for a project \nsome examples define test cases for the test suite\nExampleXYZ with X = A can be considered advanced and uses low-level structures and/or demonstrates customisation features or experimental features\nthe default output of the main function is printed on the website and can be used to check if the code runs as expected (unfortunately REPL messages are not recorded)\nprinted assembly and solving times (especially in a first iteration) can be much larger due to first-run compilation times","category":"page"},{"location":"examples_intro/#Running-the-examples","page":"About the examples","title":"Running the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"In order to run ExampleXXX, peform the following steps:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Download the example file (e.g. via the source code link at the top)\nMake sure all used packages are installed in your Julia environment\nIn the REPL: ","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"julia> include(\"ExampleXXX.jl\")`\n\njulia> ExampleXXX.main()","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Some examples offer visual output via the optional argument Plotter = PyPlot or Plotter = GLMakie","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"(provided the package PyPlot/GLMakie is installed and loaded)","category":"page"},{"location":"meshing/#Meshing","page":"Meshing","title":"Meshing","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Meshes are stored as an ExtendableGrid, see ExtendableGrids.jl for details and constructors. Grid generators for simplex grids can be found e.g. in the external module SimplexGridFactory.jl","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Cells, faces and edges of the mesh are associated to AbstractElementGeometries (defined by ExtendableGrids.jl) that are used to dispatch functionality (local/global transformation, enumeration rules, set of basis functions, volume calculation, refinements etc.). See further below for a list of recognized element geometries.","category":"page"},{"location":"meshing/#Recognized-Geometries-and-Reference-Domains","page":"Meshing","title":"Recognized Geometries and Reference Domains","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The following list contains all subtypes of ExtendableGrids.AbstractElementGeometries and their reference domains for which the package offers finite elements on them.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Edge1D-:-AbstractElementGeometry1D","page":"Meshing","title":"Edge1D <: AbstractElementGeometry1D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[1]-----[2]               [1] = [0]\n                          [2] = [1]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Triangle2D","page":"Meshing","title":"Triangle2D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[3]                 \n | \\   \n |   \\                    [1] = [0,0]\n |     \\                  [2] = [1,0]\n |       \\                [3] = [0,1]\n |         \\ \n[1]--------[2]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Parallelogram2D-:-Quadrilateral2D","page":"Meshing","title":"Parallelogram2D <: Quadrilateral2D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[4]--------[3]               \n |          |             [1] = [0,0]\n |          |             [2] = [1,0]\n |          |             [3] = [1,1]\n |          |             [4] = [0,1]\n[1]--------[2]\n\nNote: most finite elements only work as intended on Parallelogram2D\n      since the local<>global map stays affine in this case","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Tetrahedron3D","page":"Meshing","title":"Tetrahedron3D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[4]                 \n |\\\\   \n | \\ \\                    [1] = [0,0,0]\n |  \\  \\                  [2] = [1,0,0]\n |   \\   \\                [3] = [0,1,0]\n | _-[3]-_ \\              [4] = [0,0,1]\n[1]--------[2]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Parallelepiped3D-:-Hexahedron3D","page":"Meshing","title":"Parallelepiped3D <: Hexahedron3D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"    [8]--------[7]        [1] = [0,0,0]\n   / |        / |         [2] = [1,0,0]\n[5]--------[6]  |         [3] = [1,1,0]\n |   |      |   |         [4] = [0,1,0]\n |   |      |   |         [5] = [0,0,1]\n |  [4]-----|--[3]        [6] = [1,0,1]\n | /        | /           [7] = [1,1,1]\n[1]--------[2]            [8] = [0,1,1]\n\nNote: most finite elements only work as intended on Parallelepiped3D\n      since the local<>global map stays affine in this case","category":"page"},{"location":"fems/#Implemented-Finite-Elements","page":"List of Finite Elements","title":"Implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"This page describes the finite element type-tree and lists all implemented finite elements.","category":"page"},{"location":"fems/#The-Finite-Element-Type-Tree","page":"List of Finite Elements","title":"The Finite Element Type-Tree","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Finite elements are abstract type leaves in a type-tree. The complete tree looks like this:","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"AbstractFiniteElement\n├─ AbstractH1FiniteElement\n│  ├─ AbstractH1FiniteElementWithCoefficients\n│  │  ├─ H1P1TEB\n│  │  └─ H1BR\n│  ├─ H1CR\n│  ├─ H1MINI\n│  ├─ L2P0\n│  ├─ L2P1\n│  ├─ H1P1\n│  ├─ H1P2\n│  ├─ H1P2B\n│  ├─ H1P3\n│  ├─ H1Pk\n│  ├─ H1Q1\n│  └─ H1Q2\n├─ AbstractHcurlFiniteElement\n│  ├─ HCURLN0\n│  └─ HCURLN1\n└─ AbstractHdivFiniteElement\n   ├─ HDIVBDM1\n   ├─ HDIVBDM2\n   ├─ HDIVRT0\n   ├─ HDIVRT1\n   ├─ HDIVRTk\n   └─ HDIVRTkENRICH","category":"page"},{"location":"fems/#Remarks","page":"List of Finite Elements","title":"Remarks","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"each type depends on one/two or three parameters, the first one is always the number of components (ncomponents) that determines if the finite element is scalar- or veector-valued; some elements additionaly require the parameter edim <: Int if they are structurally different in different space dimensions; arbitrary order elements require a third parameter that determines the order\neach finite elements mainly comes with a set of basis functions in reference coordinates for each applicable AbstractElementGeometry and degrees of freedom maps for each mesh entity\nbroken finite elements are possible via the broken switch in the FESpace constructor\nthe type steers how the basis functions are transformed from local to global coordinates and how FunctionOperators are evaluated\ndepending on additional continuity properties of the element types more basis function sets are defined:\nAbstractH1FiniteElements additionally have evaluations of nonzero basisfunctions on faces/bfaces\nAbstractHdivFiniteElements additionally have evaluations of nonzero normalfluxes of basisfunctions on faces/bfaces\nAbstractHcurlFiniteElements additionally have evaluations of nonzero tangentfluxes of basisfunctions on edges/bedges\neach finite element has its own implemented standard interpolation interpolate! (see Finite Element Interpolations) that can be applied to a function with header function(result, qpinfo), below it is shortly described what this means for each finite element","category":"page"},{"location":"fems/#List-of-implemented-Finite-Elements","page":"List of Finite Elements","title":"List of implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The following table lists all curently implemented finite elements and on which geometries they are available (in brackets a dofmap pattern for CellDofs is shown and the number of local degrees of freedom for a vector-valued realisation). Click on the FEType to find out more details.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"FEType Triangle2D Parallelogram2D Tetrahedron3D Parallelepiped3D\nAbstractH1FiniteElementWithCoefficients    \nH1BR ✓ (N1f1, 9) ✓ (N1f1, 12) ✓ (N1f1, 16) \nH1P1TEB ✓ (N1f1, 9)  ✓ (N1e1, 18) \nAbstractH1FiniteElement    \nH1BUBBLE ✓ (I1, 2) ✓ (I1, 2) ✓ (I1, 3) \nH1CR ✓ (F1, 6) ✓ (F1, 8) ✓ (F1, 12) \nH1MINI ✓ (N1I1, 8) ✓ (N1I1, 10) ✓ (N1I1, 15) \nL2P0 ✓ (I1, 2) ✓ (I1, 2) ✓ (I1, 3) ✓ (I1, 3)\nL2P1 ✓ (I3, 6) ✓ (I3, 6) ✓ (I4, 12) ✓ (I4, 12)\nH1P1 ✓ (N1, 6)  ✓ (N1, 12) \nH1P2 ✓ (N1F1, 12)  ✓ (N1E1, 30) \nH1P2B ✓ (N1F1I1, 14)   \nH1P3 ✓ (N1F2I1, 20)  ✓ (N1E2F1, 60) \nH1Pk ✓ (order-dep)   \nH1Q1 ✓ (N1, 6) ✓ (N1, 8) ✓ (N1, 12) ✓ (N1, 24)\nH1Q2 ✓ (N1F1, 12) ✓ (N1F1I1, 18) ✓ (N1E1, 30) \nAbstractHcurlFiniteElement    \nHCURLN0 ✓ (f1, 3) ✓ (f1, 4) ✓ (e1, 6) \nHCURLN1 ✓ (f1, 6)   \nAbstractHdivFiniteElement    \nHDIVBDM1 ✓ (f2, 6) ✓ (f2, 8) ✓ (f3, 12) \nHDIVBDM2 ✓ (f3i3, 12)   \nHDIVRT0 ✓ (f1, 3) ✓ (f1, 4) ✓ (f1, 4) ✓ (f1, 6)\nHDIVRT1 ✓ (f2i2, 8)  ✓ (f3i3, 15) \nHDIVRTk ✓ (order-dep)   \nHDIVRTkENRICH ✓ (order-dep)  ✓ (order-dep) ","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Note: the dofmap pattern describes the connection of the local degrees of freedom to entities of the grid and also hints to the continuity. Here, \"N\" or \"n\" means nodes, \"F\" or \"f\" means faces, \"E\" or \"e\" means edges and \"I\" means interior (dofs without any continuity across elements). Capital letters cause that every component has its own degree of freedom, while small letters signalize that only one dof is associated to the entity. As an example \"N1f1\" (for the Bernardi-Raugel element) means that at each node sits one dof per component and at each face sits a single dof. Usually finite elements that involve small letters are only defined vector-valued (i.e. the number of components has to match the element dimension), while finite elements that only involve capital letters are available for any number of components.","category":"page"},{"location":"fems/#H1-conforming-finite-elements","page":"List of Finite Elements","title":"H1-conforming finite elements","text":"","category":"section"},{"location":"fems/#P0-finite-element","page":"List of Finite Elements","title":"P0 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Piecewise constant finite element that has one degree of freedom on each cell of the grid. (It is masked as a H1-conforming finite element, because it uses the same operator evaulations.)","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space preserves the cell integrals.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"L2P0","category":"page"},{"location":"fems/#ExtendableFEMBase.L2P0","page":"List of Finite Elements","title":"ExtendableFEMBase.L2P0","text":"abstract type L2P0{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nPiecewise constant polynomials on cells.\n\nallowed ElementGeometries:\n\nany\n\n\n\n\n\n","category":"type"},{"location":"fems/#P1-finite-element","page":"List of Finite Elements","title":"P1 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The lowest-order Courant finite element that has a degree of freedom on each vertex of the grid. On simplices the basis functions coincide with the linear barycentric coordinates. Only the L2P1 element is also defined on quads.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"L2P1\nH1P1","category":"page"},{"location":"fems/#ExtendableFEMBase.L2P1","page":"List of Finite Elements","title":"ExtendableFEMBase.L2P1","text":"abstract type L2P1{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nDiscontinuous piecewise first-order linear polynomials.\n\nallowed ElementGeometries:\n\nany\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.H1P1","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P1","text":"abstract type H1P1{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nContinuous piecewise first-order linear polynomials.\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Q1-finite-element","page":"List of Finite Elements","title":"Q1 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The lowest-order finite element that has a degree of freedom on each vertex of the grid. On simplices the basis functions coincide with the linear barycentric coordinates. This element is also defined on quads.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1Q1","category":"page"},{"location":"fems/#ExtendableFEMBase.H1Q1","page":"List of Finite Elements","title":"ExtendableFEMBase.H1Q1","text":"abstract type Q1P1{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nContinuous piecewise first-order polynomials on simplices and quads, can be used for mixed geometries.\n\nallowed ElementGeometries:\n\nEdge1D (P1 space)\nTriangle2D (P1 space)\nQuadrilateral2D (Q1 space)\nTetrahedron3D (P1 space)\nHexahedron3D (Q1 space)\n\n\n\n\n\n","category":"type"},{"location":"fems/#MINI-finite-element","page":"List of Finite Elements","title":"MINI finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The mini finite element adds cell bubles to the P1 element that are e.g. beneficial to define inf-sup stable finite element pairs for the Stokes problem.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its cell integral.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1MINI","category":"page"},{"location":"fems/#ExtendableFEMBase.H1MINI","page":"List of Finite Elements","title":"ExtendableFEMBase.H1MINI","text":"abstract type H1MINI{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nMini finite element.\n\nallowed element geometries:\n\nTriangle2D (linear polynomials + cubic cell bubble)\nQuadrilateral2D (Q1 space + quartic cell bubble)\nTetrahedron3D (linear polynomials + cubic cell bubble)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P1TEB-finite-element","page":"List of Finite Elements","title":"P1TEB finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"This element adds tangent-weighted edge bubbles to the P1 finite element and therefore is only available as a vector-valued element.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves face integrals of its tangential flux.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1P1TEB","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P1TEB","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P1TEB","text":"abstract type H1P1TEB{edim} <: AbstractH1FiniteElementWithCoefficients where {edim<:Int}\n\nvector-valued (ncomponents = edim) element that uses P1 functions + tangential-weighted edge bubbles as suggested by [Diening, L., Storn, J. & Tscherpel, T., \"Fortin operator for the Taylor–Hood element\", Numer. Math. 150, 671–689 (2022)]\n\n(is inf-sup stable for Stokes if paired with continuous P1 pressure space, less degrees of freedom than MINI)\n\nallowed ElementGeometries:\n\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Bernardi-Raugel-(BR)-finite-element","page":"List of Finite Elements","title":"Bernardi-Raugel (BR) finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The Bernardi-Raugel adds normal-weighted face bubbles to the P1 finite element and therefore is only available as a vector-valued element.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves face integrals of its normal flux.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1BR","category":"page"},{"location":"fems/#ExtendableFEMBase.H1BR","page":"List of Finite Elements","title":"ExtendableFEMBase.H1BR","text":"abstract type H1BR{edim} <: AbstractH1FiniteElementWithCoefficients where {edim<:Int}\n\nvector-valued (ncomponents = edim) Bernardi–Raugel element (first-order polynomials + normal-weighted face bubbles)\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear + normal-weighted face bubbles)\nQuadrilateral2D (Q1 space + normal-weighted face bubbles)\nTetrahedron3D (piecewise linear + normal-weighted face bubbles)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P2-finite-element","page":"List of Finite Elements","title":"P2 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The P2 finite element method on simplices equals quadratic polynomials. On the Triangle2D shape the degrees of freedom are associated with the three vertices and the three faces of the triangle. On the Tetrahedron3D shape the degrees of freedom are associated with the four verties and the six edges.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its face/edge integrals in 2D/3D.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1P2","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P2","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P2","text":"abstract type H1P2{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Q2-finite-element","page":"List of Finite Elements","title":"Q2 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"A second order finite element. On simplices it equals the P2 finite element, and on Quadrilateral2D it has 9 degrees of freedom (vertices, faces and one cell bubble).","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves lowest order face moments and (only on quads) also the cell integreal mean.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1Q2","category":"page"},{"location":"fems/#ExtendableFEMBase.H1Q2","page":"List of Finite Elements","title":"ExtendableFEMBase.H1Q2","text":"abstract type H1Q2{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials on simplices and quads. Can be used with mixed geometries (in 2D).\n\nallowed ElementGeometries:\n\nEdge1D (P2 space)\nTriangle2D (P2 space)\nQuadrilateral2D (Q2 space with cell bubble)\nTetrahedron3D (P2 space)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P2B-finite-element","page":"List of Finite Elements","title":"P2B finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The P2B finite element adds additional cell bubles (in 2D and 3D) and face bubbles (only in 3D) that are e.g. used to define inf-sup stable finite element pairs for the Stokes problem.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its cell and face integrals in 2D and also edge integrals in 3D.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1P2B","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P2B","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P2B","text":"abstract type H1P2B{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials.\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#P3-finite-element","page":"List of Finite Elements","title":"P3 finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The P3 finite element method on simplices equals cubic polynomials. On the Triangle2D shape the degrees of freedom are associated with the three vertices, the three faces (double dof) of the triangle and the cell itself (one cell bubble).","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves cell and face integrals in 2D.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1P3","category":"page"},{"location":"fems/#ExtendableFEMBase.H1P3","page":"List of Finite Elements","title":"ExtendableFEMBase.H1P3","text":"abstract type H1P3{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise third-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Pk-finite-element-(experimental)","page":"List of Finite Elements","title":"Pk finite element (experimental)","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The Pk finite element method generically generates polynomials of abitrary order k on simplices (Edge1D, Triangle2D so far).","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves cell and face integrals in 2D (moment order depends on the order and the element dimension).","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1Pk","category":"page"},{"location":"fems/#ExtendableFEMBase.H1Pk","page":"List of Finite Elements","title":"ExtendableFEMBase.H1Pk","text":"abstract type H1PK{ncomponents,edim,order} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int,order<:Int}\n\nContinuous piecewise polynomials of arbitrary order >= 1 with ncomponents components in edim space dimensions.\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Crouzeix-Raviart-(CR)-finite-element","page":"List of Finite Elements","title":"Crouzeix-Raviart (CR) finite element","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The Crouzeix-Raviart element associates one lowest-order function with each face. On the Triangle2D shape, the basis function of a face is one minus two times the nodal basis function of the opposite node. ","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"The interpolation of a given function into this space preserves its face integrals.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1CR","category":"page"},{"location":"fems/#ExtendableFEMBase.H1CR","page":"List of Finite Elements","title":"ExtendableFEMBase.H1CR","text":"abstract type H1CR{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nCrouzeix-Raviart element (only continuous at face centers).\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear, similar to P1)\nQuadrilateral2D (similar to Q1 space)\nTetrahedron3D (piecewise linear, similar to P1)\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hdiv-conforming-finite-elements","page":"List of Finite Elements","title":"Hdiv-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"These Raviart-Thomas and Brezzi-Douglas-Marini finite elements of lower order and their standard interpolations are available:","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"HDIVRT0\nHDIVBDM1\nHDIVRT1\nHDIVBDM2\nHDIVRTk\nHDIVRTkENRICH","category":"page"},{"location":"fems/#ExtendableFEMBase.HDIVRT0","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVRT0","text":"abstract type HDIVRT0{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Raviart-Thomas space.\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\nHexahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVBDM1","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVBDM1","text":"abstract type HDIVBDM1{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Brezzi-Douglas-Marini space\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVRT1","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVRT1","text":"abstract type HDIVRT1{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) Raviart-Thomas space of order 1.\n\nallowed ElementGeometries:\n\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVBDM2","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVBDM2","text":"abstract type HDIVBDM2{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) Brezzi-Douglas-Marini space of order 2\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVRTk","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVRTk","text":"abstract type HDIVRTk{edim, order} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) Raviart-Thomas space of arbitrary order.\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HDIVRTkENRICH","page":"List of Finite Elements","title":"ExtendableFEMBase.HDIVRTkENRICH","text":"abstract type HDIVRTkENRICH{k,edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nInternal (normal-zero) Hdiv-conforming vector-valued (ncomponents = edim) Raviart-Thomas space of order k ≥ 1 with the additional orthogonality property that their divergences are L2-orthogonal on P_{k-edim+1}. Example: HDIVRTkENRICH{1,2} gives the edim interior RT1 bubbles (= normal-trace-free) on a triangle, their divergences have integral mean zero; HDIVRTkENRICH{2,2} gives three RT2 bubbles on a triangle whose divergences are L2-orthogonal onto all P1 functions. The maximal order for k is 4 on a Triangle2D (edim = 2) and 3 on Tetrahedron3D (edim = 3). These spaces have no approximation power on their own, but can be used as enrichment spaces in divergence-free schemes for incompressible Stokes problems.\n\nallowed ElementGeometries:\n\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hcurl-conforming-finite-elements","page":"List of Finite Elements","title":"Hcurl-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"So far only the lowest order Nedelec element is available in 2D and 3D. On Triangle2D it has one degree of freedom for each face (i.e. the rotated RT0 element), on Tetrahedron3D it has one degree of freedom associated to each of the six edges.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"Its standard interpolation of a given functions preserves its tangential face/edge integrals.","category":"page"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"HCURLN0\nHCURLN1","category":"page"},{"location":"fems/#ExtendableFEMBase.HCURLN0","page":"List of Finite Elements","title":"ExtendableFEMBase.HCURLN0","text":"abstract type HCURLN0{edim} <: AbstractHcurlFiniteElement where {edim<:Int}\n\nHcurl-conforming vector-valued (ncomponents = edim) lowest-order Nedelec space of first kind.\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#ExtendableFEMBase.HCURLN1","page":"List of Finite Elements","title":"ExtendableFEMBase.HCURLN1","text":"abstract type HCURLN1{edim} <: AbstractHcurlFiniteElement where {edim<:Int}\n\nHcurl-conforming vector-valued (ncomponents = edim) Nedelec space of first kind and order 1.\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Incomplete-finite-elements-without-approximation-power","page":"List of Finite Elements","title":"Incomplete finite elements without approximation power","text":"","category":"section"},{"location":"fems/","page":"List of Finite Elements","title":"List of Finite Elements","text":"H1BUBBLE","category":"page"},{"location":"fems/#ExtendableFEMBase.H1BUBBLE","page":"List of Finite Elements","title":"ExtendableFEMBase.H1BUBBLE","text":"abstract type H1BUBBLE{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nPiecewise bubbles (=zero at boundary)\n\nallowed element geometries:\n\nEdge1D (one quadratic bubble)\nTriangle2D (one cubic bubble)\nQuadrilateral2D (one quartic bubble)\nTetrahedron3D (one cubic bubble)\n\n\n\n\n\n","category":"type"},{"location":"notebooks_intro/#About-the-notebooks","page":"About the notebooks","title":"About the notebooks","text":"","category":"section"},{"location":"notebooks_intro/","page":"About the notebooks","title":"About the notebooks","text":"This sections contains Pluto.jl notebooks.","category":"page"},{"location":"notebooks_intro/","page":"About the notebooks","title":"About the notebooks","text":"Plese note, that in the html version, interactive elements like sliders are disabled. Navigation via the table of contents does work, though.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build status) (Image: ) (Image: ) (Image: DOI)","category":"page"},{"location":"#ExtendableFEMBase.jl","page":"Home","title":"ExtendableFEMBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides some low level structures like finite element spaces, interpolors, matrices and vectors to assemble custom finite element solvers based on ExtendableGrids.jl infrastructure.","category":"page"},{"location":"#Dependencies-on-other-Julia-packages","page":"Home","title":"Dependencies on other Julia packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExtendableGrids.jl\nExtendableSparse.jl\nForwardDiff.jl\nDiffResults.jl\nUnicodePlots.jl\nDocStringExtensions.jl","category":"page"}]
}
