<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finite Element Interpolations · ExtendableFEMBase.jl</title><meta name="title" content="Finite Element Interpolations · ExtendableFEMBase.jl"/><meta property="og:title" content="Finite Element Interpolations · ExtendableFEMBase.jl"/><meta property="twitter:title" content="Finite Element Interpolations · ExtendableFEMBase.jl"/><meta name="description" content="Documentation for ExtendableFEMBase.jl."/><meta property="og:description" content="Documentation for ExtendableFEMBase.jl."/><meta property="twitter:description" content="Documentation for ExtendableFEMBase.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExtendableFEMBase.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li><a class="tocitem" href="../package_index/">Index</a></li><li><a class="tocitem" href="../fems/">List of Finite Elements</a></li><li><span class="tocitem">Base Structures</span><ul><li><a class="tocitem" href="../fespace/">FESpace</a></li><li><a class="tocitem" href="../fevector/">FEVector</a></li><li><a class="tocitem" href="../fematrix/">FEMatrix</a></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li><a class="tocitem" href="../feevaluator/">FEEvaluator</a></li><li class="is-active"><a class="tocitem" href>Finite Element Interpolations</a><ul class="internal"><li><a class="tocitem" href="#Source-functions-and-QPInfo"><span>Source functions and QPInfo</span></a></li><li><a class="tocitem" href="#Standard-Interpolations"><span>Standard Interpolations</span></a></li><li><a class="tocitem" href="#Nodal-Evaluations"><span>Nodal Evaluations</span></a></li><li><a class="tocitem" href="#Displace-Mesh"><span>Displace Mesh</span></a></li></ul></li><li><a class="tocitem" href="../quadrature/">Quadrature</a></li></ul></li><li><span class="tocitem">Advanced Stuff</span><ul><li><a class="tocitem" href="../pointevaluators/">PointEvaluator</a></li><li><a class="tocitem" href="../segmentintegrators/">SegmentIntegrator</a></li><li><a class="tocitem" href="../plots/">Plots</a></li></ul></li><li><span class="tocitem">Tutorial Notebooks</span><ul><li><a class="tocitem" href="../plutostatichtml_examples/LowLevelPoisson/">Low level Poisson</a></li><li><a class="tocitem" href="../plutostatichtml_examples/LowLevelNavierStokes/">Low level Navier-Stokes</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">Introduction</a></li><li><a class="tocitem" href="../module_examples/Example200_LowLevelPoisson/">Example200_LowLevelPoisson</a></li><li><a class="tocitem" href="../module_examples/Example205_LowLevelSpaceTimePoisson/">Example205_LowLevelSpaceTimePoisson</a></li><li><a class="tocitem" href="../module_examples/Example210_LowLevelNavierStokes/">Example210_LowLevelNavierStokes</a></li><li><a class="tocitem" href="../module_examples/Example280_BasisPlotter/">Example280_BasisPlotter</a></li><li><a class="tocitem" href="../module_examples/Example281_DiscontinuousPlot/">Example281_DiscontinuousPlot</a></li><li><a class="tocitem" href="../module_examples/Example290_InterpolationBetweenMeshes/">Example290_InterpolationBetweenMeshes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base Structures</a></li><li class="is-active"><a href>Finite Element Interpolations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Finite Element Interpolations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/master/docs/src/interpolations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Finite-Element-Interpolations"><a class="docs-heading-anchor" href="#Finite-Element-Interpolations">Finite Element Interpolations</a><a id="Finite-Element-Interpolations-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Element-Interpolations" title="Permalink"></a></h1><h2 id="Source-functions-and-QPInfo"><a class="docs-heading-anchor" href="#Source-functions-and-QPInfo">Source functions and QPInfo</a><a id="Source-functions-and-QPInfo-1"></a><a class="docs-heading-anchor-permalink" href="#Source-functions-and-QPInfo" title="Permalink"></a></h2><p>The functions that can be interpolated with the methods below are expected to have a certain interface, i.e.:</p><pre><code class="language-julia hljs">function f!(result, qpinfo) end</code></pre><p>The qpinfo argument communicates vast information of the current quadrature point:</p><table><tr><th style="text-align: left">qpinfo child</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left">qpinfo.x</td><td style="text-align: left">Vector{Real}</td><td style="text-align: left">space coordinates of quadrature point</td></tr><tr><td style="text-align: left">qpinfo.time</td><td style="text-align: left">Real</td><td style="text-align: left">current time</td></tr><tr><td style="text-align: left">qpinfo.item</td><td style="text-align: left">Integer</td><td style="text-align: left">current item that contains qpinfo.x</td></tr><tr><td style="text-align: left">qpinfo.cell</td><td style="text-align: left">Integer</td><td style="text-align: left">cell number (when reasonable)</td></tr><tr><td style="text-align: left">qpinfo.region</td><td style="text-align: left">Integer</td><td style="text-align: left">region number of item</td></tr><tr><td style="text-align: left">qpinfo.xref</td><td style="text-align: left">Vector{Real}</td><td style="text-align: left">reference coordinates within item of qpinfo.x</td></tr><tr><td style="text-align: left">qpinfo.volume</td><td style="text-align: left">Real</td><td style="text-align: left">volume of item</td></tr><tr><td style="text-align: left">qpinfo.normal</td><td style="text-align: left">Vector{Real}</td><td style="text-align: left">normal vector (when reasonable)</td></tr><tr><td style="text-align: left">qpinfo.params</td><td style="text-align: left">Vector{Any}</td><td style="text-align: left">parameters that can be transferred via keyword arguments</td></tr><tr><td style="text-align: left">qpinfo.grid</td><td style="text-align: left">ExtendableGrid</td><td style="text-align: left">full access to grid</td></tr></table><h2 id="Standard-Interpolations"><a class="docs-heading-anchor" href="#Standard-Interpolations">Standard Interpolations</a><a id="Standard-Interpolations-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Interpolations" title="Permalink"></a></h2><p>Each finite element type provides a standard interpolation routine that can be applied to user-defined source functions. By default, interpolation is performed over all cells, but it can also be restricted to faces or edges using an appropriate <code>AssemblyType</code>.</p><article><details class="docstring" open="true"><summary id="ExtendableGrids.interpolate!"><a class="docstring-binding" href="#ExtendableGrids.interpolate!"><code>ExtendableGrids.interpolate!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function ExtendableGrids.interpolate!(
    target::FEVectorBlock{T, Tv, Ti},
    AT::Type{&lt;:AssemblyType},
    source;
    items = [],
    kwargs...
) where {T, Tv, Ti}</code></pre><p>Interpolate a function or data into the finite element space (i.e. computes the coefficients) associated with <code>target</code>, using the specified assembly type.</p><p><strong>Arguments</strong></p><ul><li><code>target::FEVectorBlock</code>: The block of the FE vector to store the interpolated coefficients.</li><li><code>AT::Type{&lt;:AssemblyType}</code>: The assembly type specifying where interpolation is performed (e.g., <code>ON_CELLS</code>).</li><li><code>source</code>: The function or callable to interpolate. Should have the signature <code>source!(result, qpinfo)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>items</code>: List of mesh entities (cells, faces, etc.) to interpolate on. If empty, all entities of the specified type are used.</li><li><code>kwargs...</code>: Additional keyword arguments passed to lower-level routines (e.g., <code>bonus_quadorder</code>, <code>time</code>).</li></ul><p><strong>Notes</strong></p><ul><li>For &quot;broken&quot; FE spaces, interpolation is performed in a continuous auxiliary space and then mapped to the broken space.</li><li>The <code>source!</code> function is called at each quadrature point and should fill <code>result</code> with the function values at that point.</li><li>The <code>qpinfo</code> argument provides information about the current quadrature point, including coordinates, weights, and possibly time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolations.jl#L15-L42">source</a></section><section><div><pre><code class="language-julia hljs">function ExtendableGrids.interpolate!(target::FEVectorBlock,
	 source::Function;
	 kwargs...)</code></pre><p>see interpolate!(target, ON_CELLS, source; kwargs...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolations.jl#L81-L89">source</a></section></details></article><p>Additionally, you can transfer finite element functions from one grid to another using the <code>lazy_interpolate!</code> routine, which interpolates between different meshes.</p><article><details class="docstring" open="true"><summary id="ExtendableFEMBase.lazy_interpolate!"><a class="docstring-binding" href="#ExtendableFEMBase.lazy_interpolate!"><code>ExtendableFEMBase.lazy_interpolate!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function lazy_interpolate!(
        target::FEVectorBlock{T1, Tv, Ti},
        source,
        operators = [(1, Identity)];
        postprocess! = standard_kernel,
        xtrafo! = nothing,
        items = [],
        resultdim = get_ncomponents(eltype(target.FES)),
        not_in_domain_value = 1.0e30,
        start_cell = 1,
        only_localsearch = false,
        use_cellparents::Bool = false,
        eps = 1.0e-13,
        kwargs...) where {T1, Tv, Ti}</code></pre><p>Interpolates (operator-evaluations of) the given FEVector source (or an array of FEVectorBlocks) into the finite element space assigned to the <code>target</code> FEVectorBlock.</p><p>The interpolation is performed using a point evaluation pattern and cell search. If <code>CellParents</code> information is available in the target grid, enabling <code>use_cellparents=true</code> can improve the efficiency of the search.</p><p>A custom postprocessing function can be provided via the <code>postprocess!</code> argument, which should have the interface:     postprocess!(result, input, qpinfo) where <code>result</code> is the output buffer, <code>input</code> is the operator evaluation, and <code>qpinfo</code> provides quadrature point information.</p><p>If the source and target grids have different coordinate dimensions, a coordinate transformation function <code>xtrafo!</code> must be provided, with the interface:     xtrafo!(x_source, x) which maps coordinates <code>x</code> from the target grid to coordinates in the source grid.</p><p>If a point cannot be found in the source grid, the value <code>not_in_domain_value</code> is used as the function value. The <code>items</code> argument can be used to restrict the interpolation to specific target cells.</p><p><strong>Arguments</strong></p><ul><li><code>target::FEVectorBlock</code>: The target finite element vector block.</li><li><code>source</code>: The source array of FEVectorBlocks.</li><li><code>operators</code>: Array of operator argument tuples (source block tag, operator type)  (default: <code>[(1, Identity)]</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>postprocess!</code>: Function to postprocess operator evaluations (default: <code>standard_kernel</code>).</li><li><code>xtrafo!</code>: Optional coordinate transformation function (default: <code>nothing</code>).</li><li><code>items</code>: List of target cells to interpolate (default: <code>[]</code>).</li><li><code>resultdim</code>: Result dimension (default: <code>get_ncomponents(eltype(target.FES))</code>).</li><li><code>not_in_domain_value</code>: Value assigned if a point is not found in the source domain (default: <code>1.0e30</code>).</li><li><code>start_cell</code>: Starting cell index for cell search (default: <code>1</code>).</li><li><code>only_localsearch</code>: Restrict cell search to local neighborhood (default: <code>false</code>).</li><li><code>use_cellparents</code>: Use parent cell information for search (default: <code>false</code>).</li><li><code>eps</code>: Tolerance for cell search (default: <code>1.0e-13</code>).</li><li><code>kwargs...</code>: Additional keyword arguments passed to <code>interpolate!</code>.</li></ul><p><strong>Notes</strong></p><ul><li>Discontinuous quantities at target grid vertices are evaluated in the first found cell of the source grid; no averaging is performed.</li><li>The function is not the most efficient for large-scale problems due to its reliance on pointwise cell search.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/lazy_interpolate.jl#L1-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExtendableFEMBase.compute_lazy_interpolation_jacobian"><a class="docstring-binding" href="#ExtendableFEMBase.compute_lazy_interpolation_jacobian"><code>ExtendableFEMBase.compute_lazy_interpolation_jacobian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function compute_lazy_interpolation_jacobian(
    target_space::FESpace, 
    source_space::FESpace; 
    use_cellparents::Bool = false,
    kwargs...
)</code></pre><p>Compute the Jacobian of the <a href="#ExtendableFEMBase.lazy_interpolate!"><code>lazy_interpolate!</code></a> call with respect to the <code>source_space</code> degrees of freedom, i.e. for functions <span>$v = \sum_j \alpha_j \, \varphi_j$</span> of the <code>source_space</code> and the interpolation operator <span>$I(v) = \sum_k L_k(v)\,\phi_k = \sum_k L_k\left(\sum_j \alpha_j \varphi_j\right) \, \phi_k$</span> into the <code>target_space</code>, this function computes the jacobian <span>$\left[\frac{\partial L_k}{\partial \alpha_j}\right]_{k,\,j}$</span> and returns its sparse matrix representation.</p><p><strong>Arguments</strong></p><ul><li><code>target_space::FESpace</code>: Finite element space into which the interpolation <span>$I(v)$</span> is directed.</li><li><code>source_space::FESpace</code>: Finite element space from which <span>$v$</span> is taken.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>use_cellparents</code>: Use parent cell information if available (can speed up the calculation if the <code>target_space</code> is defined on a subgrid of <code>source_space</code>).</li><li><code>kwargs...</code>: Additional keyword arguments passed to lower-level <code>lazy_interpolate!</code> call.</li></ul><p><strong>Notes</strong></p><ul><li>Since <a href="#ExtendableFEMBase.lazy_interpolate!"><code>lazy_interpolate!</code></a> is based on evaluating functions from the <code>source_space</code></li></ul><p>using a <a href="../pointevaluators/#ExtendableFEMBase.PointEvaluator"><code>ExtendableFEMBase.PointEvaluator</code></a>, this should be used carefully on finer  grids as this is not the most efficient method, but will work out of the box for any  <code>source</code> and <code>target</code> spaces.</p><ul><li>This function can be used for computing prolongation or restriction operators if the <code>FESpace</code>s are defined on coarser/finer grids, respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolation_matrix_representations.jl#L1-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExtendableFEMBase.H1Pk_to_HDIVRT0_interpolator"><a class="docstring-binding" href="#ExtendableFEMBase.H1Pk_to_HDIVRT0_interpolator"><code>ExtendableFEMBase.H1Pk_to_HDIVRT0_interpolator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function H1Pk_to_HDIVRT0_interpolator(
    VRT0::FESpace,
    V1::FESpace
)</code></pre><p>Computes the interpolation matrix from the <a href="../fems/#ExtendableFEMBase.H1Pk"><code>H1Pk</code></a>-conforming source space <code>V1</code> into the <a href="../fems/#ExtendableFEMBase.HDIVRT0"><code>HDIVRT0</code></a>-conforming target space <code>VRT0</code> <em>defined on the same grid</em> and returns its sparse matrix representation.</p><p><strong>Arguments</strong></p><ul><li><code>VRT0::FESpace</code>: <a href="../fems/#ExtendableFEMBase.HDIVRT0"><code>HDIVRT0</code></a> target space into which the interpolation is directed.</li><li><code>V1::FESpace</code>: <a href="../fems/#ExtendableFEMBase.H1Pk"><code>H1Pk</code></a> source space from which the interpolant is taken.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolation_matrix_representations.jl#L61-L77">source</a></section></details></article><p>The following function continuously interpolates finite element function into a H1Pk space by point evaluations at the Lagrange nodes of the H1Pk element (averaged over all neighbours).</p><article><details class="docstring" open="true"><summary id="ExtendableFEMBase.continuify"><a class="docstring-binding" href="#ExtendableFEMBase.continuify"><code>ExtendableFEMBase.continuify</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function continuify(
	source::FEVectorBlock,
	operator = Identity;
	abs::Bool = false,
	broken = false,
	order = &quot;auto&quot;,
	factor = 1,
	regions::Array{Int,1} = [0]) where {T,Tv,Ti,FEType,APT}</code></pre><p>Interpolate the evaluation of an operator applied to a finite element function onto a continuous Lagrange finite element space (<code>H1Pk</code>), returning a new <code>FEVector</code> with the interpolated values.</p><p>This function performs nodal interpolation of the (possibly vector-valued) result of applying <code>operator</code> to the FE function represented by <code>source</code>. The result is a new FE function in a continuous Lagrange space of the specified order and dimension. If <code>broken = true</code>, the interpolation is performed in a piecewise (discontinuous) fashion.</p><p><strong>Arguments</strong></p><ul><li><code>source</code>: The <code>FEVectorBlock</code> containing the coefficients of the original FE function.</li><li><code>operator</code>: The function operator to apply before interpolation (default: <code>Identity</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>abs</code>: If <code>true</code>, interpolate the Euclidean norm of the result (default: <code>false</code>).</li><li><code>broken</code>: If <code>true</code>, generate a piecewise (discontinuous) interpolation (default: <code>false</code>).</li><li><code>order</code>: Polynomial order of the target Lagrange space (default: <code>&quot;auto&quot;</code>, which chooses an appropriate order).</li><li><code>factor</code>: Scaling factor applied to the result before interpolation (default: <code>1</code>).</li><li><code>regions</code>: List of region indices to restrict interpolation (default: all regions).</li></ul><p><strong>Returns</strong></p><ul><li>A new <code>FEVector</code> in a continuous (or broken) Lagrange space, containing the interpolated values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolations.jl#L691-L721">source</a></section></details></article><h2 id="Nodal-Evaluations"><a class="docs-heading-anchor" href="#Nodal-Evaluations">Nodal Evaluations</a><a id="Nodal-Evaluations-1"></a><a class="docs-heading-anchor-permalink" href="#Nodal-Evaluations" title="Permalink"></a></h2><p>Plotting routines require nodal values, i.e., the values of a finite element function at the mesh nodes. The generic <code>nodevalues!</code> function evaluates any finite element function at the grid nodes, averaging values if the function is discontinuous. For H1-conforming finite elements and identity evaluations, the <code>nodevalues_view</code> function can provide a direct view into the coefficient field, avoiding unnecessary memory allocations.</p><article><details class="docstring" open="true"><summary id="ExtendableFEMBase.nodevalues!"><a class="docstring-binding" href="#ExtendableFEMBase.nodevalues!"><code>ExtendableFEMBase.nodevalues!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function nodevalues!(
        target::AbstractArray{&lt;:Real,2},
        source::AbstractArray{T,1},
        FE::FESpace{Tv,Ti,FEType,AT},
        operator::Type{&lt;:AbstractFunctionOperator} = Identity;
        abs::Bool = false,
        factor = 1,
        regions::Array{Int,1} = [0],
        target_offset::Int = 0,
        source_offset::Int = 0,
        zero_target::Bool = true,
        continuous::Bool = false
    )</code></pre><p>Evaluate a finite element function (given by the coefficient vector <code>source</code> and FE space <code>FE</code>) at all nodes of the grid, applying an optional function operator, and write the results into <code>target</code>.</p><p>By default, the function is evaluated at every node in the mesh. If <code>continuous</code> is <code>false</code>, the value at each node is averaged over all neighboring cells (suitable for discontinuous quantities). If <code>continuous</code> is <code>true</code>, the value is taken from a single cell per node (suitable for continuous quantities). The result can optionally be scaled, offset, or restricted to specific regions.</p><p><strong>Arguments</strong></p><ul><li><code>target</code>: Output array to store the evaluated values (size: result dimension × number of nodes).</li><li><code>source</code>: Coefficient vector for the FE function.</li><li><code>FE</code>: The finite element space.</li><li><code>operator</code>: Function operator to apply at each node (default: <code>Identity</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>abs</code>: If <code>true</code>, store the Euclidean norm of the result at each node (default: <code>false</code>).</li><li><code>factor</code>: Scaling factor applied to the result (default: <code>1</code>).</li><li><code>regions</code>: List of region indices to restrict evaluation (default: all regions).</li><li><code>target_offset</code>: Offset for writing into <code>target</code> (default: <code>0</code>).</li><li><code>source_offset</code>: Offset for reading from <code>source</code> (default: <code>0</code>).</li><li><code>zero_target</code>: If <code>true</code>, zero out <code>target</code> before writing (default: <code>true</code>).</li><li><code>continuous</code>: If <code>true</code>, evaluate only once per node; otherwise, average over all neighboring cells (default: <code>false</code>).</li></ul><p><strong>Notes</strong></p><ul><li>The result dimension is determined by the FE space, the operator, and the <code>abs</code> argument.</li><li>The function modifies <code>target</code> in-place.</li><li>For vector-valued or higher-dimensional results, the first dimension of <code>target</code> corresponds to the result dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolations.jl#L259-L300">source</a></section><section><div><p>Convenience method: Evaluate a finite element function (given by the FEVectorBlock), applying an optional function operator, and write the results into <code>target</code>.</p><p>This forwards to the main nodevalues! method using a view of the block&#39;s entries and its FESpace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolations.jl#L912-L916">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExtendableFEMBase.nodevalues"><a class="docstring-binding" href="#ExtendableFEMBase.nodevalues"><code>ExtendableFEMBase.nodevalues</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">    nodevalues(
        source::FEVectorBlock,
        operator::Type{&lt;:AbstractFunctionOperator} = Identity;
        continuous = &quot;auto&quot;,
        nodes = [],
        cellwise = false,
        abs = false,
        kwargs...
    )</code></pre><p>Evaluate a finite element function (given by the coefficient vector <code>source</code>) at nodes of the grid, applying an optional function operator, and return the result as a newly allocated array of the appropriate size.</p><p>This function provides a flexible interface for extracting nodal or cellwise values from a finite element solution. By default, it evaluates at all nodes, but a subset of nodes can be specified. The result can be returned in a cellwise (piecewise) layout if desired.</p><p><strong>Arguments</strong></p><ul><li><code>source</code>: The <code>FEVectorBlock</code> containing the coefficients of the FE function.</li><li><code>operator</code>: The function operator to apply at each node (default: <code>Identity</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>continuous</code>: If <code>&quot;auto&quot;</code>, automatically choose continuous/discontinuous evaluation based on FE type and operator. If <code>true</code>, evaluate only once per node; if <code>false</code>, average over all neighboring cells. Is ignored when <code>cellwise</code> is <code>true</code>.</li><li><code>nodes</code>: List of node indices to evaluate (default: all nodes).</li><li><code>cellwise</code>: If <code>true</code>, return values in a cellwise (piecewise) layout (default: <code>false</code>).</li><li><code>abs</code>: If <code>true</code>, return the Euclidean norm at each node (default: <code>false</code>).</li><li><code>kwargs...</code>: Additional keyword arguments passed to lower-level routines (e.g., <code>regions</code>, <code>factor</code>, <code>target_offset</code>, <code>zero_target</code>, etc.).</li></ul><p><strong>Returns</strong></p><ul><li>A newly allocated array containing the evaluated values, with shape depending on the options chosen.</li></ul><p><strong>Notes</strong></p><ul><li>If <code>nodes</code> is empty, all nodes are evaluated.</li><li>If <code>cellwise</code> is <code>true</code>, the result is organized per cell (suitable for discontinuous or element-wise quantities).</li><li>The result dimension is determined by the FE space, the operator, and the <code>abs</code> argument.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolations.jl#L557-L592">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExtendableFEMBase.nodevalues_view"><a class="docstring-binding" href="#ExtendableFEMBase.nodevalues_view"><code>ExtendableFEMBase.nodevalues_view</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function nodevalues_view(
	source::FEVectorBlock,
	operator::Type{&lt;:AbstractFunctionOperator} = Identity)</code></pre><p>Return a vector of views into the nodal values of the given finite element function, allowing direct access to the underlying coefficient storage for each component.</p><p>This function provides efficient, zero-copy access to the nodal values of an <code>FEVectorBlock</code> for unbroken H1-conforming finite element spaces with the identity operator. Each entry in the returned vector is a view into the coefficients corresponding to one component of the FE function, optionally restricted to a subset of nodes.</p><p><strong>Arguments</strong></p><ul><li><code>source</code>: The <code>FEVectorBlock</code> containing the coefficients of the FE function.</li><li><code>operator</code>: The function operator to apply (must be <code>Identity</code> for direct views; default: <code>Identity</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>nodes</code>: List of node indices to view (default: all nodes).</li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>SubArray</code> views, one for each component, directly referencing the coefficients for the specified nodes.</li></ul><p><strong>Notes</strong></p><ul><li>Only available for unbroken H1-conforming elements and the Identity operator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolations.jl#L632-L656">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExtendableFEMBase.nodevalues_subset!"><a class="docstring-binding" href="#ExtendableFEMBase.nodevalues_subset!"><code>ExtendableFEMBase.nodevalues_subset!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function nodevalues_subset!(
	target::AbstractArray{&lt;:Real,2},
	source::AbstractArray{T,1},
	FE::FESpace{Tv,Ti,FEType,AT},
	operator::Type{&lt;:AbstractFunctionOperator} = Identity;
	regions::Array{Int,1} = [0],
	abs::Bool = false,
	factor = 1,
	nodes = [],				  
	target_offset::Int = 0,   # start to write into target after offset
	zero_target::Bool = true, # target vector is zeroed
	continuous::Bool = false)</code></pre><p>Evaluate (an operator of) a finite element function (given by the coefficient vector <code>source</code> and FE space <code>FE</code>) at a specified subset of nodes, and write the results into <code>target</code>.</p><p>For each node in <code>nodes</code>, the function is evaluated (optionally with <code>operator</code>) and the result is written to the corresponding column of <code>target</code>. If <code>continuous</code> is <code>false</code>, values are averaged over all neighboring cells; if <code>true</code>, only one cell is used per node. If <code>abs</code> is <code>true</code>, the Euclidean norm is computed instead of the raw values.</p><p><strong>Arguments</strong></p><ul><li><code>target</code>: Output array to store the evaluated values (size: result dimension × number of nodes).</li><li><code>source</code>: Coefficient vector for the FE function.</li><li><code>FE</code>: The finite element space.</li><li><code>operator</code>: Function operator to apply (default: <code>Identity</code>).</li><li><code>abs</code>: If <code>true</code>, store the Euclidean norm of the result at each node (default: <code>false</code>).</li><li><code>factor</code>: Scaling factor applied to the result (default: <code>1</code>).</li><li><code>nodes</code>: List of node indices to evaluate (default: all nodes).</li><li><code>regions</code>: List of region indices to restrict evaluation (default: all regions).</li><li><code>target_offset</code>: Offset for writing into <code>target</code> (default: <code>0</code>).</li><li><code>source_offset</code>: Offset for reading from <code>source</code> (default: <code>0</code>).</li><li><code>zero_target</code>: If <code>true</code>, zero out <code>target</code> before writing (default: <code>true</code>).</li><li><code>continuous</code>: If <code>true</code>, evaluate only once per node; otherwise, average over all neighboring cells (default: <code>false</code>).</li></ul><p><strong>Notes</strong></p><ul><li>The result dimension is determined by the FE space and operator and the <code>abs</code> argument.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolations.jl#L94-L130">source</a></section></details></article><h2 id="Displace-Mesh"><a class="docs-heading-anchor" href="#Displace-Mesh">Displace Mesh</a><a id="Displace-Mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Displace-Mesh" title="Permalink"></a></h2><p>Nodal values (e.g. of a FEVector that discretizes a displacement) can be used to displace the mesh.</p><article><details class="docstring" open="true"><summary id="ExtendableFEMBase.displace_mesh!"><a class="docstring-binding" href="#ExtendableFEMBase.displace_mesh!"><code>ExtendableFEMBase.displace_mesh!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function displace_mesh!(xgrid::ExtendableGrid, source::FEVectorBlock; magnify = 1)</code></pre><p>Displace all nodes of the given grid by adding a vector-valued finite element field as a displacement, scaled by an optional magnification factor.</p><p>This function modifies the coordinates of <code>xgrid</code> in-place by adding the nodal values of the FE function represented by <code>source</code> (typically a displacement field) to each node. The displacement can be scaled by the <code>magnify</code> parameter. After the update, all cached geometric quantities in the grid are invalidated and recomputed.</p><p><strong>Arguments</strong></p><ul><li><code>xgrid</code>: The <code>ExtendableGrid</code> whose node coordinates will be updated.</li><li><code>source</code>: An <code>FEVectorBlock</code> representing the displacement field (must be vector-valued and defined on the grid).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>magnify</code>: Scaling factor for the displacement field (default: <code>1</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolations.jl#L856-L871">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExtendableFEMBase.displace_mesh"><a class="docstring-binding" href="#ExtendableFEMBase.displace_mesh"><code>ExtendableFEMBase.displace_mesh</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function displace_mesh(xgrid::ExtendableGrid, source::FEVectorBlock; magnify = 1)</code></pre><p>Return a new grid with node coordinates displaced by a vector-valued finite element field, optionally scaled by a magnification factor.</p><p><strong>Arguments</strong></p><ul><li><code>xgrid</code>: The <code>ExtendableGrid</code> to be copied and displaced.</li><li><code>source</code>: An <code>FEVectorBlock</code> representing the displacement field (must be vector-valued and defined on the grid).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>magnify</code>: Scaling factor for the displacement field (default: <code>1</code>).</li></ul><p><strong>Returns</strong></p><ul><li>A new <code>ExtendableGrid</code> with displaced node coordinates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEMBase.jl/blob/e517554c1df1b421bfcb1fffe690febf4af2be96/src/interpolations.jl#L889-L905">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../feevaluator/">« FEEvaluator</a><a class="docs-footer-nextpage" href="../quadrature/">Quadrature »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 28 January 2026 11:33">Wednesday 28 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
